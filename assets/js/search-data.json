{
  
    
        "post0": {
            "title": "15684 사다리 조작",
            "content": "1. 문제 설명 . 2. 입력 . 3. 출력 . 4. 예제 . 5. 접근법 . 6. 시간 복잡도 . 7. 공간 복잡도 . 8. 놓친 점 . 9. 기억할 것 . 10. 코드 . . 11. 이전 풀이와 달라진 점(개선) .",
            "url": "https://eunkyung99.github.io/gang/simulation/bruteforce/baekjoon/2022/03/16/algorithm19.html",
            "relUrl": "/simulation/bruteforce/baekjoon/2022/03/16/algorithm19.html",
            "date": " • Mar 16, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "15683 감시",
            "content": "1. 문제 설명 . 스타트링크의 사무실은 1×1크기의 정사각형으로 나누어져 있는 N×M 크기의 직사각형으로 나타낼 수 있다. 사무실에는 총 K개의 CCTV가 설치되어져 있는데, CCTV는 5가지 종류가 있다. 각 CCTV가 감시할 수 있는 방법은 다음과 같다. . . 1번 | 2번 | 3번 | 4번 | 5번 | . 1번 CCTV는 한 쪽 방향만 감시할 수 있다. 2번과 3번은 두 방향을 감시할 수 있는데, 2번은 감시하는 방향이 서로 반대방향이어야 하고, 3번은 직각 방향이어야 한다. 4번은 세 방향, 5번은 네 방향을 감시할 수 있다. . CCTV는 감시할 수 있는 방향에 있는 칸 전체를 감시할 수 있다. 사무실에는 벽이 있는데, CCTV는 벽을 통과할 수 없다. CCTV가 감시할 수 없는 영역은 사각지대라고 한다. . CCTV는 회전시킬 수 있는데, 회전은 항상 90도 방향으로 해야 하며, 감시하려고 하는 방향이 가로 또는 세로 방향이어야 한다. . 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 6 0 0 0 0 0 0 0 . 지도에서 0은 빈 칸, 6은 벽, 1~5는 CCTV의 번호이다. 위의 예시에서 1번의 방향에 따라 감시할 수 있는 영역을 ‘#‘로 나타내면 아래와 같다. . 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 # 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 # # 1 0 6 0 0 0 0 0 0 0 0 0 # 0 0 0 0 0 # 0 0 0 0 0 1 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 6 0 0 0 # 0 0 0 . → | ← | ↑ | ↓ | . CCTV는 벽을 통과할 수 없기 때문에, 1번이 → 방향을 감시하고 있을 때는 6의 오른쪽에 있는 칸을 감시할 수 없다. . 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 6 0 0 6 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 5 . 위의 예시에서 감시할 수 있는 방향을 알아보면 아래와 같다. . 0 0 0 0 0 # # 2 # # # # 0 0 0 0 6 # 0 6 # # 2 # 0 0 0 0 0 # # # # # # 5 0 0 0 0 0 # # 2 # # # # 0 0 0 0 6 # 0 6 0 0 2 # 0 0 0 0 # # # # # # # 5 0 # 0 0 0 # 0 2 0 0 0 # 0 # 0 0 6 # 0 6 # # 2 # 0 0 0 0 0 # # # # # # 5 0 # 0 0 0 # 0 2 0 0 0 # 0 # 0 0 6 # 0 6 0 0 2 # 0 0 0 0 # # # # # # # 5 . 왼쪽 상단 2: ↔, 오른쪽 하단 2: ↔ | 왼쪽 상단 2: ↔, 오른쪽 하단 2: ↕ | 왼쪽 상단 2: ↕, 오른쪽 하단 2: ↔ | 왼쪽 상단 2: ↕, 오른쪽 하단 2: ↕ | . CCTV는 CCTV를 통과할 수 있다. 아래 예시를 보자. . 0 0 2 0 3 0 6 0 0 0 0 0 6 6 0 0 0 0 0 0 . 위와 같은 경우에 2의 방향이 ↕ 3의 방향이 ←와 ↓인 경우 감시받는 영역은 다음과 같다. . # # 2 # 3 0 6 # 0 # 0 0 6 6 # 0 0 0 0 # . 사무실의 크기와 상태, 그리고 CCTV의 정보가 주어졌을 때, CCTV의 방향을 적절히 정해서, 사각 지대의 최소 크기를 구하는 프로그램을 작성하시오. . 2. 입력 . 첫째 줄에 사무실의 세로 크기 N과 가로 크기 M이 주어진다. (1 ≤ N, M ≤ 8) . 둘째 줄부터 N개의 줄에는 사무실 각 칸의 정보가 주어진다. 0은 빈 칸, 6은 벽, 1~5는 CCTV를 나타내고, 문제에서 설명한 CCTV의 종류이다. . CCTV의 최대 개수는 8개를 넘지 않는다. . 3. 출력 . 첫째 줄에 사각 지대의 최소 크기를 출력한다. . 4. 예제 . . 5. 접근법 . 입력받을 때 cctv가 존재하는 행과 열의 정보를 v 벡터에 삽입 . cctv 벡터의 인덱스 0부터 하여 Bruteforce 함수를 호출 . Bruteforce(int idx) 함수 구현 . 종료 조건: idx == v.size() cctv를 모두 배치했을 경우 0인 원소를 찾아 개수를 센다. | 센 개수가 answer보다 작으면 갱신 | . | cctvR, cctvC 초기화 - 해당 칸의 cctv가 몇 번인지에 따라 if 문 수행 1번 cctv의 경우 i : 0~3으로 변경하며 nr, nc가 벽 또는 맵의 끝을 만날 때까지 해당 방향(i)에 표시 | Bruteforce(idx+1)을 호출하여 다음 cctv 배치 | nr, nc를 다시 cctvR, cctvC부터 시작해 벽 또는 맵의 끝을 만날 때까지 해당 방향을 다시 돌면서 원상복귀 | . | 2번 cctv의 경우 위 1번 cctv의 로직과 동일 | i를 0~1로 변경하고 i와 i+2 방향에 표시(정반대) | . | 3번 cctv의 경우 위 1번 cctv의 로직과 동일 | i를 0~3으로 변경하고 i와 i+1 방향에 표시(직각) | . | 4번 cctv의 경우 위 1번 cctv의 로직과 동일 | i를 0~3으로 변경하고 i, i+1, i+2 세 방향에 표시 | . | 5번 cctv의 경우 5번의 경우 4방향 모두 탐색해야 하므로 4방향에 모두 표시를 해주고, 원상복구는 해줄 필요 없음 | Bruteforce(idx+1)호출 | . | . | 해당 방향에 감시 영역을 표시할 때 idx+9 값을 사용함 (다른 cctv의 영역과 겹칠 수 있으므로 구분 필요하다고 생각) -&gt; 원래 값이 0인 경우에만 값을 idx+9로 변경 | 원상복귀할 때도 값이 idx+9인 경우(즉 이번에 갱신한 경우)에만 0으로 다시 변경 | . 6. 시간 복잡도 . cctv의 개수 최대 8개 . 7. 공간 복잡도 . int 형 배열 9*9 . 8. 놓친 점 . 종료조건에서 return을 하지 않아 segfault error 발생(v.size() 번째 cctv 접근) . answer 값 초기화 0으로 함 - 최솟값이므로 9999로 설정 . 9. 기억할 것 . 감시 영역을 표시할 때 cctv 별로 구분해주기 위해 idx+9 값을 저장, 확인 시에 사용 . Bruteforce 함수의 종료 조건에 return 확인! . 원상복구 시 다시 되돌아가는 것보다 처음 값을 다시 설정해주고 똑같은 경로를 탐색하는 것이 코드 짜기 더 쉬움 . 10. 코드 . #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int N, M; int office[9][9]; int dr[4] = { 0, -1, 0, 1 }; //left up right down int dc[4] = { -1, 0, 1, 0 }; vector&lt;pair&lt;int, int&gt; &gt; v; //cctv int answer = 9999; void Bruteforce(int idx){ if(idx == v.size()){ //감시영역 세기 int cnt = 0; for(int i=0; i&lt;N; i++){ for(int j=0; j&lt;M; j++){ if(office[i][j] == 0){ cnt += 1; } } } answer = answer &gt; cnt ? cnt : answer; return; //segfault error } int cctvR = v[idx].first; int cctvC = v[idx].second; if(office[cctvR][cctvC] == 1){ for(int i=0; i&lt;4; i++){ int nr = cctvR; int nc = cctvC; while((0&lt;=nr &amp;&amp; nr&lt;N &amp;&amp; 0&lt;=nc &amp;&amp; nc&lt;M) &amp;&amp; office[nr][nc]!=6){ if(office[nr][nc] == 0){ office[nr][nc] = idx+9; } nr += dr[i]; nc += dc[i]; } Bruteforce(idx+1); //원상복구 nr = cctvR; nc = cctvC; while((0&lt;=nr &amp;&amp; nr&lt;N &amp;&amp; 0&lt;=nc &amp;&amp; nc&lt;M) &amp;&amp; office[nr][nc]!=6){ if(office[nr][nc] == idx+9){ office[nr][nc] = 0; } nr += dr[i]; nc += dc[i]; } } }else if(office[cctvR][cctvC] == 2){ for(int i=0; i&lt;2; i++){ int nr = cctvR; int nc = cctvC; while((0&lt;=nr &amp;&amp; nr&lt;N &amp;&amp; 0&lt;=nc &amp;&amp; nc&lt;M) &amp;&amp; office[nr][nc]!=6){ if(office[nr][nc] == 0){ office[nr][nc] = idx+9; } nr += dr[i]; nc += dc[i]; } nr = cctvR; nc = cctvC; while((0&lt;=nr &amp;&amp; nr&lt;N &amp;&amp; 0&lt;=nc &amp;&amp; nc&lt;M) &amp;&amp; office[nr][nc]!=6){ if(office[nr][nc] == 0){ office[nr][nc] = idx+9; } nr += dr[i+2]; nc += dc[i+2]; } Bruteforce(idx+1); //원상복구 nr = cctvR; nc = cctvC; while((0&lt;=nr &amp;&amp; nr&lt;N &amp;&amp; 0&lt;=nc &amp;&amp; nc&lt;M) &amp;&amp; office[nr][nc]!=6){ if(office[nr][nc] == idx+9){ office[nr][nc] = 0; } nr += dr[i]; nc += dc[i]; } nr = cctvR; nc = cctvC; while((0&lt;=nr &amp;&amp; nr&lt;N &amp;&amp; 0&lt;=nc &amp;&amp; nc&lt;M) &amp;&amp; office[nr][nc]!=6){ if(office[nr][nc] == idx+9){ office[nr][nc] = 0; } nr += dr[i+2]; nc += dc[i+2]; } } }else if(office[cctvR][cctvC] == 3){ for(int i=0; i&lt;4; i++){ int nr = cctvR; int nc = cctvC; while((0&lt;=nr &amp;&amp; nr&lt;N &amp;&amp; 0&lt;=nc &amp;&amp; nc&lt;M) &amp;&amp; office[nr][nc]!=6){ if(office[nr][nc] == 0){ office[nr][nc] = idx+9; } nr += dr[i]; nc += dc[i]; } nr = cctvR; nc = cctvC; while((0&lt;=nr &amp;&amp; nr&lt;N &amp;&amp; 0&lt;=nc &amp;&amp; nc&lt;M) &amp;&amp; office[nr][nc]!=6){ if(office[nr][nc] == 0){ office[nr][nc] = idx+9; } nr += dr[(i+1)%4]; nc += dc[(i+1)%4]; } Bruteforce(idx+1); //원상복구 nr = cctvR; nc = cctvC; while((0&lt;=nr &amp;&amp; nr&lt;N &amp;&amp; 0&lt;=nc &amp;&amp; nc&lt;M) &amp;&amp; office[nr][nc]!=6){ if(office[nr][nc] == idx+9){ office[nr][nc] = 0; } nr += dr[i]; nc += dc[i]; } nr = cctvR; nc = cctvC; while((0&lt;=nr &amp;&amp; nr&lt;N &amp;&amp; 0&lt;=nc &amp;&amp; nc&lt;M) &amp;&amp; office[nr][nc]!=6){ if(office[nr][nc] == idx+9){ office[nr][nc] = 0; } nr += dr[(i+1)%4]; nc += dc[(i+1)%4]; } } }else if(office[cctvR][cctvC] == 4){ for(int i=0; i&lt;4; i++){ int nr = cctvR; int nc = cctvC; while((0&lt;=nr &amp;&amp; nr&lt;N &amp;&amp; 0&lt;=nc &amp;&amp; nc&lt;M) &amp;&amp; office[nr][nc]!=6){ if(office[nr][nc] == 0){ office[nr][nc] = idx+9; } nr += dr[i]; nc += dc[i]; } nr = cctvR; nc = cctvC; while((0&lt;=nr &amp;&amp; nr&lt;N &amp;&amp; 0&lt;=nc &amp;&amp; nc&lt;M) &amp;&amp; office[nr][nc]!=6){ if(office[nr][nc] == 0){ office[nr][nc] = idx+9; } nr += dr[(i+1)%4]; nc += dc[(i+1)%4]; } nr = cctvR; nc = cctvC; while((0&lt;=nr &amp;&amp; nr&lt;N &amp;&amp; 0&lt;=nc &amp;&amp; nc&lt;M) &amp;&amp; office[nr][nc]!=6){ if(office[nr][nc] == 0){ office[nr][nc] = idx+9; } nr += dr[(i+2)%4]; nc += dc[(i+2)%4]; } Bruteforce(idx+1); nr = cctvR; nc = cctvC; while((0&lt;=nr &amp;&amp; nr&lt;N &amp;&amp; 0&lt;=nc &amp;&amp; nc&lt;M) &amp;&amp; office[nr][nc]!=6){ if(office[nr][nc] == idx+9){ office[nr][nc] = 0; } nr += dr[i]; nc += dc[i]; } nr = cctvR; nc = cctvC; while((0&lt;=nr &amp;&amp; nr&lt;N &amp;&amp; 0&lt;=nc &amp;&amp; nc&lt;M) &amp;&amp; office[nr][nc]!=6){ if(office[nr][nc] == idx+9){ office[nr][nc] = 0; } nr += dr[(i+1)%4]; nc += dc[(i+1)%4]; } nr = cctvR; nc = cctvC; while((0&lt;=nr &amp;&amp; nr&lt;N &amp;&amp; 0&lt;=nc &amp;&amp; nc&lt;M) &amp;&amp; office[nr][nc]!=6){ if(office[nr][nc] == idx+9){ office[nr][nc] = 0; } nr += dr[(i+2)%4]; nc += dc[(i+2)%4]; } } }else{ for(int i=0; i&lt;4; i++){ int nr = cctvR; int nc = cctvC; while((0&lt;=nr &amp;&amp; nr&lt;N &amp;&amp; 0&lt;=nc &amp;&amp; nc&lt;M) &amp;&amp; office[nr][nc]!=6){ if(office[nr][nc] == 0){ office[nr][nc] = idx+9; } nr += dr[i]; nc += dc[i]; } } Bruteforce(idx+1); } } int main(){ cin &gt;&gt; N &gt;&gt; M; for(int i=0; i&lt;N; i++){ for(int j=0; j&lt;M; j++){ cin &gt;&gt; office[i][j]; if(office[i][j] &gt; 0 &amp;&amp; office[i][j] &lt; 6){ v.push_back(make_pair(i, j)); } } } Bruteforce(0); cout &lt;&lt; answer &lt;&lt;&quot; n&quot;; return 0; } . 11. 이전 풀이와 달라진 점(개선) . 기본 로직과 idx+9로 초기화하는 점 등은 똑같음 | 원상복구 시 마지막 값에서 다시 원래 값이 될 때까지 빼줌 -&gt; 비슷하지만 다시 처음부터 시작하는 것이 덜 헷갈릴 것 같음 | .",
            "url": "https://eunkyung99.github.io/gang/simulation/bruteforce/baekjoon/2022/03/15/algorithm18.html",
            "relUrl": "/simulation/bruteforce/baekjoon/2022/03/15/algorithm18.html",
            "date": " • Mar 15, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "정렬2 가장 큰 수",
            "content": "1. 문제 설명 . 0 또는 양의 정수가 주어졌을 때, 정수를 이어 붙여 만들 수 있는 가장 큰 수를 알아내 주세요. . 예를 들어, 주어진 정수가 [6, 10, 2]라면 [6102, 6210, 1062, 1026, 2610, 2106]를 만들 수 있고, 이중 가장 큰 수는 6210입니다. . 0 또는 양의 정수가 담긴 배열 numbers가 매개변수로 주어질 때, 순서를 재배치하여 만들 수 있는 가장 큰 수를 문자열로 바꾸어 return 하도록 solution 함수를 작성해주세요. . 제한 사항 . numbers의 길이는 1 이상 100,000 이하입니다. | numbers의 원소는 0 이상 1,000 이하입니다. | 정답이 너무 클 수 있으니 문자열로 바꾸어 return 합니다. | . 2. 입.출력 및 예제 . numbers return . [6, 10, 2] | “6210” | . [3, 30, 34, 5, 9] | “9534330” | . 3. 접근법 . int형 벡터를 string으로 변환하여 새로운 벡터에 저장(to_string() 함수 사용) | comp 함수 작성(a+b와 b+a 중 더 큰 것을 앞으로) | sort 함수를 통해 정렬 | 정렬된 순서대로 답을 추가 첫 원소가 0인 경우 그 뒤 원소도 모두 0이므로 0을 리턴해야 함 | . | . 4. 시간 복잡도 . O(NlogN) 10만*log10만 . 5. 공간 복잡도 . string 형 벡터 . 6. 놓친 점 . 첫 원소가 0인 경우에만 0을 리턴해야 하는데 0이 나오면 0을 리턴하도록 하여 오답 . 반례: 8 80 7 0 인 경우 0붙어야 함 | 0 0 0 0 0 인 경우는 0이어야 함 | . 7. 기억할 것 . to_string() 함수를 통해 int형을 string형으로 변환 가능 . 반례가 없는지 검사 . 8. 코드 . #include &lt;string&gt; #include &lt;vector&gt; #include &lt;string&gt; #include &lt;algorithm&gt; using namespace std; bool comp(const string &amp;a, const string&amp; b){ return a+b &gt; b+a; } string solution(vector&lt;int&gt; numbers) { string answer = &quot;&quot;; vector&lt;string&gt; v; for(int i=0; i&lt;numbers.size(); i++){ v.push_back(to_string(numbers[i])); //to_string() 통해 문자열 변환 } sort(v.begin(), v.end(), comp); for(int i=0; i&lt;v.size(); i++){ if(v[0] == &quot;0&quot;){ //*****처음이 0인 경우에만 답이 0임! answer = &quot;0&quot;; break; } answer += v[i]; } return answer; } .",
            "url": "https://eunkyung99.github.io/gang/sort/programmers/2022/03/15/algorithm17.html",
            "relUrl": "/sort/programmers/2022/03/15/algorithm17.html",
            "date": " • Mar 15, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "14890 경사로",
            "content": "1. 문제 설명 . 크기가 N×N인 지도가 있다. 지도의 각 칸에는 그 곳의 높이가 적혀져 있다. . 오늘은 이 지도에서 지나갈 수 있는 길이 몇 개 있는지 알아보려고 한다. 길이란 한 행 또는 한 열 전부를 나타내며, 한쪽 끝에서 다른쪽 끝까지 지나가는 것이다. . 다음과 같은 N=6인 경우 지도를 살펴보자. . . 이때, 길은 총 2N개가 있으며, 아래와 같다. . . 길을 지나갈 수 있으려면 길에 속한 모든 칸의 높이가 모두 같아야 한다. 또는, 경사로를 놓아서 지나갈 수 있는 길을 만들 수 있다. 경사로는 높이가 항상 1이며, 길이는 L이다. 또, 개수는 매우 많아 부족할 일이 없다. 경사로는 낮은 칸과 높은 칸을 연결하며, 아래와 같은 조건을 만족해야한다. . 경사로는 낮은 칸에 놓으며, L개의 연속된 칸에 경사로의 바닥이 모두 접해야 한다. | 낮은 칸과 높은 칸의 높이 차이는 1이어야 한다. | 경사로를 놓을 낮은 칸의 높이는 모두 같아야 하고, L개의 칸이 연속되어 있어야 한다. | . 아래와 같은 경우에는 경사로를 놓을 수 없다. . 경사로를 놓은 곳에 또 경사로를 놓는 경우 | 낮은 칸과 높은 칸의 높이 차이가 1이 아닌 경우 | 낮은 지점의 칸의 높이가 모두 같지 않거나, L개가 연속되지 않은 경우 | 경사로를 놓다가 범위를 벗어나는 경우 | . L = 2인 경우에 경사로를 놓을 수 있는 경우를 그림으로 나타내면 아래와 같다. . . 경사로를 놓을 수 없는 경우는 아래와 같다. . . 위의 그림의 가장 왼쪽부터 1번, 2번, 3번, 4번 예제라고 했을 때, 1번은 높이 차이가 1이 아니라서, 2번은 경사로를 바닥과 접하게 놓지 않아서, 3번은 겹쳐서 놓아서, 4번은 기울이게 놓아서 불가능한 경우이다. . 가장 위에 주어진 그림 예의 경우에 지나갈 수 있는 길은 파란색으로, 지나갈 수 없는 길은 빨간색으로 표시되어 있으며, 아래와 같다. 경사로의 길이 L = 2이다. . . 지도가 주어졌을 때, 지나갈 수 있는 길의 개수를 구하는 프로그램을 작성하시오. . . 2. 입력 . 첫째 줄에 N (2 ≤ N ≤ 100)과 L (1 ≤ L ≤ N)이 주어진다. 둘째 줄부터 N개의 줄에 지도가 주어진다. 각 칸의 높이는 10보다 작거나 같은 자연수이다. . 3. 출력 . 첫째 줄에 지나갈 수 있는 길의 개수를 출력한다. . 4. 예제 . . 5. 접근법 . findRow()와 findCol() 함수를 구현하여 가로/세로의 가능한 경로 개수를 더해서 답을 출력 | findRow() 함수 구현 i를 0~N까지 돌며 해당 줄이 지나갈 수 있는 길인지 판단 | lastJ 값은 경사로를 놓을 수 있는 가장 앞 인덱스를 저장함(0으로 초기화) | flag는 한 번 감소가 됐을 경우 그 이후에 경사로를 놓을 수 있는지 검사해야 하므로 한 번 감소한 상황을 표시 | 0~N-2까지 j 값을 변경하면서 j번째 열(왼쪽)과 j+1번째 열(오른쪽)을 비교 같다면 만약 flag이고(감소한 전적이 있다면) 오른쪽 - lastJ + 1이 L개가 되면 경사로를 놓아야 함 | lastJ 값이 오른쪽+1(j+2)가 되고 flag false로 변경 | . | 1 증가했다면 이전 L개에 경사로를 놓을 수 있는지 확인 | 왼쪽(j) - lastJ + 1이 L 이상이면 경사로를 놓을 수 있으므로 lastJ를 오른쪽(j+1)으로 설정하고 continue | 경사로를 놓을 수 없으면 답이 될 수 없음(break) | . | 1 감소했다면 lastJ를 오른쪽(j+1)으로 설정하고 flag 값 on | L이 1일 경우 j+1에 경사로를 놓으면 되므로 lastJ를 j+2로 설정하고 flag는 false 유지 | . | 이외(2 이상 차이) - 답이 될 수 없음 | . | 1 증가하거나 1 감소했을 때에도 flag 값을 검사해서 만약 켜져 있다면, 즉 이전에 감소했던 부분이 경사로 처리가 안 됐다면 답이 될 수 없음 | 열을 다 돌고 나서 flag 값이 꺼져 있고 답이 될 수 있으면 지나갈 수 있는 길이므로 count해준다. | . | findCol() 역시 findRow()와 똑같이 구현 - i와 j만 바꿔주면 됨 | . 6. 시간 복잡도 . O(N^2) 20000 &lt; 2초 . 7. 공간 복잡도 . int형 배열 10000 &lt; 512MB . 8. 놓친 점 . L이 1인 경우는 경사로를 바로 놓아줄 수 있음을 간과함 - 힌트를 보고 빨리 알았음 . 9. 기억할 것 . 예외가 없는지 잘 생각하고 구현하자. 조건 최대한 다 생각하고 검사하자. . 10. 코드 . #include &lt;iostream&gt; using namespace std; int N, L; int road[101][101]; int ans = 0; int findRow(){ int answer = 0; for(int i=0; i&lt;N; i++){ bool canBeAnswer = true; bool flag = false; //감소 체크해야 하는지 저장하는 flag int lastJ = 0; for(int j=0; j+1&lt;N; j++){ if(road[i][j] == road[i][j+1]){ if(flag &amp;&amp; (j+1 - lastJ + 1 == L)){ lastJ = j+2; flag = false; } }else if(road[i][j] + 1 == road[i][j+1]){ //증가 //lastJ ~ j까지 경사로를 놓아야 함 if(flag){ //감소하는 거 처리가 안 된 경우 canBeAnswer = false; break; } if(j - lastJ + 1 &gt;= L){ lastJ = j+1; }else{ //경사로를 놓을 수 없는 경우 canBeAnswer = false; break; } }else if(road[i][j] - 1 == road[i][j+1]){ //감소 2 3 3 3 2 2 2 if(flag){ //감소하는거 처리가 안 된 경우 canBeAnswer = false; break; } if(L &gt; 1){ //****** lastJ = j+1; flag = true; }else{ //*********** L이 1인 경우는 플래그 처리 필요 없이 j+1에 경사로 놓았다고 가정!!! lastJ = j+2; } }else{ //차이가 2 이상 나면 불가능 canBeAnswer = false; break; } } if(!flag &amp;&amp; canBeAnswer){ answer++; } } return answer; } int findCol(){ int answer = 0; for(int j=0; j&lt;N; j++){ bool canBeAnswer = true; bool flag = false; int lastI = 0; for(int i=0; i+1&lt;N; i++){ if(road[i][j] == road[i+1][j]){ if(flag &amp;&amp; (i+1 - lastI + 1 == L)){ lastI = i+2; flag = false; } }else if(road[i][j] + 1 == road[i+1][j]){ if(flag){ canBeAnswer = false; break; } if(i - lastI + 1 &gt;= L){ lastI = i+1; }else{ canBeAnswer = false; break; } }else if(road[i][j] - 1 == road[i+1][j]){ if(flag){ canBeAnswer = false; break; } if(L &gt; 1){ lastI = i+1; flag = true; }else{ lastI = i+2; } }else{ canBeAnswer = false; break; } } if(!flag &amp;&amp; canBeAnswer){ answer++; } } return answer; } int main(){ ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; N &gt;&gt; L; for(int i=0; i&lt;N; i++){ for(int j=0; j&lt;N; j++){ cin &gt;&gt; road[i][j]; } } cout &lt;&lt; findRow() + findCol() &lt;&lt;&quot; n&quot;; return 0; } . 11. 이전 풀이와 달라진 점(개선) . 이전 풀이에서는 별도 배열을 2개 놓고(행/열 용) 실제로 경사로를 놓아가면서 검사했음 - 코드가 길어지고 처음인 경우 별도 처리해줌 | lastJ에 경사로의 인덱스 값을 저장해주면서 코드가 간결해짐 | .",
            "url": "https://eunkyung99.github.io/gang/simulation/baekjoon/2022/03/14/algorithm16.html",
            "relUrl": "/simulation/baekjoon/2022/03/14/algorithm16.html",
            "date": " • Mar 14, 2022"
        }
        
    
  
    
        ,"post4": {
            "title": "해시2 전화번호 목록",
            "content": "1. 문제 설명 . 전화번호부에 적힌 전화번호 중, 한 번호가 다른 번호의 접두어인 경우가 있는지 확인하려 합니다. 전화번호가 다음과 같을 경우, 구조대 전화번호는 영석이의 전화번호의 접두사입니다. . 구조대 : 119 | 박준영 : 97 674 223 | 지영석 : 11 9552 4421 | . 전화번호부에 적힌 전화번호를 담은 배열 phone_book 이 solution 함수의 매개변수로 주어질 때, 어떤 번호가 다른 번호의 접두어인 경우가 있으면 false를 그렇지 않으면 true를 return 하도록 solution 함수를 작성해주세요. . 제한 사항 . phone_book의 길이는 1 이상 1,000,000 이하입니다. 각 전화번호의 길이는 1 이상 20 이하입니다. | 같은 전화번호가 중복해서 들어있지 않습니다. | . | . 2. 입.출력 및 예제 . 입출력 예제 . phone_book return . [“119”, “97674223”, “1195524421”] | false | . [“123”,”456”,”789”] | true | . [“12”,”123”,”1235”,”567”,”88”] | false | . 입출력 예 설명 . 입출력 예 #1 앞에서 설명한 예와 같습니다. . 입출력 예 #2 한 번호가 다른 번호의 접두사인 경우가 없으므로, 답은 true입니다. . 입출력 예 #3 첫 번째 전화번호, “12”가 두 번째 전화번호 “123”의 접두사입니다. 따라서 답은 false입니다. . 3. 접근법 . 풀이 1 - 해시 unordered_map을 정의하고 전화번호 목록을 돌면서 해시 맵에 기록한다 | 빈 문자열부터 시작해서 i번째 원소의 부분 문자열을 앞에서부터 하나씩 추가해준다. (이때 원소의 마지막까지, 즉 전체 문자열이 되지 않도록 주의) 원소가 119라면 11까지만 추가 | 부분 문자열의 해시 맵 값이 1이면 접두사가 존재하므로 false를 리턴한다. | | 풀이 2 - 정렬 문자열 벡터를 정렬하면 사전순으로 정렬이 됨 | 정렬 후 처음부터 돌면서 인접한 두 원소가 같은지 검사한다. 두 번째 원소를 처음부터 첫번째 원소의 길이만큼 잘라서 비교함 | 같은 경우가 존재하면 접두사이므로 false 리턴 | | 4. 시간 복잡도 . O(NM) 1000000*20(최악) . 5. 공간 복잡도 . unordered_map(100만) . 6. 놓친 점 . 해시를 이용한 풀이 방법 잘 생각해보자 . 해시 풀이에서 부분 문자열을 추가해줄 때 마지막 원소 전까지만 추가하도록 하는 것에 주의 . 7. 기억할 것 . string 벡터를 정렬할 시 숫자 순서대로가 아니라 사전 순 정렬(11-112-12 …) . 8. 코드 . //풀이1 - 해시 #include &lt;string&gt; #include &lt;vector&gt; #include &lt;unordered_map&gt; using namespace std; bool solution(vector&lt;string&gt; phone_book) { unordered_map&lt;string, int&gt; um; for(int i=0; i&lt;phone_book.size(); i++){ um[phone_book[i]] = 1; } for(int i=0; i&lt;phone_book.size(); i++){ string s = &quot;&quot;; for(int j=0; j&lt;phone_book[i].size() - 1; j++){ //***** i의 길이-1 s = s + phone_book[i][j]; if(um[s] == 1){ return false; } } } return true; } //풀이2 - 정렬 #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; bool solution(vector&lt;string&gt; phone_book) { bool answer = true; sort(phone_book.begin(), phone_book.end()); for(int i=0; i&lt;phone_book.size()-1; i++){ if(phone_book[i] == phone_book[i+1].substr(0, phone_book[i].size())){ answer = false; break; } } return answer; } .",
            "url": "https://eunkyung99.github.io/gang/hash/programmers/2022/03/14/algorithm15.html",
            "relUrl": "/hash/programmers/2022/03/14/algorithm15.html",
            "date": " • Mar 14, 2022"
        }
        
    
  
    
        ,"post5": {
            "title": "스택/큐2 프린터",
            "content": "1. 문제 설명 . 일반적인 프린터는 인쇄 요청이 들어온 순서대로 인쇄합니다. 그렇기 때문에 중요한 문서가 나중에 인쇄될 수 있습니다. 이런 문제를 보완하기 위해 중요도가 높은 문서를 먼저 인쇄하는 프린터를 개발했습니다. 이 새롭게 개발한 프린터는 아래와 같은 방식으로 인쇄 작업을 수행합니다. . 1. 인쇄 대기목록의 가장 앞에 있는 문서(J)를 대기목록에서 꺼냅니다. 2. 나머지 인쇄 대기목록에서 J보다 중요도가 높은 문서가 한 개라도 존재하면 J를 대기목록의 가장 마지막에 넣습니다. 3. 그렇지 않으면 J를 인쇄합니다. . 예를 들어, 4개의 문서(A, B, C, D)가 순서대로 인쇄 대기목록에 있고 중요도가 2 1 3 2 라면 C D A B 순으로 인쇄하게 됩니다. . 내가 인쇄를 요청한 문서가 몇 번째로 인쇄되는지 알고 싶습니다. 위의 예에서 C는 1번째로, A는 3번째로 인쇄됩니다. . 현재 대기목록에 있는 문서의 중요도가 순서대로 담긴 배열 priorities와 내가 인쇄를 요청한 문서가 현재 대기목록의 어떤 위치에 있는지를 알려주는 location이 매개변수로 주어질 때, 내가 인쇄를 요청한 문서가 몇 번째로 인쇄되는지 return 하도록 solution 함수를 작성해주세요. . 제한사항 . 현재 대기목록에는 1개 이상 100개 이하의 문서가 있습니다. | 인쇄 작업의 중요도는 1~9로 표현하며 숫자가 클수록 중요하다는 뜻입니다. | location은 0 이상 (현재 대기목록에 있는 작업 수 - 1) 이하의 값을 가지며 대기목록의 가장 앞에 있으면 0, 두 번째에 있으면 1로 표현합니다. | . 2. 입.출력 및 예제 . priorities location return . [2, 1, 3, 2] | 2 | 1 | . [1, 1, 9, 1, 1, 1] | 0 | 5 | . 입출력 예 설명 . 예제 #1 . 문제에 나온 예와 같습니다. . 예제 #2 . 6개의 문서(A, B, C, D, E, F)가 인쇄 대기목록에 있고 중요도가 1 1 9 1 1 1 이므로 C D E F A B 순으로 인쇄합니다. . 3. 접근법 . 중요도 값과 궁금한 문서인지를 저장하는 구조체 정의 | 구조체를 사용한 우선순위큐를 정의한 후 우선순위큐에 넣어준다. | 구조체 벡터에 초기 상태들을 다 삽입한다. | 큐에서 가장 큰 값을 저장한다. 벡터의 0번째 원소를 뽑은 다음(pop) 이 값이 현재 가장 큰 값(큐의 top)보다 작으면 벡터에 다시 넣고, 같거나 크면 인쇄가 되므로 큐에서 값을 뽑는다.(pop) 이때는 인쇄가 됐으므로 answer 값을 증가시키고, 만약 큐의 값이 같은 경우 isloc 검사를 하여 궁금한 문서라면 반복문을 종료한다. | 4. 시간 복잡도 . O(N*N) 100 * 100 . 5. 공간 복잡도 . 구조체(int, bool), 구조체 벡터, 구조체 우선순위큐 . 6. 놓친 점 . 인쇄가 안 되는 경우(맨 앞이 최대 중요도가 아닐 때) 큐에서 pop하면 안 됨!! . 7. 기억할 것 . 없음 . 8. 코드 . #include &lt;string&gt; #include &lt;vector&gt; #include &lt;queue&gt; #include &lt;iostream&gt; using namespace std; struct Info{ int value; bool isloc; }; struct compare{ bool operator()(const Info&amp; a, const Info&amp; b){ if(a.value &lt; b.value){ return true; } return false; } }; int solution(vector&lt;int&gt; priorities, int location) { int answer = 0; vector&lt;Info&gt; v; priority_queue&lt;Info, vector&lt;Info&gt;, compare&gt; q; int before = 0; Info info; for(int i=0; i&lt;priorities.size(); i++){ info.value = priorities[i]; if(i == location){ info.isloc = true; }else{ info.isloc = false; } q.push(info); v.push_back(info); } while(!q.empty()){ info = q.top(); Info i = v[0]; v.erase(v.begin()+0); if(i.value &lt; info.value){ v.push_back(i); //인쇄 안 됨 }else if(i.value == info.value){ if(i.isloc){ answer++; break; } q.pop(); answer++; }else{ q.pop(); answer++; } } return answer; } .",
            "url": "https://eunkyung99.github.io/gang/stack/queue/programmers/2022/03/13/algorithm14.html",
            "relUrl": "/stack/queue/programmers/2022/03/13/algorithm14.html",
            "date": " • Mar 13, 2022"
        }
        
    
  
    
        ,"post6": {
            "title": "그래프1 가장 먼 노드",
            "content": "1. 문제 설명 . n개의 노드가 있는 그래프가 있습니다. 각 노드는 1부터 n까지 번호가 적혀있습니다. 1번 노드에서 가장 멀리 떨어진 노드의 갯수를 구하려고 합니다. 가장 멀리 떨어진 노드란 최단경로로 이동했을 때 간선의 개수가 가장 많은 노드들을 의미합니다. . 노드의 개수 n, 간선에 대한 정보가 담긴 2차원 배열 vertex가 매개변수로 주어질 때, 1번 노드로부터 가장 멀리 떨어진 노드가 몇 개인지를 return 하도록 solution 함수를 작성해주세요. . 제한사항 . 노드의 개수 n은 2 이상 20,000 이하입니다. | 간선은 양방향이며 총 1개 이상 50,000개 이하의 간선이 있습니다. | vertex 배열 각 행 [a, b]는 a번 노드와 b번 노드 사이에 간선이 있다는 의미입니다. | . 2. 입.출력 및 예제 . 입출력 예 . n vertex return . 6 | [[3, 6], [4, 3], [3, 2], [1, 3], [1, 2], [2, 4], [5, 2]] | 3 | . 입출력 예 설명 . 예제의 그래프를 표현하면 아래 그림과 같고, 1번 노드에서 가장 멀리 떨어진 노드는 4,5,6번 노드입니다. . . 3. 접근법 . 주어진 간선 입력을 돌면서 별도로 생성한 그래프 벡터에 연결된 노드들을 추가함 . 1번 노드부터 큐에 넣고, bfs를 돈다. pop한 노드의 인접한 노드들을 돌면서 거리가 갱신이 안 되었으면(0) pop한 노드의 거리 + 1을 갱신함 -&gt; 큐에 해당 노드 push . 갱신할 때마다 maxL 변수에 마지막 거리(최대) 값 저장 . 마지막에 2번 노드부터 마지막 노드까지 돌면서 거리가 maxL인 노드의 개수를 센다. . 4. 시간 복잡도 . 완전탐색 . 5. 공간 복잡도 . int 형 큐, graph 벡터 . 6. 놓친 점 . 없음 . 7. 기억할 것 . 그래프 정보를 저장할 때 인접행렬로 n*n 구현하려고 했지만 이러면 인접한 거 다 찾으려면 20000개 돌아야 함 -&gt; 벡터로 구현하여 인접한 것들만 뒤에 추가해줌 . 8. 코드 . #include &lt;string&gt; #include &lt;vector&gt; #include &lt;queue&gt; using namespace std; int solution(int n, vector&lt;vector&lt;int&gt;&gt; edge) { int answer = 0; int maxL; vector&lt;vector&lt;int&gt; &gt; graph(n+1); //*** int dist[20001] = {0,}; for(int i=0; i&lt;edge.size(); i++){ int a = edge[i][0]; int b = edge[i][1]; graph[a].push_back(b); //벡터로 구현하면 전체 노드 조회할 필요 없음 graph[b].push_back(a); } queue&lt;int&gt; q; dist[1] = 0; q.push(1); while(!q.empty()){ int s = q.front(); q.pop(); for(int i=0; i&lt;graph[s].size(); i++){ if(dist[graph[s][i]] == 0){ //방문 안 했다면 maxL = dist[graph[s][i]] = dist[s] + 1; q.push(graph[s][i]); } } } for(int i=2; i&lt;=n; i++){ if(dist[i] == maxL){ answer += 1; } } return answer; } .",
            "url": "https://eunkyung99.github.io/gang/graph/programmers/2022/03/12/algorithm13.html",
            "relUrl": "/graph/programmers/2022/03/12/algorithm13.html",
            "date": " • Mar 12, 2022"
        }
        
    
  
    
        ,"post7": {
            "title": "DFS/BFS1 타겟 넘버",
            "content": "1. 문제 설명 . n개의 음이 아닌 정수들이 있습니다. 이 정수들을 순서를 바꾸지 않고 적절히 더하거나 빼서 타겟 넘버를 만들려고 합니다. 예를 들어 [1, 1, 1, 1, 1]로 숫자 3을 만들려면 다음 다섯 방법을 쓸 수 있습니다. . -1+1+1+1+1 = 3 +1-1+1+1+1 = 3 +1+1-1+1+1 = 3 +1+1+1-1+1 = 3 +1+1+1+1-1 = 3 . 사용할 수 있는 숫자가 담긴 배열 numbers, 타겟 넘버 target이 매개변수로 주어질 때 숫자를 적절히 더하고 빼서 타겟 넘버를 만드는 방법의 수를 return 하도록 solution 함수를 작성해주세요. . 제한사항 . 주어지는 숫자의 개수는 2개 이상 20개 이하입니다. | 각 숫자는 1 이상 50 이하인 자연수입니다. | 타겟 넘버는 1 이상 1000 이하인 자연수입니다. | . 2. 입.출력 및 예제 . 입출력 예 . numbers target return . [1, 1, 1, 1, 1] | 3 | 5 | . [4, 1, 2, 1] | 4 | 2 | . 입출력 예 설명 . 입출력 예 #1 . 문제 예시와 같습니다. . 입출력 예 #2 . +4+1-2+1 = 4 +4-1+2-1 = 4 . 총 2가지 방법이 있으므로, 2를 return 합니다. | . 3. 접근법 . 가능한 연산은 더하기나 빼기만 가능 . dfs 함수를 통해 계산할 인덱스와 누적결과를 넘겨준다. . dfs의 종료조건: 마지막 인덱스+1이 되었을 때 결과가 타겟 넘버가 되면 카운트 | . | 현재 상황에서 더하는 경우의 재귀 호출과 빼는 경우의 재귀 호출 진행 | . main 함수에서 dfs(0, 0)을 호출한다. . 4. 시간 복잡도 . O(2^N) . 5. 공간 복잡도 . 별도의 공간 필요 없음 . 6. 놓친 점 . 없음 . 7. 기억할 것 . 없음 . 8. 코드 . #include &lt;string&gt; #include &lt;vector&gt; using namespace std; int answer = 0; void dfs(int idx, int result, vector&lt;int&gt; n, int t){ if(idx == n.size()){ if(result == t){ answer += 1; } return; } //+-*/ dfs(idx+1, result + n[idx], n, t); dfs(idx+1, result - n[idx], n, t); } int solution(vector&lt;int&gt; numbers, int target) { dfs(0, 0, numbers, target); return answer; } .",
            "url": "https://eunkyung99.github.io/gang/bfs/dfs/programmers/2022/03/12/algorithm12.html",
            "relUrl": "/bfs/dfs/programmers/2022/03/12/algorithm12.html",
            "date": " • Mar 12, 2022"
        }
        
    
  
    
        ,"post8": {
            "title": "탐욕법1 체육복",
            "content": "1. 문제 설명 . 점심시간에 도둑이 들어, 일부 학생이 체육복을 도난당했습니다. 다행히 여벌 체육복이 있는 학생이 이들에게 체육복을 빌려주려 합니다. 학생들의 번호는 체격 순으로 매겨져 있어, 바로 앞번호의 학생이나 바로 뒷번호의 학생에게만 체육복을 빌려줄 수 있습니다. 예를 들어, 4번 학생은 3번 학생이나 5번 학생에게만 체육복을 빌려줄 수 있습니다. 체육복이 없으면 수업을 들을 수 없기 때문에 체육복을 적절히 빌려 최대한 많은 학생이 체육수업을 들어야 합니다. . 전체 학생의 수 n, 체육복을 도난당한 학생들의 번호가 담긴 배열 lost, 여벌의 체육복을 가져온 학생들의 번호가 담긴 배열 reserve가 매개변수로 주어질 때, 체육수업을 들을 수 있는 학생의 최댓값을 return 하도록 solution 함수를 작성해주세요. . 제한사항 . 전체 학생의 수는 2명 이상 30명 이하입니다. | 체육복을 도난당한 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다. | 여벌의 체육복을 가져온 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다. | 여벌 체육복이 있는 학생만 다른 학생에게 체육복을 빌려줄 수 있습니다. | 여벌 체육복을 가져온 학생이 체육복을 도난당했을 수 있습니다. 이때 이 학생은 체육복을 하나만 도난당했다고 가정하며, 남은 체육복이 하나이기에 다른 학생에게는 체육복을 빌려줄 수 없습니다. | . 2. 입.출력 및 예제 . n lost reserve return . 5 | [2, 4] | [1, 3, 5] | 5 | . 5 | [2, 4] | [3] | 4 | . 3 | [3] | [1] | 2 | . 입출력 예 설명 . 예제 #1 1번 학생이 2번 학생에게 체육복을 빌려주고, 3번 학생이나 5번 학생이 4번 학생에게 체육복을 빌려주면 학생 5명이 체육수업을 들을 수 있습니다. . 예제 #2 3번 학생이 2번 학생이나 4번 학생에게 체육복을 빌려주면 학생 4명이 체육수업을 들을 수 있습니다. . 3. 접근법 . 학생 수의 배열을 먼저 1로 초기화 . 도난 당한 목록의 학생은 -1, 여벌을 가져온 학생은 +1 처리 | 첫번째 인덱스부터 마지막 인덱스까지 돌면서 해당 학생이 체육복이 없는 경우(0) 가능하면 바로 앞 번호 학생, 불가능하다면 다음 번 학생의 체육복을 빌린다. | 최종적으로 체육복을 1개 이상 가지고 있는 학생 수를 센다. | . 4. 시간 복잡도 . O(N) . 5. 공간 복잡도 . int형 배열1개 . 6. 놓친 점 . memset 함수를 통해 1로 초기화 하려고 했음 -&gt; 반복문을 통해 하나씩 처리 . 7. 기억할 것 . memset 함수는 0과 -1로만 초기화할 수 있다!!! . 8. 코드 . #include &lt;string&gt; #include &lt;cstring&gt; #include &lt;vector&gt; using namespace std; int student[31]; int solution(int n, vector&lt;int&gt; lost, vector&lt;int&gt; reserve) { // memset(student, 0, sizeof(student)); //***** 1로 초기화 불가능 for(int s=0; s&lt;=30; s++){ student[s] = 1; } int answer = 0; for(int i=0; i&lt;lost.size(); i++){ student[lost[i]] -= 1; } for(int i=0; i&lt;reserve.size(); i++){ student[reserve[i]] += 1; } for(int s=1; s&lt;=n; s++){ if(student[s] == 0){ if(student[s-1] &gt; 1){ student[s-1] -= 1; student[s] += 1; }else if(student[s+1] &gt; 1){ student[s+1] -= 1; student[s] += 1; } } } for(int s=1; s&lt;=n; s++){ if(student[s] &gt; 0){ answer += 1; } } return answer; } .",
            "url": "https://eunkyung99.github.io/gang/greedy/programmers/2022/03/12/algorithm11.html",
            "relUrl": "/greedy/programmers/2022/03/12/algorithm11.html",
            "date": " • Mar 12, 2022"
        }
        
    
  
    
        ,"post9": {
            "title": "정렬1 K번째수",
            "content": "1. 문제 설명 . 배열 array의 i번째 숫자부터 j번째 숫자까지 자르고 정렬했을 때, k번째에 있는 수를 구하려 합니다. . 예를 들어 array가 [1, 5, 2, 6, 3, 7, 4], i = 2, j = 5, k = 3이라면 . array의 2번째부터 5번째까지 자르면 [5, 2, 6, 3]입니다. | 1에서 나온 배열을 정렬하면 [2, 3, 5, 6]입니다. | 2에서 나온 배열의 3번째 숫자는 5입니다. | 배열 array, [i, j, k]를 원소로 가진 2차원 배열 commands가 매개변수로 주어질 때, commands의 모든 원소에 대해 앞서 설명한 연산을 적용했을 때 나온 결과를 배열에 담아 return 하도록 solution 함수를 작성해주세요. . 제한사항 . array의 길이는 1 이상 100 이하입니다. | array의 각 원소는 1 이상 100 이하입니다. | commands의 길이는 1 이상 50 이하입니다. | commands의 각 원소는 길이가 3입니다. | . 2. 입.출력 및 예제 . array commands return . [1, 5, 2, 6, 3, 7, 4] | [[2, 5, 3], [4, 4, 1], [1, 7, 3]] | [5, 6, 3] | . 입출력 예 설명 . [1, 5, 2, 6, 3, 7, 4]를 2번째부터 5번째까지 자른 후 정렬합니다. [2, 3, 5, 6]의 세 번째 숫자는 5입니다. [1, 5, 2, 6, 3, 7, 4]를 4번째부터 4번째까지 자른 후 정렬합니다. [6]의 첫 번째 숫자는 6입니다. [1, 5, 2, 6, 3, 7, 4]를 1번째부터 7번째까지 자릅니다. [1, 2, 3, 4, 5, 6, 7]의 세 번째 숫자는 3입니다. . 3. 접근법 . 명령어마다 i, j, k 구하고 임시 벡터 tmp에 i~j 인덱스 범위의 값을 넣어줌 . 임시 벡터 tmp 정렬 후 인덱스 k의 값 answer 배열에 넣어줌 . 4. 시간 복잡도 . O(N*K) 100 * 50 . 5. 공간 복잡도 . int 벡터(최대 100) * 50개 . 6. 놓친 점 . tmp에 원소를 넣고 tmp의 처음부터 끝까지 범위를 정렬해줘야 함(i~j를 정렬하려고 함) - 실수 . 7. 기억할 것 . 없음 . 8. 코드 . #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; vector&lt;int&gt; solution(vector&lt;int&gt; array, vector&lt;vector&lt;int&gt;&gt; commands) { vector&lt;int&gt; answer; for(int v=0; v&lt;commands.size(); v++){ vector&lt;int&gt; tmp; int i = commands[v][0] - 1; int j = commands[v][1]; int k = commands[v][2] - 1; for(int x=i; x&lt;j; x++){ tmp.push_back(array[x]); } sort(tmp.begin(), tmp.end()); answer.push_back(tmp[k]); } return answer; } .",
            "url": "https://eunkyung99.github.io/gang/sort/programmers/2022/03/10/algorithm9.html",
            "relUrl": "/sort/programmers/2022/03/10/algorithm9.html",
            "date": " • Mar 10, 2022"
        }
        
    
  
    
        ,"post10": {
            "title": "힙1 더 맵게",
            "content": "1. 문제 설명 . 매운 것을 좋아하는 Leo는 모든 음식의 스코빌 지수를 K 이상으로 만들고 싶습니다. 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 Leo는 스코빌 지수가 가장 낮은 두 개의 음식을 아래와 같이 특별한 방법으로 섞어 새로운 음식을 만듭니다. . 섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2) . Leo는 모든 음식의 스코빌 지수가 K 이상이 될 때까지 반복하여 섞습니다. Leo가 가진 음식의 스코빌 지수를 담은 배열 scoville과 원하는 스코빌 지수 K가 주어질 때, 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 섞어야 하는 최소 횟수를 return 하도록 solution 함수를 작성해주세요. . 제한 사항 . scoville의 길이는 2 이상 1,000,000 이하입니다. | K는 0 이상 1,000,000,000 이하입니다. | scoville의 원소는 각각 0 이상 1,000,000 이하입니다. | 모든 음식의 스코빌 지수를 K 이상으로 만들 수 없는 경우에는 -1을 return 합니다. | . 2. 입.출력 및 예제 . scoville K return . [1, 2, 3, 9, 10, 12] | 7 | 2 | . 입출력 예 설명 . 스코빌 지수가 1인 음식과 2인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다. 새로운 음식의 스코빌 지수 = 1 + (2 * 2) = 5 가진 음식의 스코빌 지수 = [5, 3, 9, 10, 12] | 스코빌 지수가 3인 음식과 5인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다. 새로운 음식의 스코빌 지수 = 3 + (5 * 2) = 13 가진 음식의 스코빌 지수 = [13, 9, 10, 12] | 모든 음식의 스코빌 지수가 7 이상이 되었고 이때 섞은 횟수는 2회입니다. . 3. 접근법 . priority_queue를 사용해서 가장 낮은 값을 2개씩 pop 해주고 새로운 스코빌 지수를 만들어줘야 함 | 가장 낮은 값이 K 이상이 되면 반복문 탈출 | 4. 시간 복잡도 . O(N) 100만 . 5. 공간 복잡도 . priority_queue * N . 6. 놓친 점 . while 문 탈출 조건이 가장 낮은 값이 K보다 작은 경우이어야 함 . K를 새로 만들고 넣은 다음에 검사함 -&gt; 새로 만든 K보다 3번째 값이 더 작을 수도 있음 -&gt; 새로 만든 k가 K보다 크면 종료하면 안 됨!! . 7. 기억할 것 . 문제 조건을 잘 생각하자.. 특히 종료 조건 주의!! . 8. 코드 . #include &lt;string&gt; #include &lt;vector&gt; #include &lt;queue&gt; #include &lt;iostream&gt; using namespace std; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; pq; int solution(vector&lt;int&gt; scoville, int K) { int answer = 0; for(int i=0; i&lt;scoville.size(); i++){ pq.push(scoville[i]); } while(pq.top() &lt; K){ //문제 조건 : 모든 음식의 스코빌 지수가 K 이상이 되도록 int m1, m2, k; if(pq.size() == 1){ answer = -1; break; } m1 = pq.top(); pq.pop(); m2 = pq.top(); pq.pop(); k = m1 + (m2 * 2); answer++; //섞음 pq.push(k); } return answer; } .",
            "url": "https://eunkyung99.github.io/gang/heap/programmers/2022/03/10/algorithm8.html",
            "relUrl": "/heap/programmers/2022/03/10/algorithm8.html",
            "date": " • Mar 10, 2022"
        }
        
    
  
    
        ,"post11": {
            "title": "14891 톱니바퀴",
            "content": "1. 문제 설명 . 총 8개의 톱니를 가지고 있는 톱니바퀴 4개가 아래 그림과 같이 일렬로 놓여져 있다. 또, 톱니는 N극 또는 S극 중 하나를 나타내고 있다. 톱니바퀴에는 번호가 매겨져 있는데, 가장 왼쪽 톱니바퀴가 1번, 그 오른쪽은 2번, 그 오른쪽은 3번, 가장 오른쪽 톱니바퀴는 4번이다. . . 이때, 톱니바퀴를 총 K번 회전시키려고 한다. 톱니바퀴의 회전은 한 칸을 기준으로 한다. 회전은 시계 방향과 반시계 방향이 있고, 아래 그림과 같이 회전한다. . . . 톱니바퀴를 회전시키려면, 회전시킬 톱니바퀴와 회전시킬 방향을 결정해야 한다. 톱니바퀴가 회전할 때, 서로 맞닿은 극에 따라서 옆에 있는 톱니바퀴를 회전시킬 수도 있고, 회전시키지 않을 수도 있다. 톱니바퀴 A를 회전할 때, 그 옆에 있는 톱니바퀴 B와 서로 맞닿은 톱니의 극이 다르다면, B는 A가 회전한 방향과 반대방향으로 회전하게 된다. 예를 들어, 아래와 같은 경우를 살펴보자. . . 두 톱니바퀴의 맞닿은 부분은 초록색 점선으로 묶여있는 부분이다. 여기서, 3번 톱니바퀴를 반시계 방향으로 회전했다면, 4번 톱니바퀴는 시계 방향으로 회전하게 된다. 2번 톱니바퀴는 맞닿은 부분이 S극으로 서로 같기 때문에, 회전하지 않게 되고, 1번 톱니바퀴는 2번이 회전하지 않았기 때문에, 회전하지 않게 된다. 따라서, 아래 그림과 같은 모양을 만들게 된다. . . 위와 같은 상태에서 1번 톱니바퀴를 시계 방향으로 회전시키면, 2번 톱니바퀴가 반시계 방향으로 회전하게 되고, 2번이 회전하기 때문에, 3번도 동시에 시계 방향으로 회전하게 된다. 4번은 3번이 회전하지만, 맞닿은 극이 같기 때문에 회전하지 않는다. 따라서, 아래와 같은 상태가 된다. . . 톱니바퀴의 초기 상태와 톱니바퀴를 회전시킨 방법이 주어졌을 때, 최종 톱니바퀴의 상태를 구하는 프로그램을 작성하시오. . 2. 입력 . 첫째 줄에 1번 톱니바퀴의 상태, 둘째 줄에 2번 톱니바퀴의 상태, 셋째 줄에 3번 톱니바퀴의 상태, 넷째 줄에 4번 톱니바퀴의 상태가 주어진다. 상태는 8개의 정수로 이루어져 있고, 12시방향부터 시계방향 순서대로 주어진다. N극은 0, S극은 1로 나타나있다. . 다섯째 줄에는 회전 횟수 K(1 ≤ K ≤ 100)가 주어진다. 다음 K개 줄에는 회전시킨 방법이 순서대로 주어진다. 각 방법은 두 개의 정수로 이루어져 있고, 첫 번째 정수는 회전시킨 톱니바퀴의 번호, 두 번째 정수는 방향이다. 방향이 1인 경우는 시계 방향이고, -1인 경우는 반시계 방향이다. . 3. 출력 . 총 K번 회전시킨 이후에 네 톱니바퀴의 점수의 합을 출력한다. 점수란 다음과 같이 계산한다. . 1번 톱니바퀴의 12시방향이 N극이면 0점, S극이면 1점 | 2번 톱니바퀴의 12시방향이 N극이면 0점, S극이면 2점 | 3번 톱니바퀴의 12시방향이 N극이면 0점, S극이면 4점 | 4번 톱니바퀴의 12시방향이 N극이면 0점, S극이면 8점 | . 4. 예제 . . 5. 접근법 . 단순 구현 문제 . 회전 K번 진행. K번 마다 회전시킬 톱니바퀴 번호와 방향 주어짐 | 회전할 톱니바퀴가 정해지면 1번부터 3번까지 오른쪽 톱니바퀴와 맞닿은 극이 같은지 검사 후 표기한다 왼쪽(i)의 2번째 칸과 오른쪽(i+1)의 6번째 칸 비교 | . | 회전하는 함수 구현 왼쪽 톱니바퀴가 존재하고(n&gt;1), 왼쪽도 회전해야 하면 회전 함수 재귀 호출(반대 방향으로) | 오른쪽 톱니바퀴가 존재하고(n&lt;4), 오른쪽도 회전해야 하면 회전 함수 재귀 호출(반대 방향으로) | 주어진 회전 방향에 따라 배열 회전시켜 줌 | . | K번의 회전 후에 1~4번 톱니바퀴의 상태에 따라 0번 칸이 N극인지 S극인지 확인하고 점수 계산 | 6. 시간 복잡도 . O(K) 100회 회전 * 최대 4개 * 8칸 . 7. 공간 복잡도 . int형 배열*40 , int형 배열 4 . 8. 놓친 점 . 붙어 있는 톱니바퀴 검사 시 오른쪽 톱니바퀴 인덱스 i로 적음 | 왼쪽이나 오른쪽이 회전해야 할 경우 재귀 호출을 할 때 극이 반대인지 표시하는 배열을 false로 바꿔주지 않음 재귀 호출을 해서도 인접한 지 검사하기 때문에 계속 같은 번호들이 재귀 호출되어 segmentation fault가 발생함 | 재귀 호출하기 전에 isRotate를 false로 바꿔줌 | . | . 9. 기억할 것 . 재귀 함수 무한 루프 돌면 -&gt; 스택 오버플로우(segmentation fault) . 10. 코드 . #include &lt;iostream&gt; using namespace std; int K; int gear[5][8]; bool isRotate[4]; //1: 1-2 2: 2-3 3: 3-4 void checkWhatRotate(){ for(int i=1; i&lt;4; i++){ int right = gear[i][2]; int left = gear[i+1][6]; //*** if(right != left){ isRotate[i] = true; }else{ isRotate[i] = false; } } } void Rotate(int n, int d){ if((n &gt; 1) &amp;&amp; isRotate[n-1]){ //left isRotate[n-1] = false; //********** 재귀 끊어줘야 함(visited 역할) Rotate(n-1, (-1)*d); } if((n &lt; 4) &amp;&amp; isRotate[n]){ //right isRotate[n] = false; //********** 재귀 끊어줘야 함(visited 역할) Rotate(n+1, (-1)*d); } if(d == 1){ int tmp = gear[n][7]; for(int i=7; i&gt;0; i--){ gear[n][i] = gear[n][i-1]; } gear[n][0] = tmp; }else if(d == -1){ //d == -1 int tmp = gear[n][0]; for(int i=0; i&lt;7; i++){ gear[n][i] = gear[n][i+1]; } gear[n][7] = tmp; } } int getScore(){ int score = 0; if(gear[1][0] == 1){ score += 1; } if(gear[2][0] == 1){ score += 2; } if(gear[3][0] == 1){ score += 4; } if(gear[4][0] == 1){ score += 8; } return score; } int main(){ ios::sync_with_stdio(0); cin.tie(0); int num, dir; string s; for(int i=1; i&lt;=4; i++){ cin &gt;&gt; s; for(int j=0; j&lt;8; j++){ gear[i][j] = s[j] - &#39;0&#39;; } } cin &gt;&gt; K; for(int k=0; k&lt;K; k++){ cin &gt;&gt; num &gt;&gt; dir; checkWhatRotate(); Rotate(num, dir); } cout &lt;&lt; getScore() &lt;&lt;&quot; n&quot;; return 0; } . 11. 이전 풀이와 달라진 점(개선) . 돌아야 하는 톱니바퀴 기준으로 연결된(회전해야 하는) 톱니바퀴를 하나하나 찾아서 회전 함수(rotate) 호출함 -&gt; 재귀로 구현하여 회전 함수 안에서 양쪽 중 연결된 것 있는지 검사해서 재귀 호출하도록 구현! . 마지막에 score 계산하는 부분은 이전 코드가 더 간단했음 (for 문으로) . int score[5] = {0, 1, 2, 4, 8}; int answer(){ int ans = 0; for(int i=1; i&lt;=4; i++){ if(round[i][0] == 1){ //S극이면 ans += score[i]; } } return ans; } .",
            "url": "https://eunkyung99.github.io/gang/simulation/baekjoon/2022/03/10/algorithm7.html",
            "relUrl": "/simulation/baekjoon/2022/03/10/algorithm7.html",
            "date": " • Mar 10, 2022"
        }
        
    
  
    
        ,"post12": {
            "title": "완전탐색1 모의고사",
            "content": "1. 문제 설명 . 수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다. . 1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, … 2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, … 3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, … . 1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 solution 함수를 작성해주세요. . 제한 조건 . 시험은 최대 10,000 문제로 구성되어있습니다. | 문제의 정답은 1, 2, 3, 4, 5중 하나입니다. | 가장 높은 점수를 받은 사람이 여럿일 경우, return하는 값을 오름차순 정렬해주세요. | . 2. 입.출력 및 예제 . answers return . [1,2,3,4,5] | [1] | . [1,3,2,4,2] | [1,2,3] | . 입출력 예 설명 . 입출력 예 #1 . 수포자 1은 모든 문제를 맞혔습니다. | 수포자 2는 모든 문제를 틀렸습니다. | 수포자 3은 모든 문제를 틀렸습니다. | . 따라서 가장 문제를 많이 맞힌 사람은 수포자 1입니다. . 입출력 예 #2 . 모든 사람이 2문제씩을 맞췄습니다. | . 3. 접근법 . 수포자 1~3의 찍는 규칙을 배열 A, B, C에 저장함 . 답안지의 처음부터 끝까지 돌면서 (인덱스 % 규칙개수) 번째 찍는 답과 실제 답 비교해서 맞은 개수 저장 . 최대값 구하고 가장 높은 점수를 받은 사람들 answer에 추가 . 4. 시간 복잡도 . O(N) 10000 . 5. 공간 복잡도 . int형 배열 3개 . 6. 놓친 점 . 없음 . 7. 기억할 것 . 없음 . 8. 코드 . #include &lt;string&gt; #include &lt;vector&gt; using namespace std; int A[5] = {1, 2, 3, 4, 5}; int B[8] = {2, 1, 2, 3, 2, 4, 2, 5}; int C[10] = {3, 3, 1, 1, 2, 2, 4, 4, 5, 5}; vector&lt;int&gt; solution(vector&lt;int&gt; answers) { vector&lt;int&gt; answer; int cA = 0; int cB = 0; int cC = 0; for(int v=0; v&lt;answers.size(); v++){ if(A[v%5] == answers[v]){ cA++; } if(B[v%8] == answers[v]){ cB++; } if(C[v%10] == answers[v]){ cC++; } } int maxAns = max(max(cA, cB), cC); if(maxAns == cA){ answer.push_back(1); } if(maxAns == cB){ answer.push_back(2); } if(maxAns == cC){ answer.push_back(3); } return answer; } .",
            "url": "https://eunkyung99.github.io/gang/bruteforce/programmers/2022/03/10/algorithm10.html",
            "relUrl": "/bruteforce/programmers/2022/03/10/algorithm10.html",
            "date": " • Mar 10, 2022"
        }
        
    
  
    
        ,"post13": {
            "title": "스택/큐1 기능개발",
            "content": "1. 문제 설명 . 프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다. . 또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다. . 먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요. . 제한 사항 . 작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다. | 작업 진도는 100 미만의 자연수입니다. | 작업 속도는 100 이하의 자연수입니다. | 배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다. | . 2. 입.출력 및 예제 . progresses speeds return . [93, 30, 55] | [1, 30, 5] | [2, 1] | . [95, 90, 99, 99, 80, 99] | [1, 1, 1, 1, 1, 1] | [1, 3, 2] | . 입출력 예 #1 첫 번째 기능은 93% 완료되어 있고 하루에 1%씩 작업이 가능하므로 7일간 작업 후 배포가 가능합니다. 두 번째 기능은 30%가 완료되어 있고 하루에 30%씩 작업이 가능하므로 3일간 작업 후 배포가 가능합니다. 하지만 이전 첫 번째 기능이 아직 완성된 상태가 아니기 때문에 첫 번째 기능이 배포되는 7일째 배포됩니다. 세 번째 기능은 55%가 완료되어 있고 하루에 5%씩 작업이 가능하므로 9일간 작업 후 배포가 가능합니다. . 따라서 7일째에 2개의 기능, 9일째에 1개의 기능이 배포됩니다. . 입출력 예 #2 모든 기능이 하루에 1%씩 작업이 가능하므로, 작업이 끝나기까지 남은 일수는 각각 5일, 10일, 1일, 1일, 20일, 1일입니다. 어떤 기능이 먼저 완성되었더라도 앞에 있는 모든 기능이 완성되지 않으면 배포가 불가능합니다. . 따라서 5일째에 1개의 기능, 10일째에 3개의 기능, 20일째에 2개의 기능이 배포됩니다. . 3. 접근법 . 100%까지 남은 양을 구하고 속도로 나누어 필요한 일 수를 담는 벡터 만들어준다 | 앞에서부터 필요한 일을 검사해서 마지막 값을 저장한다. | 마지막 값(before)보다 다음 값이 작으면 기다려야 하므로 answer 벡터에 넣지 말고 마지막 원소의 개수를 하나씩 증가해줌 -&gt; before보다 큰 값이 나올 때 까지 | 큰 값이 나오면 before 갱신하고 answer에 1 삽입 | 4. 시간 복잡도 . O(N) 100 . 5. 공간 복잡도 . int 벡터 2개 . 6. 놓친 점 . 없음 . 7. 기억할 것 . 재귀 함수는 조건 미달 시 리턴해주는 것에 주의하자! . 8. 코드 . #include &lt;string&gt; #include &lt;vector&gt; using namespace std; vector&lt;int&gt; solution(vector&lt;int&gt; progresses, vector&lt;int&gt; speeds) { vector&lt;int&gt; days; vector&lt;int&gt; answer; for(int i=0; i&lt;progresses.size(); i++){ int need = 100 - progresses[i]; if(need % speeds[i] == 0){ days.push_back(need/speeds[i]); }else{ days.push_back(need/speeds[i] + 1); } } int before = 0; int v = -1; //index for(int i=0; i&lt;days.size(); i++){ if(before &lt; days[i]){ answer.push_back(1); v++; before = days[i]; //갱신 }else{ answer[v] += 1; } } return answer; } .",
            "url": "https://eunkyung99.github.io/gang/stack/queue/programmers/2022/03/09/algorithm6.html",
            "relUrl": "/stack/queue/programmers/2022/03/09/algorithm6.html",
            "date": " • Mar 9, 2022"
        }
        
    
  
    
        ,"post14": {
            "title": "해시1 완주하지 못한 선수",
            "content": "1. 문제 설명 . 수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다. . 마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요. . 제한사항 . 마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다. | completion의 길이는 participant의 길이보다 1 작습니다. | 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다. | 참가자 중에는 동명이인이 있을 수 있습니다. | . 2. 입.출력 및 예제 . participant completion return . [“leo”, “kiki”, “eden”] | [“eden”, “kiki”] | “leo” | . [“marina”, “josipa”, “nikola”, “vinko”, “filipa”] | [“josipa”, “filipa”, “marina”, “nikola”] | “vinko” | . [“mislav”, “stanko”, “mislav”, “ana”] | [“stanko”, “ana”, “mislav”] | “mislav” | . 예제 #1 “leo”는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다. . 예제 #2 “vinko”는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다. . 예제 #3 “mislav”는 참여자 명단에는 두 명이 있지만, 완주자 명단에는 한 명밖에 없기 때문에 한명은 완주하지 못했습니다. . 3. 접근법 . unordered_map을 사용하여 string, int 매칭해주는 해시 테이블로 만듦 . 완주한 사람들을 먼저 맵에 표시함 (동명이인이 있을 수 있으므로 값을 1씩 증가하며 count해주도록 함) . 명단에 있는 사람들을 탐색했을 때 맵의 끝에 도달(존재하지 않음)이거나 값이 0일 때는 완주하지 못한 경우이므로 답으로 정한다. . unordered_map . #include . unordered_map&lt;string, int&gt; um; //선언 . empty() : 맵이 비어있는지 확인하는 함수 . size() : 맵의 크기를 확인하는 함수 . operator [ ] : 맵에서 key를 통해 value 지정 um[key] = value; . count(key) : 맵에서 key에 해당하는 원소의 개수를 찾는 함수 . find(key) : 맵에서 key에 해당하는 원소를 찾는 함수 (없을 경우 um.end() 반환!) . insert({key, value}) : 맵에 pair&lt;key, value&gt; 추가 (키가 존재할 경우 삽입 안 함) . erase(key) : key에 해당하는 원소 제거 . clear() : 맵 초기화 . operator = : 대입연산자 가능 . begin(), end() : 시작과 끝 . unordered_map O(1) - 데이터가 많을 시 월등히 좋은 성능 . | map은 BinarySearchTree로 구현되어 탐색하는데 O(logn) 소요 . | . 인덱스로 접근할 수 없고 iterator로 접근해야 함 . iter -&gt; first : key, iter -&gt; second : value . for(pair&lt;string, int&gt; elem : um){ //for(auto elem : um){ cout &lt;&lt; &quot;key : &quot; &lt;&lt; elem.first &lt;&lt; &quot; value : &quot; &lt;&lt; elem.second &lt;&lt;&quot; n&quot;; } . 4. 시간 복잡도 . O(1) * N 10만 . 5. 공간 복잡도 . 20만 . 6. 놓친 점 . 동명이인이 있는 경우를 처리해주지 못 함 . 7. 기억할 것 . 문제 조건을 잘 확인하자 . 8. 코드 . #include &lt;string&gt; #include &lt;vector&gt; #include &lt;unordered_map&gt; using namespace std; string solution(vector&lt;string&gt; participant, vector&lt;string&gt; completion) { unordered_map&lt;string, int&gt; um; string answer; for(int i=0; i&lt;completion.size(); i++){ um[completion[i]] += 1; //*****동명이인이 있을 수 있음 // um.insert(make_pair(completion[i], 1)); } for(int i=0; i&lt;participant.size(); i++){ if(um.find(participant[i]) == um.end() || um[participant[i]] == 0){ answer = participant[i]; break; }else{ um[participant[i]] -= 1; } } return answer; } .",
            "url": "https://eunkyung99.github.io/gang/hash/programmers/2022/03/09/algorithm5.html",
            "relUrl": "/hash/programmers/2022/03/09/algorithm5.html",
            "date": " • Mar 9, 2022"
        }
        
    
  
    
        ,"post15": {
            "title": "14502 연구소",
            "content": "1. 문제 설명 . 인체에 치명적인 바이러스를 연구하던 연구소에서 바이러스가 유출되었다. 다행히 바이러스는 아직 퍼지지 않았고, 바이러스의 확산을 막기 위해서 연구소에 벽을 세우려고 한다. . 연구소는 크기가 N×M인 직사각형으로 나타낼 수 있으며, 직사각형은 1×1 크기의 정사각형으로 나누어져 있다. 연구소는 빈 칸, 벽으로 이루어져 있으며, 벽은 칸 하나를 가득 차지한다. . 일부 칸은 바이러스가 존재하며, 이 바이러스는 상하좌우로 인접한 빈 칸으로 모두 퍼져나갈 수 있다. 새로 세울 수 있는 벽의 개수는 3개이며, 꼭 3개를 세워야 한다. . 예를 들어, 아래와 같이 연구소가 생긴 경우를 살펴보자. . 2 0 0 0 1 1 0 0 0 1 0 1 2 0 0 1 1 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 1 0 0 0 0 0 0 1 0 0 0 0 0 . 이때, 0은 빈 칸, 1은 벽, 2는 바이러스가 있는 곳이다. 아무런 벽을 세우지 않는다면, 바이러스는 모든 빈 칸으로 퍼져나갈 수 있다. . 2행 1열, 1행 2열, 4행 6열에 벽을 세운다면 지도의 모양은 아래와 같아지게 된다. . 2 1 0 0 1 1 0 1 0 1 0 1 2 0 0 1 1 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 1 1 0 1 0 0 0 0 0 0 1 0 0 0 0 0 . 바이러스가 퍼진 뒤의 모습은 아래와 같아진다. . 2 1 0 0 1 1 2 1 0 1 0 1 2 2 0 1 1 0 1 2 2 0 1 0 0 0 1 2 0 0 0 0 0 1 1 0 1 0 0 0 0 0 0 1 0 0 0 0 0 . 벽을 3개 세운 뒤, 바이러스가 퍼질 수 없는 곳을 안전 영역이라고 한다. 위의 지도에서 안전 영역의 크기는 27이다. . 연구소의 지도가 주어졌을 때 얻을 수 있는 안전 영역 크기의 최댓값을 구하는 프로그램을 작성하시오. . 2. 입력 . 첫째 줄에 지도의 세로 크기 N과 가로 크기 M이 주어진다. (3 ≤ N, M ≤ 8) . 둘째 줄부터 N개의 줄에 지도의 모양이 주어진다. 0은 빈 칸, 1은 벽, 2는 바이러스가 있는 위치이다. 2의 개수는 2보다 크거나 같고, 10보다 작거나 같은 자연수이다. . 빈 칸의 개수는 3개 이상이다. . 3. 출력 . 첫째 줄에 얻을 수 있는 안전 영역의 최대 크기를 출력한다. . 4. 예제 . . 5. 접근법 . 재귀 함수를 구현하여(DFS) 벽이 3개 세워질 때까지 모든 경우의 가짓수만큼 호출한다 . 처음 호출할 때 인덱스 -1로 하여 +1부터 시작해서 마지막 벽 세울 수 있는 공간까지 경우의 수 구한다 . 새로운 경우의 수 후보의 재귀함수를 호출하기 전에 벽을 세우는 마크(1) 표시하고, 호출하고 돌아왔을 때 원상복구(0)되도록 함 . 벽이 3개 세워졌을 경우 그 상태에서 바이러스들이 퍼질 수 있는 공간을 탐색(BFS) -&gt; 처음에 센 0의 공간에서 벽 3개 빼고, 바이러스 퍼질 수 있는 영역들 방문할 때마다 빼줌 . 6. 시간 복잡도 . O(N^2 C 3)..? 이지만 N이 최대 9이므로 완전탐색 괜찮다 . 7. 공간 복잡도 . 81*int 배열 1개, 벡터, 큐 &lt; 512MB . 8. 놓친 점 . 재귀 함수 DFS가 돌아가는 과정을 생각하는데 오래걸렸다 . 모든 경우의 수를 다 돌릴 때는 완전탐색 . 9. 기억할 것 . 모든 경우의 수를 다 돌릴 수 있는 방법 . 10. 코드 . #include &lt;iostream&gt; #include &lt;queue&gt; #include &lt;vector&gt; using namespace std; int N, M; int office[9][9]; int dr[4] = { 0, 0, -1, 1 }; int dc[4] = { -1, 1, 0, 0 }; int emptyArea = 0; int ans = 0; int called = 0; vector&lt;pair&lt;int, int&gt; &gt; virus; vector&lt;pair&lt;int, int&gt; &gt; candidate; int Spread(){ int visited[9][9] = {false,}; int cnt = emptyArea - 3; for(int v=0; v&lt;virus.size(); v++){ queue&lt;pair&lt;int, int&gt; &gt; q; int vr = virus[v].first; int vc = virus[v].second; visited[vr][vc] = true; q.push(make_pair(vr, vc)); while(!q.empty()){ pair&lt;int, int&gt; p = q.front(); q.pop(); for(int d=0; d&lt;4; d++){ int nr = p.first + dr[d]; int nc = p.second + dc[d]; if((0&lt;=nr &amp;&amp; nr&lt;N &amp;&amp; 0&lt;=nc &amp;&amp; nc&lt;M) &amp;&amp; !visited[nr][nc] &amp;&amp; office[nr][nc]==0){ q.push(make_pair(nr, nc)); visited[nr][nc] = true; cnt -= 1; //virus 퍼진 것 if(cnt &lt; ans){ //가지치기 return -1; } } } } } return cnt; } void DFS(int idx, int built){ if(built == 3){ called += 1; int cnt = Spread(); if(ans &lt; cnt){ ans = cnt; } return; } for(int i=idx+1; i&lt;candidate.size(); i++){ int nr = candidate[i].first; int nc = candidate[i].second; office[nr][nc] = 1; DFS(i, built+1); office[nr][nc] = 0; } } int main(){ ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; N &gt;&gt; M; for(int i=0; i&lt;N; i++){ for(int j=0; j&lt;M; j++){ cin &gt;&gt; office[i][j]; if(office[i][j] == 0){ emptyArea += 1; candidate.push_back(make_pair(i, j)); } if(office[i][j] == 2){ virus.push_back(make_pair(i, j)); } } } DFS(-1, 0); cout &lt;&lt; ans &lt;&lt;&quot; n&quot;; return 0; } . 11. 이전 풀이와 달라진 점(개선) . DFS를 도는 방식이 조금 꼬였던 것 같다. main 문에서 N번, DFS 안에서 N^2번 돌아서 이를 DFS 안에서만 돌도록 수정 | 체크아웃하는 부분도 꼬였었음 -&gt; 한 군데로 통일 | 바이러스가 안 퍼지는 안전 영역을 전체 돌아서 구함 -&gt; 이 부분 생략하고 BFS 돌 때 후보에서 개수 하나씩 빼줌 | 맵을 복사하는 과정을 굳이 추가함 -&gt; 체크인 체크아웃으로 벽 위치 표시해서 별도의 배열, 복사 과정 필요 없어짐 | .",
            "url": "https://eunkyung99.github.io/gang/bfs/dfs/baekjoon/2022/03/09/algorithm4.html",
            "relUrl": "/bfs/dfs/baekjoon/2022/03/09/algorithm4.html",
            "date": " • Mar 9, 2022"
        }
        
    
  
    
        ,"post16": {
            "title": "14503 로봇 청소기",
            "content": "1. 문제 설명 . 로봇 청소기가 청소하는 영역의 개수를 구하는 프로그램을 작성하시오. . 로봇 청소기가 있는 장소는 N*M 크기의 직사각형으로 나타낼 수 있으며, 1x1 크기의 정사각형 칸으로 나누어져 있다. 각각의 칸은 벽 또는 빈 칸이다. 청소기는 바라보는 방향이 있으며, 이 방향은 동, 서, 남, 북 중 하나이다. 지도의 각 칸은 (r, c)로 나타낼 수 있고, r은 북쪽으로부터 떨어진 칸의 개수, c는 서쪽으로부터 떨어진 칸의 개수이다. . 로봇 청소기의 작동 원리 . 현재 위치를 청소한다 | 현재 위치에서 현재 방향을 기준으로 왼쪽 방향부터 차례대로 인접한 칸을 탐색한다. 왼쪽 방향에 아직 청소하지 않은 공간이 존재한다면, 그 방향으로 회전한 다음 한 칸을 전진하고 1번부터 진행한다. | 왼쪽 방향에 청소할 공간이 없다면, 그 방향으로 회전하고 2번으로 돌아간다. | 네 방향 모두 청소가 이미 되어있거나 벽인 경우에는 바라보는 방향을 유지한 채로 한 칸 후진을 하고 2번으로 돌아간다. | 네 방향 모두 청소가 이미 되어있거나 벽이면서 뒤쪽 방향이 벽이라 후진도 할 수 없는 경우에는 작동을 멈춘다. | | 로봇 청소기는 이미 청소되어 있는 칸을 또 청소하지 않으며, 벽을 통과할 수 없다. . 2. 입력 . 첫째 줄에 세로 크기 N과 가로 크기 M이 주어진다. (3 ≤ N, M ≤ 50) . 둘째 줄에 로봇 청소기가 있는 칸의 좌표 (r, c)와 바라보는 방향 d가 주어진다. d가 0인 경우에는 북쪽을, 1인 경우에는 동쪽을, 2인 경우에는 남쪽을, 3인 경우에는 서쪽을 바라보고 있는 것이다. . 셋째 줄부터 N개의 줄에 장소의 상태가 북쪽부터 남쪽 순서대로, 각 줄은 서쪽부터 동쪽 순서대로 주어진다. 빈 칸은 0, 벽은 1로 주어진다. 지도의 첫 행, 마지막 행, 첫 열, 마지막 열에 있는 모든 칸은 벽이다. . 로봇 청소기가 있는 칸의 상태는 항상 빈 칸이다. . 3. 출력 . 로봇 청소기가 청소하는 칸의 개수를 출력한다. . 4. 예제 . . 5. 접근법 . 좌표와 방향 정보를 인수로 넘겨주면서 다음으로 이동할 칸을 탐색한다. . 탐색 순서는 규칙에 나와있는 내용을 구현하기만 하면 됨 . 왼쪽 방향으로 순환하며 이동할 수 있는 곳 탐색 -&gt; 존재하면 이동 | 4방향 다 돌고나면 후진 가능한지 체크 -&gt; 가능하면 후진 | . 6. 시간 복잡도 . O(N*M) 2500 . 7. 공간 복잡도 . 2500*int 배열 1개 &lt; 512MB . 8. 놓친 점 . 다음으로 이동할 칸을 찾으면 return을 해주어야 하는데 그 부분을 작성하지 않아 재귀 스택이 쓸데없이 많이 쌓였고 예제 2번의 경우 오답이 나왔음. . 9. 기억할 것 . 재귀 함수는 조건 미달 시 리턴해주는 것에 주의하자! . 10. 코드 . #include &lt;iostream&gt; using namespace std; int N, M; int room[51][51]; int dr[4] = {-1, 0, 1, 0}; int dc[4] = {0, 1, 0, -1}; int cleaning = 0; void Clean(int r, int c, int d){ //현재 위치 청소 if(room[r][c] == 0){ room[r][c] = 2; //청소 표시 cleaning++; } for(int i=0; i&lt;4; i++){ d = (d - 1 + 4) % 4; //왼쪽 방향 전환 int nr = r + dr[d]; int nc = c + dc[d]; if((0&lt;=nr &amp;&amp; nr&lt;N &amp;&amp; 0&lt;=nc &amp;&amp; nc&lt;M) &amp;&amp; room[nr][nc]==0){ Clean(nr, nc, d); return; //******* 방향을 찾으면 리턴해줘야 함!!! } } //네 방향 모두 청소가 이미 되어 있거나 벽인 경우 int backR = r - dr[d]; int backC = c - dc[d]; if((0&lt;=backR &amp;&amp; backR&lt;N &amp;&amp; 0&lt;=backC &amp;&amp; backC&lt;M) &amp;&amp; room[backR][backC]!=1){ Clean(backR, backC, d); return; //******* 방향을 찾으면 리턴해줘야 함!!! } return; } int main(){ ios::sync_with_stdio(0); cin.tie(0); int r, c, d; cin &gt;&gt; N &gt;&gt; M; cin &gt;&gt; r &gt;&gt; c &gt;&gt; d; for(int i=0; i&lt;N; i++){ for(int j=0; j&lt;M; j++){ cin &gt;&gt; room[i][j]; } } Clean(r, c, d); cout &lt;&lt; cleaning &lt;&lt;&quot; n&quot;; return 0; } . 11. 이전 풀이와 달라진 점(개선) . 방향 전환을 이전에는 따로 함수로 구현 -&gt; 4 더하고 4로 나머지 연산함 | visited 배열을 따로 둠 -&gt; 입력받는 room에 0과 1 아닌 2를 기록하며 방문 표시 | 후진하는 경우 함수를 다시 호출하지 않고 while 문을 통해 후진한 다음 만족하는 위치 찾을 때까지 돌도록 함(코드 더러움) -&gt; 조건 정리 코드에도 보이게 명료해짐 | .",
            "url": "https://eunkyung99.github.io/gang/simulation/baekjoon/2022/03/09/algorithm3.html",
            "relUrl": "/simulation/baekjoon/2022/03/09/algorithm3.html",
            "date": " • Mar 9, 2022"
        }
        
    
  
    
        ,"post17": {
            "title": "15486 퇴사 2",
            "content": "1. 문제 설명 . 상담원으로 일하고 있는 백준이는 퇴사를 하려고 한다. . 오늘부터 N+1일째 되는 날 퇴사를 하기 위해서, 남은 N일 동안 최대한 많은 상담을 하려고 한다. . 백준이는 비서에게 최대한 많은 상담을 잡으라고 부탁을 했고, 비서는 하루에 하나씩 서로 다른 사람의 상담을 잡아놓았다. . 각각의 상담은 상담을 완료하는데 걸리는 기간 Ti와 상담을 했을 때 받을 수 있는 금액 Pi로 이루어져 있다. . N = 7인 경우에 다음과 같은 상담 일정표를 보자. .   1일 2일 3일 4일 5일 6일 7일 . Ti | 3 | 5 | 1 | 1 | 2 | 4 | 2 | . Pi | 10 | 20 | 10 | 20 | 15 | 40 | 200 | . 1일에 잡혀있는 상담은 총 3일이 걸리며, 상담했을 때 받을 수 있는 금액은 10이다. 5일에 잡혀있는 상담은 총 2일이 걸리며, 받을 수 있는 금액은 15이다. . 상담을 하는데 필요한 기간은 1일보다 클 수 있기 때문에, 모든 상담을 할 수는 없다. 예를 들어서 1일에 상담을 하게 되면, 2일, 3일에 있는 상담은 할 수 없게 된다. 2일에 있는 상담을 하게 되면, 3, 4, 5, 6일에 잡혀있는 상담은 할 수 없다. . 또한, N+1일째에는 회사에 없기 때문에, 6, 7일에 있는 상담을 할 수 없다. . 퇴사 전에 할 수 있는 상담의 최대 이익은 1일, 4일, 5일에 있는 상담을 하는 것이며, 이때의 이익은 10+20+15=45이다. . 상담을 적절히 했을 때, 백준이가 얻을 수 있는 최대 수익을 구하는 프로그램을 작성하시오. . 2. 입력 . 첫째 줄에 N (1 ≤ N ≤ 1,500,000)이 주어진다. . 둘째 줄부터 N개의 줄에 Ti와 Pi가 공백으로 구분되어서 주어지며, 1일부터 N일까지 순서대로 주어진다. (1 ≤ Ti ≤ 50, 1 ≤ Pi ≤ 1,000) . 3. 출력 . 첫째 줄에 백준이가 얻을 수 있는 최대 이익을 출력한다. . 4. 예제 . . 5. 접근법 . DP(Bottom-Top 방식) - 전날까지 가능한 최댓값 / DP[i-X]에서 올라온 값 / 기존 dp[i] 값 중 최댓값을 업데이트 해줌 . 6. 시간 복잡도 . O(N) 150만 &lt; 2초 . 7. 공간 복잡도 . 150만*int 배열 3개 &lt; 512MB . 8. 놓친 점 . 전날까지 있는 최댓값을 생각하지 못했음 - 예제 4보고 알아챔 . 최댓값 변수 지정 -&gt; 업데이트해줌(i 번째까지) -&gt; 같이 비교해준다 . 9. 기억할 것 . 크기가 큰 배열 -&gt; 전역 변수로 선언하기! segmentation fault 에러 . 10. 코드 . #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; //segmentation fault 전역변수로 선언! int T[1500001]; int P[1500001]; int dp[1500001]; int main(){ int N; int MAX = 0; cin &gt;&gt; N; for(int i=1; i&lt;=N; i++){ cin &gt;&gt; T[i] &gt;&gt; P[i]; } for(int i=1; i&lt;=N+1; i++){ //이전에 최댓값이 있을 수 있음 if(MAX &lt; dp[i-1]){ MAX = dp[i-1]; } int complete = i + T[i]; if(complete &gt; N+1){ continue; } if(MAX &gt; dp[i]){ dp[i] = MAX; } dp[complete] = max(dp[i]+P[i], dp[complete]); } cout &lt;&lt; dp[N+1]&lt;&lt;&quot; &quot;; return 0; } .",
            "url": "https://eunkyung99.github.io/gang/dp/baekjoon/2021/09/02/algorithm2.html",
            "relUrl": "/dp/baekjoon/2021/09/02/algorithm2.html",
            "date": " • Sep 2, 2021"
        }
        
    
  
    
        ,"post18": {
            "title": "13458 시험 감독",
            "content": "1. 문제 설명 . 총 N개의 시험장이 있고, 각각의 시험장마다 응시자들이 있다. i번 시험장에 있는 응시자의 수는 Ai명이다. . 감독관은 총감독관과 부감독관으로 두 종류가 있다. 총감독관은 한 시험장에서 감시할 수 있는 응시자의 수가 B명이고, 부감독관은 한 시험장에서 감시할 수 있는 응시자의 수가 C명이다. . 각각의 시험장에 총감독관은 오직 1명만 있어야 하고, 부감독관은 여러 명 있어도 된다. . 각 시험장마다 응시생들을 모두 감시해야 한다. 이때, 필요한 감독관 수의 최솟값을 구하는 프로그램을 작성하시오. . 2. 입력 . 첫째 줄에 시험장의 개수 N(1 ≤ N ≤ 1,000,000)이 주어진다. . 둘째 줄에는 각 시험장에 있는 응시자의 수 Ai (1 ≤ Ai ≤ 1,000,000)가 주어진다. . 셋째 줄에는 B와 C가 주어진다. (1 ≤ B, C ≤ 1,000,000) . 3. 출력 . 각 시험장마다 응시생을 모두 감독하기 위해 필요한 감독관의 최소 수를 출력한다. . 4. 예제 . . 5. 접근법 . 단순한 수학 계산 식 구현 . 최소 총감독관 한 명씩 필요하므로 총감독관만큼 빼주고 나머지 부감독이 몇 명 필요한지 계산 . 6. 시간 복잡도 . O(N) - 100만 &lt; 2초 . 7. 공간 복잡도 . int 100만 배열 선언 &lt; 512MB . 8. 놓친 점 . 100만 * 100만 =&gt; int 범위 초과!! =&gt; long long . 9. 기억할 것 . long long (틀렸습니다) . 10. 코드 . #include &lt;iostream&gt; using namespace std; int main(){ int N; int A[1000000]; int B, C; long long coach = 0; //*** long long 틀렸습니다!! cin &gt;&gt; N; for(int i=0; i&lt;N; i++){ cin &gt;&gt; A[i]; } cin &gt;&gt; B &gt;&gt; C; coach = N; //최소 총감독관 한 명씩 필요 for(int i=0; i&lt;N; i++){ A[i] -= B; if(A[i] &lt; 0){ A[i] = 0; } if(A[i]%C == 0){ coach += A[i]/C; }else{ coach += (A[i]/C + 1); } } cout &lt;&lt; coach &lt;&lt;&quot; n&quot;; return 0; } .",
            "url": "https://eunkyung99.github.io/gang/math/baekjoon/2021/09/02/algorithm1.html",
            "relUrl": "/math/baekjoon/2021/09/02/algorithm1.html",
            "date": " • Sep 2, 2021"
        }
        
    
  
    
        ,"post19": {
            "title": "경로 제어/트래픽 제어",
            "content": "1. 경로 제어(Routing) . 송.수신 측 간의 전송 경로 중에서 최적 패킷 교환 경로를 결정하는 기능 | 경로 제어표(Routing Table)를 참조해서 이루어지며, 라우터에 의해 수행됨 | 경로 제어 요소 성능 기준 | 경로의 결정 시간과 장소 | 정보 발생지 | 경로 정보의 갱신 시간 | . | . 2. 경로 제어 프로토콜(Routing Protocol) . IGP(Interior Gateway Protocol, 내부 게이트웨이 프로토콜) 하나의 자율 시스템 내의 라우팅에 사용되는 프로토콜 | RIP(Routing Information Protocol) 현재 가장 널리 사용되는 라우팅 프로토콜로 거리 벡터 라우팅 프로토콜이라고도 불리며, 최단 경로 탐색에 Bellman-Ford 알고리즘이 사용됨 | 소규모 동종의 네트워크(자율 시스템, AS) 내에서 효율적인 방법 | 최대 홉 수를 15로 제한하므로 15 이상의 경우는 도달할 수 없는 네트워크를 의미하는데 이것은 대규모 네트워크에서는 RIP를 사용할 수 없음을 의미함 | 라우팅 정보를 30초마다 네트워크 내의 모든 라우터에 알리며, 180초 이내에 새로운 라우팅 정보가 수신되지 않으면 해당 경로를 이상 상태로 간주함 | . | OSPF(Open Shortest Path First protocol) RIP의 단점을 해결하여 새로운 기능을 지원하는 인터넷 프로토콜로, 대규모 네트워크에서 많이 사용됨 | 인터넷 망에서 이용자가 최단 경로를 선정할 수 있도록 라우팅 정보에 노드 간의 거리 정보, 링크 상태 정보를 실시간으로 반영하여 최단 경로로 라우팅을 지원함 | 최단 경로 탐색에 다익스트라(Dijkstra) 알고리즘을 사용함 | 라우팅 정보에 변화가 생길 경우 변화된 정보만 네트워크 내의 모든 라우터에 알림 | 하나의 자율 시스템(AS)에서 동작하면서 내부 라우팅 프로토콜의 그룹에 도달함 | . | . | EGP(Exterior Gateway Protocol, 외부 게이트웨이 프로토콜) 자율 시스템 간의 라우팅, 즉 게이트웨이 간의 라우팅에 사용되는 프로토콜 | . | BGP(Border Gateway Protocol) 자율 시스템 간의 라우팅 프로토콜로, EGP의 단점을 보완하기 위해 만들어졌음 | 초기에 BGP 라우터들이 연결될 때에는 전체 경로 제어표(라우팅 테이블)를 교환하고, 이후에는 변화된 정보만을 교환함 | . | . 3. 트래픽 제어 . 네트워크의 보호, 성능 유지, 네트워크 자원의 효율적인 이용을 위해 전송되는 패킷의 흐름 또는 그 양을 조절하는 기능임 | 종류 흐름 제어 | 폭주(혼합) 제어 | 교착상태 방지 | . | . 4. 흐름 제어(Flow Control) . 네트워크 내의 원활한 흐름을 위해 송.수신 측 사이에 전송되는 패킷의 양이나 속도를 규제하는 기능임 | 기법 정지-대기(Stop-and-Wait) 수신 측의 확인 신호(ACK)를 받은 후에 다음 패킷을 전송하는 방식 | 한 변에 하나의 패킷만을 전송할 수 있음 | . | 슬라이딩 윈도우(Sliding Window) 확인 신호, 즉 수신 통지를 이용하여 송신 데이터의 양을 조절하는 방식 | 수신 측의 확인 신호를 받지 않더라도 미리 정해진 패킷의 수만큼 연속적으로 전송하는 방식으로, 한 번에 여러 개의 패킷을 전송할 수 있어 전송 효율이 좋음 | 송신 측은 수신 측으로부터 확인 신호(ACK) 없이도 보낼 수 있는 패킷의 최대치를 미리 약속받는데, 이 패킷의 최대치가 윈도우 크기(Windows Size)를 의미함 | 윈도우 크기는 상황에 따라 변함. 즉, 수신 측으로부터 이전에 송신한 패킷에 대한 긍정 수신 응답(ACK)이 전달된 경우 윈도우 크기는 증가하고, 수신 측으로부터 이전에 송신한 패킷에 대한 부정 수신 응답(NAK)이 전달된 경우 윈도우 크기는 감소함 | . | . | . 5. 폭주 제어(Congestion Control) . 흐름 제어가 송.수신 측 사이의 패킷 수를 제어하는 기능이라면, 폭주 제어는 네트워크 내의 패킷 수를 조절하여 네트워크의 오버플로를 방지하는 기능을 함 | 기법 느린 시작(Slow Start) 윈도우의 크기를 1, 2, 4, 8, … 과 같이 2배씩 지수적으로 증가시켜 초기에는 느리지만 갈수록 빨라짐 | 전송 데이터의 크기가 임계 값에 도달하며 혼잡 회피 단계로 넘어감 | . | 혼잡 회피(Congestion Avoidance) 느린 시작의 지수적 증가가 임계 값에 도달되면 혼잡으로 간주하고 회피를 위해 윈도우의 크기를 1씩 선형적으로 증가시켜 혼잡을 예방하는 방식 | . | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/31/theory181.html",
            "relUrl": "/theory/2021/08/31/theory181.html",
            "date": " • Aug 31, 2021"
        }
        
    
  
    
        ,"post20": {
            "title": "빌드 자동화 도구",
            "content": "1. 빌드 자동화 도구 . 빌드를 포함하여 테스트 및 배포를 자동화하는 도구 | 애자일과 같은 지속적인 통합(Continuous Integration) 개발 환경에서 유용하게 활용됨 | 빌드 자동화 도구에는 Ant, Make, Maven, Gradle, Jenkins 등이 있으며, 이중 Jenkins와 Gradle이 가장 대표적임 | . 2. Jenkins . JAVA 기반의 오픈 소스 형태로, 서블릿 컨테이너에서 실행되는 서버 기반 도구임 | 가장 많이 사용되는 빌드 자동화 도구임 | SVN, Git 등 대부분의 형상 관리 도구와 연동이 가능함 | 친숙한 Web GUI 제공으로 사용이 쉬움 | . 3. Gradle . Groovy를 기반으로 한 오픈 소스 형태의 자동화 도구임 | 안드로이드 앱 개발 환경에서 사용됨 | 안드로이드뿐만 아니라 플러그인을 설정하면, JAVA, C/C++, Python 등의 언어도 빌드할 수 있음 | Groovy를 사용해서 만든 DSL(Domain Specific Language)을 스크립트 언어로 사용함 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/31/theory199.html",
            "relUrl": "/theory/2021/08/31/theory199.html",
            "date": " • Aug 31, 2021"
        }
        
    
  
    
        ,"post21": {
            "title": "Git(깃) 명령어 활용",
            "content": "다음은 지역 저장소의 생성, 변경 내역 저장, 새로운 브랜치의 생성과 병합 그리고 지역 저장소의 변경 내역을 원격 저장소에 저장하는 과정임 . 계정 설정하기 . Git을 통해 버전을 관리하려면 먼저 사용자 이름과 사용자 이메일을 등록하여 계정을 설정해야 함 . $ git config –global user.name “gang” . $ git config –global user.email “gang@naver.com” . #### 지역 저장소 만들기 . 계정을 설정한 후에는 버전 관리 내역이 저장될 지역 저장소를 만들어야 함. 지역 저장소는 실제 개발 작업을 진행하는 폴더에 생성해야 함 . 작업 폴더가 gitstudy라고 가정하고 gitstudy로 이동한 후 ‘init’ 명령을 실행하면, 현재 폴더에 ‘.GIT’이라는 지역 저장소 폴더가 그 안에 버전 관리에 필요한 폴더 및 파일들을 포함한 상태로 생성됨. 이후 버전 관리 내역은 ‘.GIT’ 폴더에 저장됨 | $ git init . 변경 내역을 지역 저장소에 저장하기 . 작업을 수행하여 변경된 파일들은 다음의 두 단계를 거쳐 지역 저장소에 저장됨 . . ** 작업 폴더(gitstudy)에 Java로 작성한 4개의 파일들이 있고 4개의 파일 모두 변동 내역이 발생한 상태라고 가정하고 이후 작업을 수행함 . [파일 목록] . Test01.java . Test02.java . Test03.java . Test04.java . 작업 내역을 지역 저장소에 저장하기 전에 스테이징 영역에 추가함 | $ git add –all //파일 중 변경 내용이 있는 파일만 모두 스테이징 영역에 추가함 . 작업 내역을 지역 저장소에 저장함 | $ git commit -m “첫 번재 커밋 작업 완료” //작업 내역을 지역 저장소에 저장하면서 “첫 번재 커밋 작업 완료”라는 메시지를 부여한다. 메시지는 향후 작업 시 참고 자료가 됨 . 병합(Merge) 기능 사용하기 . 처음 commit을 하면 마스터 브랜치가 생성되고 이 브랜치에서 실질적인 버전 관리가 수행됨. 기본적인 작업과 별도로 새로운 기능에 대한 테스트가 필요할 때는 새로운 브랜치를 만들어 테스트를 수행한 후 테스트가 정상적으로 완료되면 새로운 기능에 대한 작업 내역을 마스터 브랜치에 병합하여 저장함 . 새로운 브랜치(new_test)를 생성함 | $ git branch new_test . 가장 최근의 commit을 가리키는 포인터를 현재 작업중인 마스터 브랜치에서 ‘new_test’ 브랜치로 이동함 | $ git checkout new_test . 현재 작업 폴더의 변경 내역을 저장함. commit을 가리키는 포인터가 ‘new_test’ 브랜치로 옮겼기 때문에 변경 내역은 ‘new_test’ 브랜치에 저장됨 | Test05.java를 생성하였다고 가정한다. | . $ git add Test05.java //’Test05.java’ 파일을 스테이징 영역에 추가함 . $ git commit -m “두 번째 커밋 완료” //’new_test’ 브랜치에서 커밋을 수행하면서 “두 번째 커밋 완료”라는 메시지를 부여함 . ‘new_test’ 브랜치의 커밋 내역을 마스터 브랜치와 병합하기 위해 commit을 가리키는 포인터를 마스터(master) 브랜치로 이동함 | $ git checkout master . ‘new_test’ 브랜치의 커밋 내역을 마스터 브랜치와 병합한 후 ‘new_test’ 브랜치를 제거함 | $ git merge new_test //’new_test’ 브랜치의 커밋 내역을 마스터 브랜치에 반영함 . $ git branch –d new_test //new_test 브랜치를 제거함 . 지역 저장소의 버전 관리 내역을 원격 저장소에 저장하기 . 원격 저장소는 여러 사람들이 협업을 위해 공동으로 버전을 관리하는 곳으로, 자신의 버전 관리 내역을 반영하거나 다른 개발자의 변경 내용을 가져올 때 사용함 . 지역 저장소의 변경 내역을 원격 저장소에 반영할 때 사용하는 명령이 push인데, 이 명령을 사용하려면 원격 저장소의 위치를 별명으로 지정해야 함 | $ git remote add abc https://github.com/kek/remotetest.git //사용자가 ‘kek’이고 저장소 이름이 ‘remotetest’인 원격 저장소의 별명을 abc로 지정함 . 지역 저장소의 변경 내역을 다른 개발자와 공유하기 위해 원격 저장소에 저장함 | $ git push abc master //원격 저장소(abc)에 마스터 브랜치의 내용을 반영함 . .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/31/theory198.html",
            "relUrl": "/theory/2021/08/31/theory198.html",
            "date": " • Aug 31, 2021"
        }
        
    
  
    
        ,"post22": {
            "title": "소프트웨어 버전 관리 도구",
            "content": "1. 공유 폴더 방식 . 버전 관리 자료가 지역 컴퓨터의 공유 폴더에 저장되어 관리되는 방식임 | 파일을 잘못 복사하거나 다른 위치로 복사하는 것에 대비하기 위해 파일의 변경 사항을 데이터베이스에 기록하여 관리함 | 종류: SCCS, RCS, PVCS, QVCS 등 | . 2. 클라이언트/서버 방식 . 버전 관리 자료가 서버에 저장되어 관리되는 방식임 | 모든 버전 관리는 서버에서 수행됨 | 서버에 문제가 생기면 서버가 복구되기 전까지 다른 개발자와의 협업 및 버전 관리 작업은 중단됨 | 종류: CVS, SVN(Subversion), CVSNT, Clear Case, CMVC, Perforce 등 | . 3. 분산 저장소 방식 . 버전 관리 자료가 하나의 원격 저장소와 분산된 개발자 PC의 지역 저장소에 함께 저장되어 관리되는 방식임 | 지역 저장소에서 버전 관리가 가능하므로 원격 저장소에 문제가 생겨도 지역 저장소의 자료를 이용하여 작업할 수 있음 | 종류: Git, GNU arch, DCVS, Bazaar, Mercurial, TeamWare, Bitkeeper, Plastic SCM 등 | . 4. Subversion(서브버전, SVN) . CVS를 개선한 것으로, 아파치 소프트웨어 재단에서 2000년에 발표하였음 | 클라이언트/서버 구조로, 서버(저장소, Repository)에는 최신 버전의 파일들과 변경 사항이 관리됨 | 소스가 오픈되어 있어 무료로 사용할 수 있음 | CVS의 단점이었던 파일이나 디렉터리의 이름 변경, 이동 등이 가능함 | Subversion의 주요 명령어 add 새로운 파일이나 디렉터리를 버전 관리 대상으로 등록함 | add로 등록되지 않은 대상은 commit이 적용되지 않음 | . | commit 버전 관리 대상으로 등록된 클라이언트의 소스 파일을 서버의 소스 파일에 적용함 | . | update 서버의 최신 commit 이력을 클라이언트의 소스 파일에 적용함 | commit 전에는 매번 update를 수행하여 클라이언트에 적용되지 않은 서버의 변동 내역을 클라이언트에 적용함 | . | checkout 버전 관리 정보와 소스 파일을 서버에서 클라이언트로 받아옴 | . | lock/unlock 서버의 소스 파일이나 디렉터리를 잠그거나 해제함 | . | import 아무것도 없는 서버의 저장소에 맨 처음 소스 파일을 저장하는 명령으로, 한 번 사용하면 다시 사용하지 않음 | . | export 버전 관리에 대한 정보를 제외한 순수한 소스 파일만을 서버에서 받아옴 | . | info 지정한 파일에 대한 위치나 마지막 수정 일자 등에 대한 정보를 표시함 | . | diff 지정된 파일이나 경로에 대해 이전 리비전과의 차이를 표시함 | . | merge 다른 디렉터리에서 작업된 버전 관리 내역을 기본 개발 작업과 병합함 | . | . | . 5. Git(깃) . 리누스 토발즈가 2005년 리눅스 커널 개발에 사용할 관리 도구로 개발한 이후 주니오 하마노에 의해 유지 보수되고 있음 | 분산 버전 관리 시스템으로 2개의 저장소, 즉 지역 저장소와 원격 저장소가 존재함 | 버전 관리가 지역 저장소에서 진행되므로 버전 관리가 신속하게 처리되고, 원격 저장소나 네트워크에 문제가 있어도 작업이 가능함 | Git의 주요 명령어 add 작업 내역을 지역 저장소에 저장하기 위해 스테이징 영역에 추가함 | ’–all’ 옵션으로 작업 디렉터리의 모든 파일을 스테이징 영역에 추가할 수 있음 | . | commit 작업 내역을 지역 저장소에 저장함 | . | branch 새로운 브랜치를 생성함 | 최초로 commit을 하면 마스터 브랜치가 생성됨 | commit 할 때마다 해당 브랜치는 가장 최근의 commit한 내용을 가리키게 됨 | ‘-d’ 옵션으로 브랜치를 삭제할 수 있음 | . | checkout 지정한 브랜치로 이동함 | 현재 작업 중인 브랜치는 HEAD 포인터가 가리키는데, checkout 명령을 통해 HEAD 포인터를 지정한 브랜치로 이동시킴 | . | merge 지정한 브랜치의 변경 내역을 현재 HEAD 포인터가 가리키는 브랜치에 반영함으로써 두 브랜치를 병함함 | . | init 지역 저장소를 생성함 | . | remote add 원격 저장소에 연결함 | . | push 로컬 저장소의 변경 내역을 원격 저장소에 반영함 | . | fetch 원격 저장소의 변경 이력만을 지역 저장소로 가져와 반영함 | . | clone 원격 저장소의 전체 내용을 지역 저장소로 복제함 | . | fork 지정한 원격 저장소의 내용을 자신의 원격 저장소로 복제함 | . | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/31/theory197.html",
            "relUrl": "/theory/2021/08/31/theory197.html",
            "date": " • Aug 31, 2021"
        }
        
    
  
    
        ,"post23": {
            "title": "소프트웨어 버전 등록",
            "content": "1. 소프트웨어 패키징의 형상 관리 . 형상 관리(SCM; Software Configuration Management)는 개발 과정에서 소프트웨어의 변경 사항을 관리하기 위해 개발된 일련의 활동임 | 형상 관리는 소프트웨어 개발의 전 단계에 적용되는 활동이며, 유지보수 단계에서도 수행됨 | 형상 관리는 소프트웨어 개발의 전체 비용을 줄이고, 개발 과정의 여러 방해 요인이 최소화되도록 보증하는 것을 목적으로 함 | . 2. 형상 관리 기능 . 형상 식별: 형상 관리 대상에 이름과 관리 번호를 부여하고, 계층 구조로 구분하여 수정 및 추적이 용이하도록 하는 작업 | 버전 제어: 소프트웨어 업그레이드나 유지 보수 과정에서 생성된 다른 버전의 형상 항목을 관리하고, 이를 위해 특정 절차와 도구(Tool)를 결합시키는 작업 | 형상 통제: 식별된 형상 항목에 대한 변경 요구를 검토하여 현재의 기준선이 잘 반영될 수 있도록 조정하는 작업 | 형상 감사: 기준선의 무결성을 평가하기 위해 확인, 검증, 검열 과정을 통해 공식적으로 승인하는 작업 | 형상 기록: 형상의 식별, 통제, 감사 작업의 결과를 기록.관리하고 보고서를 작성하는 작업 | . 3. 소프트웨어의 버전 등록 관련 주요 기능 . 저장소(Repository) 최신 버전의 파일들과 변경 내역에 대한 정보들이 저장되어 있는 곳 | . | 가져오기(Import) 버전 관리가 되고 있지 않은 아무것도 없는 저장소(Repository)에 처음으로 파일을 복사함 | . | 체크아웃(Check-Out) 프로그램을 수정하기 위해 저장소에서 파일을 받아옴 | 소스 파일과 함께 버전 관리를 위한 파일들도 받아옴 | . | 체크인(Check-In) 체크아웃 한 파일의 수정을 완료한 후 저장소의 파일을 새로운 버전으로 갱신함 | . | 커밋(Commit) 체크인을 수행할 때 이전에 갱신된 내용이 있는 경우에는 충돌(Conflict)을 알리고 diff 도구를 이용해 수정한 후 갱신을 완료함 | . | 동기화(Update) 저장소에 있는 최신 버전으로 자신의 작업 공간을 동기화함 | . | . 4. 소프트웨어 버전 등록 과정 . 가져오기(Import) 개발자가 저장소에 신규로 파일을 추가함 | | 인출(Check-Out) 수정 작업을 진행할 개발자가 저장소에 추가된 파일을 자신의 작업 공간으로 인출함 | | 예치(Commit) 인출한 파일을 수정한 후 설명을 붙여 저장소에 예치함 | | 동기화(Update) 커밋 후 새로운 개발자가 자신의 작업 공간을 동기화함. 이때 기존 개발자가 추가했던 파일이 전달됨 | | 차이(Diff) 새로운 개발자가 추가된 파일의 수정 기록을 확인하면서 이전 개발자가 처음 추가한 파일과 이후 변경된 파일의 차이를 확인함 | |",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/31/theory196.html",
            "relUrl": "/theory/2021/08/31/theory196.html",
            "date": " • Aug 31, 2021"
        }
        
    
  
    
        ,"post24": {
            "title": "소프트웨어 사용자 매뉴얼 작성",
            "content": "1. 소프트웨어 사용자 매뉴얼 . 사용자가 소프트웨어를 사용하는 과정에서 필요한 내용을 문서로 기록한 설명서와 안내서임 | 사용자가 소프트웨어 사용에 필요한 절차, 환경 등의 제반사항이 모두 포함되도록 작성함 | 소프트웨어 배포 후 발생될 수 있는 오류에 대한 패치나 기능에 대한 업그레이드를 위해 매뉴얼의 버전을 관리함 | 개별적으로 동작이 가능한 컴포넌트 단위로 매뉴얼을 작성함 | 사용자 매뉴얼은 컴포넌트 명세서와 컴포넌트 구현 설계서를 토대로 작성함 | . 2. 사용자 매뉴얼 작성 순서 . 기능 식별 소프트웨어의 개발 목적과 사용자 활용 기능을 흐름 순으로 정리하여 기록함 | | 사용자 화면 분류 사용자 화면을 메뉴별로 분류하여 기록함 | | 사용자 환경 파일 확인 폴더 위치, 사용자 로그 파일, 백업 파일 등의 개별적인 기능을 확인하여 기록함 | | 초기화 절차 확인 프로그램을 사용하기 위한 초기화 절차를 확인하고 그 단계를 순서대로 기록함 | | 이상 Case 확인 소프트웨어 사용 과정에서 발생할 수 있는 다양한 이상 Case를 만들어 확인하고 해당 Case에 대한 대처법을 자세하게 기록함 | | 최종 매뉴얼 적용 사용과 관련된 문의 답변을 정리하여 기록함 | 완성된 매뉴얼을 검토하고 고객 지원에 대한 내용을 기록함 | |",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/31/theory195.html",
            "relUrl": "/theory/2021/08/31/theory195.html",
            "date": " • Aug 31, 2021"
        }
        
    
  
    
        ,"post25": {
            "title": "소프트웨어 설치 매뉴얼 작성",
            "content": "1. 소프트웨어 설치 매뉴얼 . 개발 초기에서부터 적용된 기준이나 사용자가 소프트웨어를 설치하는 과정에 필요한 내용을 기록한 설명서와 안내서임 | 설치 매뉴얼은 사용자 기준으로 작성함 | 설치 시작부터 완료할 때까지의 전 과정을 빠짐없이 순서대로 설명함 | 설치 과정에서 표시될 수 있는 오류 메시지 및 예외 상황에 관한 내용을 별도로 분류하여 설명함 | . 2. 설치 매뉴얼 작성 순서 . 기능 식별 소프트웨어의 개발 목적과 주요 기능을 흐름 순으로 정리하여 기록함 | | UI 분류 설치 매뉴얼을 작성할 순서대로 UI를 분류한 후 기록함 | | 설치 파일/백업 파일 확인 폴더 위치, 설치 파일, 백업 파일 등의 개별적인 기능을 확인하여 기록함 | | Uninstall 절차 확인 직접 Uninstall을 수행하면서 그 순서를 단계별로 자세히 기록함 | | 이상 Case 확인 설치 과정에서 발생할 수 있는 다양한 Case를 만들어 확인하고 해당 Case에 대한 대처법을 자세하게 기록함 | | 최종 매뉴얼 적용 설치가 완료된 화면과 메시지를 캡쳐하여 추가함 | 완성된 매뉴얼을 검토하고 고객 지원에 대한 내용을 기록함 | |",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/31/theory194.html",
            "relUrl": "/theory/2021/08/31/theory194.html",
            "date": " • Aug 31, 2021"
        }
        
    
  
    
        ,"post26": {
            "title": "디지털 저작권 관리(DRM)",
            "content": "1. 저작권 . 소설, 시, 논문, 강연, 연술, 음악, 연극, 무용, 회화, 서예, 건축물, 사진, 영상, 지도, 도표, 컴퓨터 프로그램 저작물 등에 대하여 창작자가 가지는 배타적 독점적 권리로, 타인의 침해를 받지 않을 고유한 권한임 | 컴퓨터 프로그램들과 같이 복제하기 쉬운 저작물에 대해 불법 복제 및 배포 등을 막기 위한 기술적인 방법을 통칭해 저작권 보호 기술이라고 함 | . 2. 디지털 저작권 관리(DRM; Digital Right Management) . 저작권자가 배포한 디지털 콘텐츠가 저작권자가 의도한 용도로만 사용되도록 디지털 콘텐츠의 생성, 유통, 이용까지의 전 과정에 걸쳐 사용되는 디지털 콘텐츠 관리 및 보호 기술임 | 원본 콘텐츠가 아날로그인 경우에는 디지털로 변환한 후 패키저로 DRM 패키징을 수행함 | 패키징을 수행하면 콘텐츠에는 암호화된 저작권자의 전자서명이 포함되고 저작권자가 설정한 라이선스 정보가 클리어링 하우스에 등록됨 | . 3. 디지털 저작권 관리의 흐름 및 구성 요소 . . 클리어링 하우스: 저작권에 대한 사용 권한, 라이선스 발급, 암호화된 키 관리, 사용량에 따른 결제 관리 등을 수행하는 곳 | 콘텐츠 제공자: 콘텐츠를 제공하는 저작권자 | 패키저: 콘텐츠를 메타 데이터와 함께 배포 가능한 형태로 묶어 암호화하는 프로그램 | 콘텐츠 분배자: 암호화된 콘텐츠를 유통하는 곳이나 사람 | 콘텐츠 소비자: 콘텐츠를 구매해서 사용하는 주체 | DRM 컨트롤러: 배포된 콘텐츠의 이용 권한을 통제하는 프로그램 | 보안 컨테이너: 콘텐츠 원본을 안전하게 유통하기 위한 전자적 보안 장치 | . 4. 디지털 저작권 관리의 기술 요소 . 암호화: 콘텐츠 및 라이선스를 암호화하고 전자 서명을 할 수 있는 기술 | 키 관리: 콘텐츠를 암호화한 키에 대한 저장 및 분배 기술 | 암호화 파일 생성: 콘텐츠를 암호화된 콘텐츠로 생성하기 위한 기술 | 식별 기술: 콘텐츠에 대한 식별 체계 표현 기술 | 저작권 표현: 라이선스의 내용 표현 기술 | 정책 관리: 라이선스 발급 및 사용에 대한 정책 표현 및 관리 기술 | 크랙 방지: 크랙에 의한 콘텐츠 사용 방지 기술 | 인증: 라이선스 발급 및 사용의 기준이 되는 사용자 인증 기술 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/31/theory193.html",
            "relUrl": "/theory/2021/08/31/theory193.html",
            "date": " • Aug 31, 2021"
        }
        
    
  
    
        ,"post27": {
            "title": "릴리즈 노트 작성",
            "content": "1. 릴리즈 노트(Release Note) . 소프트웨어 개발 과정에서 정리된 릴리즈 정보를 최종 사용자인 고객과 공유하기 위한 문서임 | 릴리즈 노트를 통해 테스트 진행 결과와 소프트웨어 사양에 대한 개발팀의 정확한 준수 여부를 확인할 수 있음 | 소프트웨어에 포함된 전체 기능, 서비스의 내용, 개선 사항 등을 사용자와 공유할 수 있음 | . 2. 릴리즈 노트 작성 항목 . Header(머릿말) 릴리즈 노트 이름, 소프트웨어 이름, 릴리즈 버전, 릴리즈 날짜, 릴리즈 노트 날짜, 릴리즈 노트 버전 등 | . | 개요 소프트웨어 및 변경사항 전체에 대한 간략한 내용 | . | 목적 해당 릴리즈 버전에서의 새로운 기능이나 수정된 기능의 목록과 릴리즈 노트의 목적에 대한 간략한 개요 | . | 재현 항목 버그 발견에 대한 과정 설명 | . | 수정/개선 내용 버그를 수정/개선한 내용을 간단히 설명 | . | 사용자 영향도 사용자가 다른 기능들을 사용하는데 있어 해당 릴리즈 버전에서의 기능 변화가 미칠 수 있는 영향에 대한 설명 | . | SW 지원 영향도 해당 릴리즈 버전에서의 기능 변화가 다른 응용 프로그램들을 지원하는 프로세스에 미칠 수 있는 영향에 대한 설명 | . | 노트 SW/HW 설치 항목, 업그레이드, 소프트웨어 문서화에 대한 참고 항목 | . | 면책 조항 회사 및 소프트웨어와 관련하여 참조할 사항 | 예) 프리웨어, 불법 복제 금지 등 | . | 연락처 사용자 지원 및 문의 응대를 위한 연락처 정보 | . | . 3. 릴리즈 노트 작성 순서 . 모듈 식별 모듈별 빌드 수행 후 릴리즈 노트에 작성될 내용을 확인함 | | 릴리즈 정보 확인 릴리즈 노트 이름, 소프트웨어 이름, 릴리즈 버전, 릴리즈 날짜, 노트 날짜, 노트 버전 등을 확인함 | | 릴리즈 노트 개요 작성 소프트웨어 및 변경사항 전체에 대한 간략한 내용을 작성함 | | 영향도 체크 버그나 이슈 관련 내용 또는 해당 릴리즈 버전에서의 기능 변화가 다른 소프트웨어나 기능을 사용하는데 미칠 수 있는 영향에 대해 기술함 | | 정식 릴리즈 노트 작성 Header(머릿말), 개요, 영향도 체크 항목을 포함하여 정식 릴리즈 노트에 작성될 기본 사항을 작성함 | | 추가 개선 항목 식별 추가 버전 릴리즈 노트 작성이 필요한 경우 추가 릴리즈 노트를 작성함 | |",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/31/theory192.html",
            "relUrl": "/theory/2021/08/31/theory192.html",
            "date": " • Aug 31, 2021"
        }
        
    
  
    
        ,"post28": {
            "title": "소프트웨어 패키징",
            "content": "1. 소프트웨어 패키징 . 모듈별로 생성한 실행 파일들을 묶어 배포용 설치 파일을 만드는 것을 말함 | 개발자가 아니라 사용자를 중심으로 진행함 | 소스 코드는 향후 관리를 고려하여 모듈화하여 패키징함 | . 2. 패키징 작업 순서 . 기능 식별 작성된 코드의 기능을 확인함 | | 모듈화 확인된 기능 단위로 코드들을 분류함 | | 빌드 진행 모듈 단위별로 실행 파일을 만듦 | | 사용자 환경 분석 웹, 모바일, PC 등 소프트웨어가 사용될 환경이나 운영체제, CPU, RAM 등의 최소 운영 환경을 정의함 | | 패키징 및 적용 시험 빌드된 실행 파일들을 정의된 환경에 맞게 배포용 파일 형식으로 패키징함 | 정의된 환경과 동일한 환경에서 패키징 결과를 테스팅한 후 소프트웨어에 대한 불편사항을 사용자 입장에서 확인함 | | 패키징 변경 개선 확인된 불편 사항을 반영하기 위한 패키징의 변경 및 개선을 진행함 | | 배포 배포 수행 시 오류가 발생하면 해당 개발자에게 전달하여 수정을 요청함 | |",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/31/theory191.html",
            "relUrl": "/theory/2021/08/31/theory191.html",
            "date": " • Aug 31, 2021"
        }
        
    
  
    
        ,"post29": {
            "title": "데이터 표준화",
            "content": "1. 데이터 표준화 . 시스템을 구성하는 데이터 요소의 명칭, 정의, 형식, 규칙에 대한 원칙을 수립하고 적용하는 것을 의미함 | 데이터 표준화 작업을 통해 사용자가 데이터를 정확히 이해하고 활용할 수 있도록 표준 항목명이 부여됨 | 데이터 표준화 작업을 통해 엔티티, 속성, 테이블, 컬럼 등 데이터 요소에 쓰일 단어에 대해 일정한 규칙이 적용됨 | . 2. 데이터 표준화 구성 요소 . 데이터 표준 데이터 모델이나 DB에서 정의할 수 있는 모든 오브젝트를 대상으로 데이터 표준화를 수행함 | 데이터 표준의 종류 표준 단어: 업무에서 사용하고 일정한 의미를 가진 최소 단위의 단어 | 표준 도메인: 문자형, 숫자형, 날짜형, 시간형과 같이 컬럼을 성질에 따라 묶은 것 | 표준 코드: 선택할 수 있는 값을 정형화하기 위해 기준에 맞게 정의된 코드 값으로, 도메인의 한 유형임 | 표준 용어: 단어, 도메인, 코드 표준이 정의되면 이를 바탕으로 표준 용어를 구성함 | . | . | 데이터 관리 조직 데이터 표준 원칙이나 데이터 표준의 준수 여부 등을 관리하는 사람들로, 대표적으로 데이터 관리자가 있음 | 데이터 관리자는 조직 내의 데이터에 대한 정의, 체계화, 감독 등의 업무를 담당함 | . | 데이터 표준화 절차 데이터 표준화 요구사항 수집, 데이터 표준 정의, 데이터 표준 확정, 데이터 표준 관리 순으로 진행됨 | . | . . 3. 데이터 표준화의 대상 . 데이터 명칭 데이터를 유일하게 구별할 수 있는 유일성, 의미 전달의 충분성, 그리고 업무적 보편성을 갖는 이름으로 정의해야 함 | . | 데이터 정의 데이터를 제3자의 입장에서도 쉽게 이해할 수 있도록 해당 데이터가 의미하는 범위 및 자격 요건 등을 규정함 | . | 데이터 형식 업무 규칙 및 사용 목적과 유사한 데이터에 대해 일관되게 데이터 형식을 정의함으로써 데이터 입력 오류, 통제 위험 등을 최소화함 | . | 데이터 규칙 기본 값, 허용 값, 허용 범위 등과 같이 발생할 수 있는 데이터 값을 사전에 지정함으로써 데이터의 정합성 및 완전성을 향상시킴 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/31/theory190.html",
            "relUrl": "/theory/2021/08/31/theory190.html",
            "date": " • Aug 31, 2021"
        }
        
    
  
    
        ,"post30": {
            "title": "교착상태",
            "content": "1. 교착상태(Dead Lock) . 상호 배제에 의해 나타나는 문제점으로, 둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상을 의미함 | . 2. 교착상태 발생의 필요 충분 조건 . 교착상태가 발생하기 위해서는 다음의 네 가지 조건이 충족되어야 하는데, 이 네 가지 조건 중 하나라도 충족되지 않으면 교착상태가 발생하지 않음 | . 상호 배제(Mutual Exclusion) 한 번에 한 개의 프로세스만이 공유 자원을 사용할 수 있어야 함 | | 점유와 대기(Hold and Wait) 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용되고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 함 | | 비선점(Non-preemption) 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 함 | | 환형 대기(Circular Wait) 공유 자원과 공유 자원을 사용하기 위해 대기하는 프로세스들이 원형으로 구성되어 있어 자신에게 할당된 자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원을 요구해야 함 | | 3. 교착상태의 해결 방법 . 예방 기법(Prevention) 교착상태가 발생하지 않도록 사전에 시스템을 제어하는 방법 | 교착상태 발생의 네 가지 조건 중에서 어느 하나를 제거함으로써 수행됨 | 자원의 낭비가 가장 심한 기법임 | . | 회피 기법(Avoidance) 교착상태가 발생할 가능성을 배제하지 않고 교착상태가 발생하면 적절히 피해나가는 방법 | 주로 은행원 알고리즘(Banker’s Algorithm)이 사용됨 | 은행원 알고리즘: E. J. Dijkstra가 제안한 것으로 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는 데서 유래한 기법 | . | 발견 기법(Detection) 시스템에 교착상태가 발생했는지 점검하여 교착상태에 있는 프로세스와 자원을 발견하는 것 | 교착상태 발견 알고리즘과 자원 할당 그래프 등을 사용할 수 있음 | . | 회복 기법(Recovery) 교착상태를 일으킨 프로세스를 종료하거나 교착상태의 프로세스에 할당된 자원을 선점하여 프로세스나 자원을 회복하는 것 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/31/theory189.html",
            "relUrl": "/theory/2021/08/31/theory189.html",
            "date": " • Aug 31, 2021"
        }
        
    
  
    
        ,"post31": {
            "title": "회복/병행제어",
            "content": "1. 회복(Recovery) . 트랜잭션들을 수행하는 도중 장애가 발생하여 데이터베이스가 손상되었을 때 손상되기 이전의 정상 상태로 복구하는 작업임 | 회복 기법의 종류 연기 갱신 기법(Deferred Update) 트랜잭션이 성공적으로 완료될 때까지 데이터베이스에 대한 실질적인 갱신을 연기하는 방법 | 트랜잭션이 수행되는 동안 갱신된 내용은 일단 Log에 보관됨 | 트랜잭션의 부분 완료 시점에 Log에 보관한 갱신 내용을 실제 데이터베이스에 기록함 | Redo 작업만 가능함 | . | 즉각 갱신 기법(Immediate Update) 트랜잭션이 데이터를 갱신하면 트랜잭션이 부분 완료되기 전이라도 즉시 실제 데이터베이스에 반영하는 방법 | 장애가 발생하여 회복 작업할 경우를 대비하여 갱신된 내용들은 Log에 보관시킴 | Redo와 Undo 모두 사용 가능함 | . | 그림자 페이지 대체 기법(Shadow Paging) 갱신 이전의 데이터베이스를 일정 크기의 페이지 단위로 구성하여 각 페이지마다 복사본인 그림자 페이지를 별도 보관해 놓고, 실제 페이지를 대상으로 갱신 작업을 수행하다가 장애가 발생하여 트랜잭션 작업을 Rollback시킬 때는 갱신 이후의 실제 페이지 부분을 그림자 페이지로 대체하여 회복시키는 기법 | . | 검사점 기법(Check Point) 트랜잭션 실행 중 특정 단계에서 재실행할 수 있도록 갱신 내용이나 시스템에 대한 상황 등에 관한 정보와 함께 검사점을 로그에 보관해 두고, 장애 발생 시 트랜잭션 전체를 철회하지 않고 검사점부터 회복 작업을 수행하여 회복시간을 절약하도록 하는 기법 | . | . | . 2. 병행제어(Concurrency Control) . 다중 프로그램의 이점을 활용하여 동시에 여러 개의 트랜잭션을 병행수행할 때, 동시에 실행되는 트랜잭션들이 데이터베이스의 일관성을 파괴하지 않도록 트랜잭션 간의 상호 작용을 제어하는 것임 | 병행제어 없이 트랜잭션들이 데이터베이스에 동시에 접근하도록 허용할 경우 갱신 분실, 비완료 의존성, 모순성, 연쇄 복귀 등의 문제가 발생함 | 병행제어 기법의 종류 로킹(Locking) 트랜잭션들이 어떤 로킹 단위를 액세스하기 전에 Lock(잠금)을 요청해서 Lock이 허락되어야만 그 로킹 단위를 액세스할 수 있도록 하는 기법 | 주요 데이터의 액세스를 상호 배타적으로 함 | . | 타임 스탬프 순서(Time Stamp Ordering) 트랜잭션과 트랜잭션이 읽거나 갱신한 데이터에 대해 트랜잭션이 실행을 시작하기 전에 시간표(Time Stamp)를 부여하여 부여된 시간에 따라 트랜잭션 작업을 수행하는 기법 | 직렬성 순서를 결정하기 위해 트랜잭션 간의 처리 순서를 미리 선택하는 기법들 중에서 가장 보편적인 방법임 | . | 최적 병행수행(검증 기법, 확인 기법, 낙관적 기법) 병행수행하고자 하는 대부분의 트랜잭션이 판독 전용(Read Only) 트랜잭션일 경우, 트랜잭션 간의 충돌률이 매우 낮아서 병행제어 기법을 사용하지 않고 실행되어도 이 중의 많은 트랜잭션은 시스템의 상태를 일관성 있게 유지한다는 점을 이용한 기법 | . | 다중 버전 기법 타임 스탬프의 개념을 이용하는 기법 | 다중 버전 타임 스탬프 기법이라고도 함 | 타임 스탬프 기법은 트랜잭션 및 데이터들이 이용될 때의 시간을 시간표로 관리하지만, 다중 버전 기법은 갱신될 때마다의 버전을 부여하여 관리함 | . | . | . 3. 로킹 단위(Locking Granularity) . 병행제어에서 한꺼번에 로킹할 수 있는 객체의 크기를 의미함 | 데이터베이스, 파일, 레코드, 필드 등이 로킹 단위가 될 수 있음 | 로킹 단위가 크면 로크 수가 작아 관리하기 쉽지만 병행성 수준이 낮아짐 | 로킹 단위가 작으면 로크 수가 많아 관리하기 복잡해 오버헤드가 증가하지만 병행성 수준이 높아짐 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/31/theory188.html",
            "relUrl": "/theory/2021/08/31/theory188.html",
            "date": " • Aug 31, 2021"
        }
        
    
  
    
        ,"post32": {
            "title": "DB 관련 신기술",
            "content": "1. DB 관련 신기술 . 빅데이터(Big Data) 기존의 관리 방법이나 분석 체계로는 처리하기 어려운 막대한 양의 정형 또는 비정형 데이터 집합 | 빅데이터가 주목받고 있는 이유는 기업이나 정부, 포털 등이 빅데이터를 효과적으로 분석함으로써 미래를 예측해 최적의 대응 방안을 찾고, 이를 수익으로 연결하여 새로운 가치를 창출하기 때문임 | . | 브로드 데이터(Broad Data) 다양한 채널에서 소비자와 상호 작용을 통해 생성된 것으로, 기업 마케팅에 있어 효율적이고 다양한 데이터이며, 이전에 사용하지 않았거나 알지 못했던 새로운 데이터나 기존 데이터에 새로운 가치가 더해진 데이터 | . | 메타 데이터(Meta Data) 일련의 데이터를 정의하고 설명해 주는 데이터 | 컴퓨터에서는 데이터 사전의 내용, 스키마 등을 의미함 | HTML 문서에서는 메타 태그 내의 내용이 메타 데이터임 | . | 디지털 아카이빙(Digital Archiving) 디지털 정보 자원을 장기적으로 보존하기 위한 작업 | 아날로그 콘텐츠는 디지털로 변환한 후 압축해서 저장하고, 디지털 콘텐츠도 체계적으로 분류하고 메타 데이터를 만들어 DB화하는 작업임 | . | 하둡(Hadoop) 오픈 소스를 기반으로 한 분산 컴퓨팅 플랫폼 | 일반 PC급 컴퓨터들로 가상화된 대형 스토리지를 형성하고 그 안에 보관된 거대한 데이터 세트를 병렬로 처리할 수 있도록 개발된 자바 소프트웨어 프레임워크 | 구글, 야후 등에 적용되고 있음 | . | 맵리듀스(MapReduce) 대용량 데이터를 분산 처리하기 위한 목적으로 개발된 프로그래밍 모델 | 흩어져 있는 데이터를 연관성 있는 데이터 분류로 묶는 Map 작업을 수행한 후 중복 데이터를 제거하고 원하는 데이터를 추출하는 Reduce 직업을 수행함 | Google에 의해 고안되었으며, 대표적인 대용량 데이터 처리를 위한 병렬 처리 기법으로 많이 사용되고 있음 | . | 타조(Tajo) 오픈 소스 기반 분산 컴퓨팅 플랫폼인 아파치 하둡 기반의 분산 데이터 웨어하우스 프로젝트 | . | 데이터 다이어트 데이터를 삭제하는 것이 아니라 압축하고, 중복된 정보는 중복을 배제하고, 새로운 기준에 따라 나누어 저장하는 방법 | . | 데이터 마이닝 대량의 데이터를 분석하여 데이터에 내재된 변수 사이의 상호 관계를 규명하여 일정한 패턴을 찾아내는 기법 | . | OLAP(Online Analytical Processing) 다차원으로 이루어진 데이터로부터 통계적인 요약 정보를 분석하여 의사결정에 활용하는 방식 | OLAP 연산: Roll-up, Drill-down, Drill-through, Drill-across, Pivoting, Slicing, Dicing | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/31/theory187.html",
            "relUrl": "/theory/2021/08/31/theory187.html",
            "date": " • Aug 31, 2021"
        }
        
    
  
    
        ,"post33": {
            "title": "Secure OS",
            "content": "1. Secure OS . 기존의 운영체제에 내재된 보안 취약점을 해소하기 위해 보안 기능을 갖춘 커널을 이식하여 외부의 침입으로부터 시스템 자원을 보호하는 운영체제를 의미 | 보안 커널은 보안 기능을 갖춘 커널을 의미하며, TCB를 기반으로 참조 모니터의 개념을 구현하고 집행함 | 보호 방법을 구현하기 복잡한 것부터 차례로 분류하면 다음과 같음 암호적 분리(Cryptographic Separation) 내부 정보를 암호화하는 방법 | . | 논리적 분리(Logical Separation) 프로세스의 논리적 구역을 지정하여 구역을 벗어나는 행위를 제한하는 방법 | . | 시간적 분리(Temporal Separation) 동일 시간에 하나의 프로세스만 수행되도록 하여 동시 실행으로 발생하는 보안 취약점을 제거하는 방법 | . | 물리적 분리(Physical Separation) 사용자별로 특정 장비만 사용하도록 제한하는 방법 | . | . | Secure OS의 보안 기능 식별 및 인증 | 임의적/강제적 접근통제 | 객체 재사용 보호 | 완전한 조정 | 신뢰 경로 | 검사 및 감사기록 축소 등 | . | . 2. 참조 모니터(Reference Monitor) . 보호 대상 객체에 대한 접근통제를 수행하는 추상머신이며, 이것을 실제로 구현한 것이 보안 커널임 | 보안 커널 데이터베이스(SKDB; Security Kernel Database)를 참조하여 객체에 대한 접근 허가 여부를 결정함 | 참조 모니터와 보안 커널의 특징 격리성(Isolation): 부정 조작이 불가능해야 함 | 검증가능성(Verifiability): 적절히 구현되었다는 것을 확인할 수 있어야 함 | 완전성(Completeness): 우회가 불가능해야 함 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/31/theory186.html",
            "relUrl": "/theory/2021/08/31/theory186.html",
            "date": " • Aug 31, 2021"
        }
        
    
  
    
        ,"post34": {
            "title": "HW 관련 신기술",
            "content": "1. HW 관련 신기술 . 고가용성(HA; High Availability) 긴 시간동안 안정적인 서비스 운영을 위해 장애 발생 시 즉시 다른 시스템으로 대체 가능한 환경을 구축하는 메커니즘 | . | 3D Printing 대상을 평면에 출력하는 것이 아니라 손으로 만질 수 있는 실제 물체로 만들어내는 것 | 아의미주 얇은 두께로 한층한층 쌓아 하나의 형태를 만들어내는 기술을 이용함 | . | 4D Printing 특정 시간이나 환경 조건이 갖추어지면 스스로 형태를 변화시키거나 제조되는 자가 조립 기술이 적용된 제품을 3D Printing하는 기술 | . | RAID(Redundant Array of Inexpensive Disk, Redundant Array of Independent Disk) 여러 개의 하드디스크로 디스크 배열을 구성하여 파일을 구성하고 있는 데이터 블록들을 서로 다른 디스크들에 분산 저장할 경우, 그 블록들을 여러 디스크에서 동시에 읽거나 쓸 수 있으므로 디스크의 속도가 매우 향상되는데, 이 기술을 RAID라고 함 | . | 4K 해상도 차세대 고화질 모니터의 해상도를 지칭하는 용어 | 가로 픽셀 수가 3840이고, 세로 픽셀 수가 2160인 영상의 해상도를 말하는데, 이는 Full HDTV(1920 X 1080)의 가로.세로 2배, 총 4배에 해당하는 초고화질의 영상임 | . | 앤 스크린(N-Screen) N개의 서로 다른 단말기에서 동일한 콘텐츠를 자유롭게 이용할 수 있는 서비스 | . | 컴패니언 스크린(Companion Screen) TV 방송 시청 시 방송 내용을 공유하며 추가적인 기능을 수행할 수 있는 스마트폰, 태블릿PC 등을 의미함 | 앤 스크린의 한 종류로, 세컨드 스크린이라고도 불림 | . | 신 클라이언트 PC 하드디스크나 주변장치 없이 기본적인 메모리만 갖추고 서버와 네트워크로 운용되는 개인용 컴퓨터 | 서버 기반 컴퓨팅과 관계가 깊음 | . | 패블릿(Phablet) 폰과 태블릿의 합성어로, 태블릿 기능을 포함한 5인치 이상의 대화면 스마트폰 | . | C형 유에스비 범용 인터페이스 규격인 USB의 표준 중 하나임 | 기존 A형에 비하여 크기가 작고, 24핀으로 위아래의 구분이 없어 어느 방향으로든 연결이 가능함 | . | 멤스(MEMS; Micro-Electro Mechanical Systems) 초정밀 반도체 제조 기술을 바탕으로 센서, 액추에이터 등 기계 구조를 다양한 기술로 미세 가공하여 전기기계적 동작을 할 수 있도록 한 초미세 장치 | . | 트러스트존 기술 하나의 프로세서 내에 일반 애플리케이션을 처리하는 일반 구역과 보안이 필요한 애플리케이션을 처리하는 보안 구역으로 분할하여 관리하는 하드웨어 기반의 보안 기술 | . | 엠디스크 한 번의 기록만으로 자료를 영구 보관할 수 있는 광 저장장치 | 디스크 표면의 무기물층에 레이저를 이용해 자료를 조각해서 기록함 | 시간이 지나도 변하지 않는 금속 활자처럼 빛, 열, 습기 등의 외부 요인에 영향을 받지 않음 | . | 멤리스터 메모리와 레지스터의 합성어로, 전류의 방향과 양 등 기존의 경험을 모두 기억하는 특별한 소자 | 레지스터, 커패시터, 인덕터에 이어 네 번째 전자회로 구성 요소라 불리고 있음 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/31/theory185.html",
            "relUrl": "/theory/2021/08/31/theory185.html",
            "date": " • Aug 31, 2021"
        }
        
    
  
    
        ,"post35": {
            "title": "소프트웨어 개발 보안 활동 관련 법령 및 규정",
            "content": "1. 개인정보 보호 관련 법령 . 개인정보 보호법: 개인정보의 처리 및 보호에 관한 사항을 정함으로써 개인의 자유와 권리를 보호함 | 정보통신망 이용촉진 및 정보보호 등에 관한 법률: 정보통신망의 이용 촉진 및 정보 통신 서비스를 이용하는 이용자들의 개인정보를 보호함 | 신용정보의 이용 및 보호에 관한 법률: 개인 신용정보의 효율적 이용과 체계적인 관리를 통해 정보의 오남용을 방지함 | 위치정보의 보호 및 이용 등에 관한 법률: 개인 위치정보의 안전한 이용 환경을 조성하여 정보의 유출이나 오남용을 방지함 | 표준 개인정보 보호 지침: 개인정보의 처리에 관한 기준, 개인정보 침해의 유형 및 예방조치 등에 관한 세부사항을 규정함 | 개인정보의 안전성 확보 조치 기준: 개인정보 처리자가 개인정보를 처리하는데 있어 개인정보가 분실, 도난, 유출, 위조, 변조, 훼손되지 않도록 안전성 확보에 필요한 기술적, 관리적, 물리적 안전조치에 관한 최소한의 기준을 규정함 | 개인정보 영향평가에 관한 고시: 개인정보 영향평가를 위한 평가기관의 지정, 영향평가의 절차 등에 관한 세부기준을 규정함 | . 2. IT 기술 관련 규정 . RFID 프라이버시 보호 가이드라인: RFID 시스템의 이용자들의 프라이버시를 보호하고 안전한 RFID 이용 환경을 조성하기 위한 가이드라인 | 위치정보의 보호 및 이용 등에 관한 법률: 개인 위치정보의 유출 및 오남용을 방지하기 위한 법률 | 위치정보의 관리적, 기술적 보호조치 권고 해설서: 개인 위치정보의 누출, 변조, 훼손 등을 방지하기 위해 위치정보 사업자 및 위치기반 서비스 사업자가 준수해야 하는 관리적, 기술적 보호조치의 구체적인 기준 | 바이오정보 보호 가이드라인: 개인 바이오정보의 보호와 안전한 활용을 위한 원칙 및 조치사항 | 뉴미디어 서비스 개인정보 보호 가이드라인: 뉴미디어 서비스 이용 및 제공 시 개인 정보의 침해사고를 예방하기 위한 준수사항 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/31/theory184.html",
            "relUrl": "/theory/2021/08/31/theory184.html",
            "date": " • Aug 31, 2021"
        }
        
    
  
    
        ,"post36": {
            "title": "소프트웨어 개발 보안",
            "content": "1. 소프트웨어 개발 보안 . 소프트웨어 개발 과정에서 발생할 수 있는 보안 취약점을 최소화하여 보안 위협으로부터 안전한 소프트웨어를 개발하기 위한 일련의 보안 활동을 의미함 | 소프트웨어 개발 보안은 데이터의 기밀성, 무결성, 가용성을 유지하는 것을 목표로 함 | . 2. 소프트웨어 개발 보안 관련 기관 . 행정안전부 소프트웨어 개발 보안 정책을 총괄함 | 소프트웨어 개발 보안 관련 법규, 지침, 제도를 정비함 | 소프트웨어 보안 약점을 진단하는 사람의 양성 및 관련 업무를 수행함 | . | 한국인터넷진흥원(KISA) 소프트웨어 개발 보안 정책 및 가이드를 개발함 | 소프트웨어 개발 보안에 대한 기술을 지원하고, 교육과정 및 자격제도를 운영함 | . | 발주기관 소프트웨어 개발 보안의 계획을 수립함 | 소프트웨어 개발 보안 사업자 및 감리법인을 설정함 | 소프트웨어 개발 보안의 준수 여부를 점검함 | . | 사업자 소프트웨어 개발 보안 관련 기술 수준 및 적용 계획을 명시함 | 소프트웨어 개발 보안 관련 인력을 대상으로 교육을 실시함 | 소프트웨어 개발 보안 가이드를 참조하여 개발함 | 자체적으로 보안 약점을 진단하고 제거함 | 소프트웨어 보안 약점과 관련된 시정 요구사항을 이행함 | . | 감리법인 감리 계획을 수립하고 협의함 | 소프트웨어 보안 약점의 제거 여부 및 조치 결과를 확인함 | . | . 3. 소프트웨어 개발 직무별 보안 활동 . 안전한 소프트웨어 개발을 위해서는 프로젝트 관련자들이 보안 활동을 수행할 수 있도록 직무별로 수행해야 할 보안 활동을 정의해야 함 | 프로젝트 관리자(Project Manager) 응용 프로그램에 대한 보안 전략을 조직 구성원들에게 전달함 | 조직 구성원들에게 응용 프로그램 보안 영향을 이해시킴 | . | 요구사항 분석가(Requirement Specifier) 아키텍트가 고려해야 할 보안 관련 비즈니스 요구사항을 설명함 | 프로젝트 팀이 고려해야 할 구조 정의 및 해당 구조에 존재하는 자원에 대한 요구사항을 정의함 | . | 아키텍트(Architect) 보안 오류가 발생하지 않도록 보안 기술 문제를 충분히 이해함 | 시스템에 사용되는 모든 리소스 정의 및 각 리소스별로 적절한 보안 요구사항을 적용함 | . | 설계자(Designer) 특정 기술에 대해 보안 요구사항의 만족성 여부를 확인함 | 문제 발생 시 최선의 문제 해결 방법을 결정함 | . | 구현 개발자(Implementer) 구조화된 소프트웨어 개발 환경에서 프로그램을 원활히 구현할 수 있도록 시큐어 코딩 표준을 준수하여 개발함 | . | 테스트 분석가(Test Analyst) 소프트웨어 개발 요구사항과 구현 결과를 반복적으로 확인함 | . | 보안 감시자(Security Auditor) 소프트웨어 개발 프로젝트의 현재 상태의 보안을 보장함 | 요구사항 검토 시 요구사항의 적합성과 완전성을 확인함 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/31/theory183.html",
            "relUrl": "/theory/2021/08/31/theory183.html",
            "date": " • Aug 31, 2021"
        }
        
    
  
    
        ,"post37": {
            "title": "SW 관련 신기술",
            "content": "1. SW 관련 신기술 . 인공지능(AI; Artificial Intelligence) 인간의 두뇌와 같이 컴퓨터 스스로 추론, 학습, 판단 등 인간지능적인 작업을 수행하는 시스템 | 인공지능의 응용 분야: 패턴 인식, 전문가 시스템, 로봇 공학 등 | . | 뉴럴링크(Neuralink) 미국의 전기자동차 회사 테슬라의 CEO 일론 머스크가 사람의 뇌와 컴퓨터를 결합하는 기술을 개발하기 위해 2017년 3월 설립한 회사 | 뉴럴링크가 개발하고 있는 기술은 ‘신경 레이스(Neural Lace)’로, 작은 전극을 뇌에 이식함으로써 생각을 업로드하고 다운로드하는 것을 목표로 삼고 있음 | . | 딥러닝(Deep Learning) 인간의 두뇌를 모델로 만들어진 인공 신경망(ANN; Artificial Neural Network)을 기반으로 하는 기계 학습 기술 | . | 전문가 시스템(Expert System) 의료 진단 등과 같은 특정 분야의 전문가가 수행하는 고도의 업무를 지원하기 위한 컴퓨터 응용 프로그램 | . | 증강현실(AR; Augmented Reality) 실제 촬영한 화면에 가상의 정보를 부가하여 보여주는 기술로, 혼합 현실(MR; Mixed Reality)이라고도 부름 | . | 블록체인(Blockchain) P2P 네트워크를 이용하여 온라인 금융 거래 정보를 온라인 네트워크 참여자의 디지털 장비에 분신 저장하는 기술 | . | 분산 원장 기술(DLT; Distributed Ledger Technology) 중앙 관리자나 중앙 데이터 저장소가 존재하지 않고 P2P 망 내의 참여자들에게 모든 거래 목록이 분산 저장되어 거래가 발생할 때마다 지속적으로 갱신되는 디지털 원장을 의미함 | . | 해시(Hash) 임의의 길이의 입력 데이터나 메시지를 고정된 길이의 값이나 키로 변환하는 것 | . | 양자 암호키 분배(QKD; Quantum Key Distribution) 양자 통신을 위해 비밀키를 분배하여 관리하는 기술 | 두 시스템이 암호 알고리즘 동작을 위한 비밀키를 안전하게 공유하기 위해 양자 암호키 분배 시스템을 설치하여 운용하는 방식으로 활용됨 | . | 프라이버시 강화 기술(PET; Privacy Enhancing Technology) 개인정보 침해 위험을 관리하기 위한 핵심 기술 | 암호화, 익명화 등 개인정보를 보호하는 기술에서 사용자가 직접 개인정보를 통제하기 위한 기술까지 다양한 사용자 프라이버시 보호 기술을 통칭함 | . | 공통 평가 기준(CC; Common Criteria) 1999년 6월 8일 ISO 15408 표준으로 채택된 정보 보호 제품 평가 기준 | 정보화 순기능 역할을 보장하기 위해 정보화 제품의 정보 보호 기능과 이에 대한 사용 환경 등급을 정한 기준 | . | 개인정보 영향평가 제도(PIA; Privacy Impact Assessment) 개인 정보를 활용하는 새로운 정보시스템의 도입 및 기존 정보시스템의 중요한 변경 시 시스템의 구축 운영이 기업의 고객은 물론 국민의 사생활에 미칠 영향에 대해 미리 조사.분석.평가하는 제도 | . | 그레이웨어(Grayware) 소프트웨어를 제공하는 입장에서는 악의적이지 않은 유용한 소프트웨어라고 주장할 수 있지만 사용자 입장에서는 유용할 수도 있고 악의적일 수도 있는 애드웨어, 트랙웨어, 기타 악성 코드나 악성 공유웨어를 말함 | . | 매시업(Mashup) 웹에서 제공하는 정보 및 서비스를 이용하여 새로운 소프트웨어나 서비스, 데이터베이스 등을 만드는 기술. 즉 다수의 정보원이 제공하는 콘텐츠를 조합하여 하나의 서비스로 제공하는 웹 사이트 또는 애플리케이션을 말함 | . | 리치 인터넷 애플리케이션(RIA; Rich Internet Application) 플래시 애니메이션 기술과 웹 서버 애플리케이션 기술을 통합하여 기존 HTML보다 역동적이고 인터랙티브한 웹 페이지를 제공하는 신개념의 플래시 웹 페이지 제작 기술 | . | 시맨틱 웹(Semantic Web) 컴퓨터가 사람을 대신하여 정보를 읽고 이해하고 가공하여 새로운 정보를 만들어 낼 수 있도록 이해하기 쉬운 의미를 가진 차세대 지능형 웹 | . | 증발품(Vaporware) 판매 계획 또는 배포 계획은 발표되었으나 실제로 고객에게 판매되거나 배포되지 않고 있는 소프트웨어 | . | 오픈 그리드 서비스 아키텍처(OGSA; Open Grid Service Architecture) 애플리케이션 공유를 위한 웹 서비스를 그리드 상에서 제공하기 위해 만든 개방형 표준 | . | 서비스 지향 아키텍처(SOA; Service Oriented Architecture) 기업의 소프트웨어 인프라인 정보시스템을 공유와 재사용이 가능한 서비스 단위나 컴포넌트 중심으로 구축하는 정보기술 아키텍처 | SOA 기반 애플리케이션 구성 계층 표현 계층 | 업무 프로세스 계층 | 서비스 중간 계층 | 애플리케이션 계층 | 데이터 저장 계층 | . | . | 서비스형 소프트웨어(SaaS; Software as a Service) 소프트웨어의 여러 기능 중에서 사용자가 필요로 하는 서비스만 이용할 수 있도록 한 소프트웨어 | . | 소프트웨어 에스크로(Software Escrow) 소프트웨어 개발자의 지식재산권을 보호하고 사용자는 저렴한 비용으로 소프트웨어를 안정적으로 사용 및 유지보수 할 수 있도록 소스 프로그램과 기술 정보 등을 제 3의 기관에 보관하는 것 | . | 복잡 이벤트 처리(CEP; Complex Event Processing) 실시간으로 발생하는 많은 사건들 중 의미가 있는 것만을 추출할 수 있도록 사건 발생 조건을 정의하는 데이터 처리 방법 | . | 디지털 트윈(Digital Twin) 현실속의 사물을 소프트웨어로 가상화한 모델 | 자동차, 항공, 에너지, 국방, 헬스케어 등 여러 분야에서 주목 받고 있음 | 실제 물리적인 자산을 소프트웨어로 가상화함으로써 실제 자산의 특성에 대한 정확한 정보를 얻을 수 있음 | 자산 최적화, 돌발사고 최소화, 생산성 증가 등 설계부터 제조, 서비스에 이르는 모든 과정의 효율성을 향상시킬 수 있음 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/31/theory182.html",
            "relUrl": "/theory/2021/08/31/theory182.html",
            "date": " • Aug 31, 2021"
        }
        
    
  
    
        ,"post38": {
            "title": "스위치",
            "content": "1. 스위치 분류 . 브리지와 같이 LAN과 LAN을 연결하여 훨씬 더 큰 LAN을 만드는 장치임 | 스위치는 OSI 7 계층의 Layer에 따라 L2, L3, L4, L7으로 분류됨 L2 스위치 OSI의 2계층에 속하는 장비임 | 일반적으로 부르는 스위치는 L2 스위치를 의미함 | MAC 주소를 기반으로 프레임을 전송함 | 동일 네트워크 간의 연결만 가능함 | . | L3 스위치 OSI의 3계층에 속하는 장비임 | L2 스위치에 라우터 기능이 추가된 것으로, IP 주소를 기반으로 패킷을 전송함 | 서로 다른 네트워크 간의 연결이 가능함 | . | L4 스위치 OSI 4계층에 속하는 장비임 | 로드밸런서가 달린 L3 스위치로, IP 주소 및 TCP/UDP를 기반으로 사용자들의 요구를 서버의 부하가 적은 곳에 배분하는 로드밸런싱 기능을 제공함 | . | L7 스위치 OSI 7계층에 속하는 장비임 | IP 주소, TCP/UDP 포트 정보에 패킷 내용까지 참조하여 세밀하게 로드밸런싱함 | . | . | . 2. 스위칭 방식 . Store and Forwarding 데이터를 모두 받은 후 스위칭하는 방식 | . | Cut-through 데이터의 목적지 주소만을 확인한 후 바로 스위칭하는 방식 | . | Fragment Free Store and Forwarding과 Cut-through 방식의 장점을 결합한 방식 | . | . 3. 백본 스위치(Backbone Switch) . 네트워크들을 연결할 때 중추적 역할을 하는 네트워크를 백본이라 하고, 백본에서 스위칭 역할을 하는 장비를 백본 스위치라고 함 | 백본 스위치는 모든 패킷이 지나가는 네트워크의 중심에 배치함 | 대규모 트래픽을 처리하려면 고성능의 백본 스위치를 사용해야 함 | 주로 L3 스위치가 백본 스위치의 역할을 함 | . 4. Hierarchical 3 Layer 모델 . 네트워크 구성 시 사용되는 모델의 한 종류로, 액세스 계층, 디스트리뷰션 계층, 코어 계층으로 나뉨 | 액세스 계층(Access Layer) 사용자가 네트워크에 접속할 때 최초로 연결되는 지점으로, 사용자들로부터 오는 통신을 집약해서 디스트리뷰션 계층으로 전송함 | 액세스 계층에 배치되는 장비는 성능은 낮아도 되지만 포트 수는 사용자수 만큼 있어야 함 | L2 스위치를 사용함 | . | 디스트리뷰션 계층(Distribution Layer) 액세스 계층의 장치들이 연결되는 지점으로, 액세스 계층에서 오는 통신을 집약해서 코어 계층으로 전송함 | LAN 간에 라우팅 기능을 수행함 | 라우터, L3 스위치를 사용함 | . | 코어 계층(Core Layer) 디스트리뷰션 계층에서 오는 통신을 집약해 인터넷에 연결하는 계층으로, 백본 계층이라고도 함 | 전자우편, 인터넷 접속, 화상 회의 등의 기능을 수행함 | 백본 스위치를 사용함 | . | . .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/30/theory180.html",
            "relUrl": "/theory/2021/08/30/theory180.html",
            "date": " • Aug 30, 2021"
        }
        
    
  
    
        ,"post39": {
            "title": "네트워크 구축",
            "content": "1. 네트워크(Network) . 두 대 이상의 컴퓨터를 전화선이나 케이블 등으로 연결하여 자원을 공유하는 것을 말함 | 네트워크는 다른 컴퓨터의 데이터, 프로그램, 주변장치, 인터넷 등을 공유하기 위해 사용함 | 네트워크 설치 구조는 장치들의 물리적 위치에 따라서 성형, 링형, 버스형, 계층형, 망형으로 나누어짐 | 네트워크는 사이트들이 분포되어 있는 지리적 범위에 따라 LAN과 WAN으로 분류됨 | . 2. 성형(Star, 중앙 집중형) . 중앙에 중앙 컴퓨터가 있고, 이를 중심으로 단말장치들이 연결되는 중앙 집중식의 네트워크 구성 형태임 | 포인트 투 포인트(Point-to-Point) 방식으로 회선을 연결함 | 단말장치의 추가와 제거가 쉬움 | 하나의 단말장치가 고장나더라도 다른 단말장치에는 영향을 주지 않지만, 중앙 컴퓨터가 고장나면 전체 통신망의 기능이 정지됨 | . . 3. 링형(Ring, 루프형) . 컴퓨터와 단말장치들을 서로 이웃하는 것끼리 연결시킨 포인트 투 포인트(Point-to-Point) 방식의 구성 형태임 | 단말장치의 추가/제거 및 기밀 보호가 어려움 | 각 단말장치에서 전송 징연이 발생할 수 있음 | 중계기의 수가 많아짐 | 데이터는 단방향 또는 양방향으로 전송할 수 있음 | . . 4. 버스형(Bus) . 한 개의 통신 회선에 여러 대의 단말장치가 연결되어 있는 형태임 | 단말장치의 추가와 제거가 용이함 | 단말장치가 고장나더라도 통신망 전체에 영향을 주지 않기 때문에 신뢰성을 높일 수 있음 | 기밀 보장이 어려움 | 통신 회선의 길이에 제한이 있음 | . . 5. 계층형(Tree, 분산형) . 중앙 컴퓨터와 일정 지역의 단말장치까지는 하나의 통신 회선으로 연결시키고, 이웃하는 단말장치는 일정 지역 내에 설치된 중간 단말장치로부터 다시 연결시키는 형태임 | 분산 처리 시스템을 구성하는 방식임 | . . 6. 망형(Mesh) . 모든 지점의 컴퓨터와 단말장치를 서로 연결한 형태로, 노드의 연결성이 높음 | 많은 단말장치로부터 많은 양의 통신을 필요로 하는 경우에 유리함 | 통신 회선의 총 경로가 가장 긺 | 통신 회선 장애 시 다른 경로를 통하여 데이터를 전송할 수 있음 | 모든 노드를 망형으로 연결하려면 노드의 수가 n개일 때, n(n-1)/2개의 회선이 필요하고 노드당 n-1개의 포트가 필요함 | 25개의 노드를 망형으로 연결하려고 할 때 필요한 회선의 수와 노드당 필요한 포트의 수는? | 회선 수 = n(n-1)/2 = 25(25-1)/2 = 600/2 = 300(개), 포트 수 = n-1 = 24(개) | . . 7. 네트워크의 분류 . 근거리 통신망(LAN; Local Area Network) 회사, 학교, 연구소 등에서 비교적 가까운 거리에 있는 컴퓨터, 프린터, 저장장치 등과 같은 자원을 연결하여 구성함 | 주로 자원 공유를 목적으로 사용함 | 사이트 간의 거리가 짧아 데이터의 전송 속도가 빠르고, 에러 발생률이 낮음 | 주로 버스형이나 링형 구조를 사용함 | . | 광대역 통신망(WAN; Wide Area Network) 국가와 국가 혹은 대륙과 대륙 등과 같이 멀리 떨어진 사이트들을 연결하여 구성함 | 사이트 간의 거리가 멀기 때문에 통신 속도가 느리고, 에러 발생률이 높음 | 일정한 지역에 있는 사이트들을 근거리 통신망으로 연결한 후 각 근거리 통신망을 연결하는 방식을 사용함 | . | . 8. LAN의 표준안 . IEEE 802의 주요 표준 규격 802.1: 전체의 구성, OSI 참조 모델과의 관계, 통신망 관리 등에 관한 규약 | 802.2: 논리 링크 제어(LLC) 계층에 관한 규약 | 802.3: CSMA/CD 방식의 매체 접근 제어 계층에 관한 규약 | 802.4: 토큰 버스 방식의 매체 접근 제어 계층에 관한 규약 | 802.5: 토큰 링 방식의 매체 접근 제어 계층에 관한 규약 | 802.6: 도시형 통신망(MAN)에 관한 규약 | 802.9: 종합 음성/데이터 네트워크에 관한 규약 | 802.11: 무선 LAN에 관한 규약 | . | 802.11의 버전 802.11(초기 버전): 2.4GHz 대역 전파와 CSMA/CA 기술을 사용해 최고 2Mbps까지의 전송 속도를 지원함 | 802.11a: 5GHz 대역의 전파를 사용하며, OFDM 기술을 사용해 최고 54Mbps까지의 전송 속도를 지원함 | 802.11b: 802.11 초기 버전의 개선안으로 등장하였으며, 초기 버전의 대역 전파와 기술을 사용해 최고 11Mbps의 전송 속도로 기존에 비해 5배 이상 빠르게 개선되었음 | 802.11e: 802.11의 부가 기능 표준으로, QoS 기능이 지원되도록 하기 위해 매체 접근 제어(MAC) 계층에 해당하는 부분을 수정하였음 | 802.11g: 2.4GHz 대역의 전파를 사용하지만 5GHz 대역의 전파를 사용하는 802.11a와 동일한 최고 54Mbps까지의 전송 속도를 지원함 | 802.11n: 2.4GHz 대역과 5GHz 대역을 사용하는 규격으로, 최고 600Mbps까지의 전송 속도를 지원함 | . | . 9. NAT(Network Address Translation, 네트워크 주소 변환) . 한 개의 정식 IP 주소에 대량의 가상 사설 IP 주소를 할당 및 연결하는 기능임 | 한 개의 IP 주소를 사용해서 외부에 접속할 수 있는 노드는 어느 시점에서 한 개로 제한되는 문제가 있지만 IP 마스커레이드를 이용하여 해결할 수 있음 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/28/theory179.html",
            "relUrl": "/theory/2021/08/28/theory179.html",
            "date": " • Aug 28, 2021"
        }
        
    
  
    
        ,"post40": {
            "title": "네트워크 관련 신기술",
            "content": "1. 네트워크 관련 신기술 . IoT(Internet of Things, 사물 인터넷) 정보 통신 기술을 기반으로 실세계(Physical World)와 가상 세계(Virtual World)의 다양한 사물들을 인터넷으로 서로 연결하여 진보된 서비스를 제공하기 위한 서비스 기반 기술 | . | M2M(Machine to Machine, 사물 통신) 무선 통신을 이용한 기계와 기계 사이의 통신 | 변압기 원격 감시, 전기, 가스 등의 원격 검침, 무선 사용 카드 조회기, 무선 보안단말기, 버스 운행 시스템, 위치 추적 시스템, 시설물 관리 등을 무선으로 통합하여 상호작용하는 통신 | . | 모바일 컴퓨팅(Mobile Computing) 휴대형 기기로 이동하면서 자유로이 네트워크에 접속하여 업무를 처리할 수 있는 환경 | . | 클라우드 컴퓨팅(Cloud Computing) 각종 컴퓨팅 자원을 중앙 컴퓨터에 두고 인터넷 기능을 갖는 단말기로 언제 어디서나 인터넷을 통해 컴퓨터 작업을 수행할 수 있는 가상화된 환경 | . | 그리드 컴퓨팅(Grid Computing) 지리적으로 분산되어 있는 컴퓨터를 초고속 인터넷망으로 연결하여 공유함으로써 하나의 고성능 컴퓨터처럼 활용하는 기술 | . | 모바일 클라우드 컴퓨팅(MCC; Mobile Cloud Computing) 소비자와 소비자의 파트너가 클라우드 서비스를 이용하여 모바일 기기로 클라우드 컴퓨팅 인프라를 구성하여 여러 가지 정보와 자원을 공유하는 ICT 기술 | . | 인터클라우드 컴퓨팅(Inter-Cloud Computing) 각기 다른 클라우드 서비스를 연동하거나 컴퓨팅 자원의 동적 할당이 가능하도록 여러 클라우드 서비스 제공자들이 제공하는 클라우드 서비스나 자원을 연결하는 기술 | . | 메시 네트워크(Mesh Network) 차세대 이동통신, 홈네트워킹, 공공 안전 등 특수 목적을 위한 새로운 방식의 네트워크 기술 | 대규모 디바이스의 네트워크 생성에 최적화되어 있음 | . | 와이선(Wi-SUN) 스마트 그리드와 같은 장거리 무선 통신을 필요로 하는 사물 인터넷(IoT) 서비스를 위한 저전력 장거리(LPWA; Low-Power Wide Area) 통신 기술 | . | NDN(Named Data Networking) 콘텐츠 자제의 정보와 라우터 기능만으로 데이터 전송을 수행하는 기술 | 클라이언트와 서버가 패킷의 헤더에 내장되어 있는 주소 정보를 이용하여 연결되던 기존의 IP(Internet Protocol)망을 대체할 새로운 인터넷 아키텍처로 떠오르고 있음 | . | NGN(Next Generation Network, 차세대 통신망) ITU-T에서 개발하고 있는 유선망 기반의 차세대 통신망 | 유선망뿐만 아니라 이동 사용자를 목표로 하며, 이동통신에서 제공하는 완전한 이동성 제공을 목표로 개발되고 있음 | . | SDN(Software Defined Networking, 소프트웨어 정의 네트워킹) 네트워크를 컴퓨터처럼 모델링하여 여러 사용자가 각각의 소프트웨어로 네트워킹을 가상화하여 제어하고 관리하는 네트워크 | . | NFC(Near Field Communication, 근거리 무선 통신) 고주파(HF)를 이용한 근거리 무선 통신 기술 | 아주 가까운 거리에서 양방향 통신을 지원하는 RFID 기술의 일종임 | . | UWB(Ultra WideBand, 초광대역) 짧은 거리에서 많은 양의 디지털 데이터를 낮은 전력으로 전송하기 위한 무선 기술로 무선 디지털 펄스라고도 함 | 0.5m/W 정도의 저전력으로 많은 양의 데이터를 1km의 거리까지 전송할 수 있을 뿐만 아니라, 땅속이나 벽면 뒤로도 전송이 가능함 | . | 피코넷(PICONET) 여러 개의 독립된 통신장치가 블루투스 기술이나 UWB 통신 기술을 사용하여 통신망을 형성하는 무선 네트워크 기술 | . | WBAN(Wireless Body Area Network) 웨어러블 또는 몸에 심는 형태의 센서나 기기를 무선으로 연결하는 개인 영역 네트워킹 기술 | . | GIS(Geographic Information System, 지리 정보 시스템) 지리적인 자료를 수집.저장.분석.출력할 수 있는 컴퓨터 응용 시스템 | 위성을 이용해 모든 사물의 위치 정보를 제공해 줌 | . | USN(Ubiquitous Sensor Network, 유비쿼터스 센서 네트워크) 각종 센서로 수집한 정보를 무선으로 수집할 수 있도록 구성한 네트워크 | 필요한 모든 것에 RFID 태그를 부착하고, 이를 통하여 사물의 인식정보는 물론 주변의 환경정보까지 탐지하여 이를 네트워크에 연결하여 정보를 관리함 | . | SON(Self Organizing Network, 자동 구성 네트워크) 주변 상황에 맞추어 스스로 망을 구성하는 네트워크 | SON의 목적은 통신망 커버리지 및 전송 용량 확장의 경제성 문제를 해결하고, 망의 운영과 관리의 효율성을 높이는 것임 | . | 애드 혹 네트워크(Ad-hoc Network) 재난 현장과 같이 별도의 고정된 유선망을 구축할 수 없는 장소에서 모바일 호스트만을 이용하여 구성한 네트워크 | 망을 구성한 후 단기간 사용되는 경우나 유선망을 구성하기 어려운 경우에 적합함 | . | 네트워크 슬라이싱(Network Slicing) 네트워크에서 하나의 물리적인 코어 네트워크 인프라를 독립된 다수의 가상 네트워크로 분리하여 각각의 네트워크를 통해 다양한 고객 맞춤형 서비스를 제공하는 것을 목적으로 하는 네트워크 기술 | 3GPP를 포함한 여러 글로벌 이동통신 표준화 단체가 선정한 5G(IMT-2020)의 핵심기술 중 하나임 | . | 저전력 블루투스 기술(BLE; Bluetooth Low Energy) 일반 블루투스와 동일한 2.4GHz 주파수 대역을 사용하지만 연결되지 않은 대기 상태에서는 절전모드를 유지하는 기술 | . | 지능형 초연결망 스마트 시티, 스마트 스테이션 등 4차 산업혁명 시대를 맞아 새로운 변화에 따라 급격하게 증가하는 데이터 트래픽을 효과적으로 수용하기 위해 시행되는 과학기술정보통신부 주관 사업임 | . | 파장 분할 다중화(WDM, Wavelength Division Multiplexing) 광섬유를 이용한 통신기술의 하나로, 파장이 서로 다른 복수의 신호를 보냄으로써 여러 대의 단말기가 동시에 통신 회선을 사용할 수 있도록 하는 것 | 파장이 다른 광선끼리는 서로 간섭을 일으키지 않는 성질을 이용한 기술임 | . | 소프트웨어 정의 데이터 센터(SDDC, Software Defined Data Center) 데이터 센터의 모든 자원을 가상화하여 인력의 개입없이 소프트웨어 조작만으로 관리 및 제어되는 데이터 센터를 의미함 | 컴퓨팅, 네트워킹, 스토리지, 관리 등을 모두 소프트웨어로 정의함 | 다양한 소프트웨어 정의 기술이 사용됨 | . | 개방형 링크드 데이터(LOD, Linked Open Data) Linked Data와 Open Data의 합성어로, 누구나 사용할 수 있도록 웹상에 공개된 연계 데이터를 의미함 | 웹상에 존재하는 데이터를 개별 URI(인터넷 식별자)로 식별하고, 각 URI에 링크 정보를 부여함으로써 상호 연결된 웹을 지향하는 모형임 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/28/theory178.html",
            "relUrl": "/theory/2021/08/28/theory178.html",
            "date": " • Aug 28, 2021"
        }
        
    
  
    
        ,"post41": {
            "title": "TCP/IP",
            "content": "1. 프로토콜 . 서로 다른 기기들 간의 데이터 교환을 원활하게 수행할 수 있도록 표준화시켜 놓은 통신 규약임 | 프로토콜의 기본 요소 구문(Syntax): 전송하고자 하는 데이터의 형식, 부호화, 신호 레벨 등을 규정함 | 의미(Semantics): 두 기기 간의 효율적이고 정확한 정보 전송을 위한 협조 사항과 오류 관리를 위한 제어 정보를 규정함 | 시간(Timing): 두 기기 간의 통신 속도, 메시지의 순서 제어 등을 규정함 | . | 프로토콜의 기능: 단편화와 재결합, 캡슐화, 흐름 제어, 오류 제어, 동기화, 순서 제어, 주소 지정, 다중화, 경로 제어, 전송 서비스 등 | . 2. TCP/IP(Transmission Control Protocol/Internet Protocol) . 인터넷에 연결된 서로 다른 기종의 컴퓨터들이 데이터를 주고받을 수 있도록 하는 표준 프로토콜임 | TCP OSI 7계층의 전송 계층에 해당함 | 신뢰성 있는 연결형 서비스를 제공함 | 패킷의 다중화, 순서 제어, 오류 제어, 흐름 제어 기능을 제공함 | . | IP OSI 7계층의 네트워크 계층에 해당함 | 데이터그램을 기반으로 하는 비연결형 서비스를 제공함 | 패킷의 분해/조립, 주소 지정, 경로 선택 기능을 제공함 | . | . 3. TCP/IP의 구조 . OSI TCP/IP 기능 . 응용 계층표현 계층세션 계층 | 응용 계층 | - 응용 프로그램 간의 데이터 송.수신 제공- TELNET, FTP, SMTP, SNMP, DNS, HTTP 등 | . 전송 게층 | 전송 계층 | - 호스트들 간의 신뢰성 있는 통신 제공- TCP, UDP, RTCP | . 네트워크 계층 | 인터넷 계층 | - 데이터 전송을 위한 주소 지정, 경로 설정을 제공함- IP, ICMP, IGMP, ARP, RARP | . 대이터 링크 계층물리 계층 | 네트워크 액세스 계층 | - 실제 데이터(프레임)를 송.수신하는 역할- Ethernet, IEEE 802, HDLC, X.25, RS-232C, ARQ 등 | . 4. 응용 계층의 주요 프로토콜 . FTP(File Transfer Protocol) 컴퓨터와 컴퓨터 또는 컴퓨터와 인터넷 사이에서 파일을 주고받을 수 있도록 하는 원격 파일 전송 프로토콜 | . | SMTP(Simple Mail Transfer Protocol) 전자 우편을 교환하는 서비스 | . | TELNET 멀리 떨어져 있는 컴퓨터에 접속하여 자신의 컴퓨터처럼 사용할 수 있도록 해주는 서비스 | 프로그램을 실행하는 등 시스템 관리 작업을 할 수 있는 가상의 터미널 기능을 수행함 | . | SNMP(Simple Network Management Protocol) TCP/IP의 네트워크 관리 프로토콜로, 라우터나 허브 등 네트워크 기기의 네트워크 정보를 네트워크 관리 시스템에 보내는데 사용되는 표준 통신 규약 | . | DNS(Domain Name System) 도메인 네임을 IP 주소로 매핑하는 시스템 | . | HTTP(HyperText Transfer Protocol) 월드 와이드 웹(WWW)에서 HTML 문서를 송수신하기 위한 표준 프로토콜 | . | . 5. 전송 계층의 주요 프로토콜 . TCP(Transmission Control Protocol) 양방향 연결(Full Duplex Connection)형 서비스를 제공함 | 가상 회선 연결(Virtual Circuit Connection) 형태의 서비스를 제공함 | 스트림 위주의 전달(패킷 단위)을 함 | 신뢰성 있는 경로를 확립하고 메시지 전송을 감독함 | 순서 제어, 오류 제어, 흐름 제어 기능을 함 | 패킷의 분실, 손상, 지연이나 순서가 틀린 것 등이 발생할 때 투명성이 보장되는 통신을 제공함 | TCP 프로토콜의 헤더는 기본적으로 20Byte에서 60Byte까지 사용할 수 있는데, 선택적으로 40Byte를 더 추가할 수 있으므로 최대 100Byte까지 크기를 확장할 수 있음 | . | UDP(User Datagram Protocol) 데이터 전송 전에 연결을 설정하지 않는 비연결형 서비스를 제공함 | TCP에 비해 상대적으로 단순한 헤더 구조를 가지므로, 오버헤드가 적고, 흐름 제어나 순서 제어가 없어 전송 속도가 빠름 | 고속의 안정성 있는 전송 매체를 사용하여 빠른 속도를 필요로 하는 경우, 동시에 여러 사용자에게 데이터를 전달할 경우, 정기적으로 반복해서 전송할 경우에 사용함 | 실시간 전송에 유리하며, 신뢰성보다는 속도가 중요시되는 네트워크에서 사용됨 | UDP 헤더에는 Source Port Number, Destination Port Number, Length, Checksum 등이 포함됨 | . | RTCP(Real-Time Control Protocol) RTP(Real-time Transport Protocol) 패킷의 전송 품질을 제어하기 위한 제어 프로토콜 | 세션에 참여한 각 참여자들에게 주기적으로 제어 정보를 전송함 | 하위 프로토콜은 데이터 패킷과 제어 패킷의 다중화를 제공함 | 데이터 전송을 모니터링하고 최소한의 제어와 인증 기능만을 제공함 | RTCP 패킷은 항상 32비트의 경계로 끝남 | . | . 6. 인터넷 계층의 주요 프로토콜 . IP(Internet Protocol) 전송할 데이터에 주소를 지정하고, 경로를 설정하는 기능을 함 | 비연결형인 데이터그램 방식을 사용하는 것으로 신뢰성이 보장되지 않음 | . | ICMP(Internet Control Message Protocol, 인터넷 제어 메시지 프로토콜) IP와 조합하여 통신중에 발생하는 오류의 처리와 전송 경로 변경 등을 위한 제어 메시지를 관리하는 역할을 함 | 헤더는 8Byte로 구성됨 | . | IGMP(Internet Group Management Protocol, 인터넷 그룹 관리 프로토콜) 멀티캐스트를 지원하는 호스트나 라우터 사이에서 멀티캐스트 그룹 유지를 위해 사용됨 | . | ARP(Address Resolution Protocol, 주소 분석 프로토콜) 호스트의 IP 주소를 호스트와 연결된 네트워크 접속 장치의 물리적 주소(MAC Address)로 바꿈 | . | RARP(Reverse Address Resolution Protocol) ARP와 반대로 물리적 주소를 IP 주소로 변환하는 기능을 함 | . | . 7. 네트워크 액세스 계층의 주요 프로토콜 . Ethernet(IEEE 802.3) CSMA/CD 방식의 LAN | . | IEEE 802 LAN을 위한 표준 프로토콜 | . | HDLC 비트 위주의 데이터 링크 제어 프로토콜 | . | X.25 패킷 교환망을 통한 DTE와 DCE 간의 인터페이스를 제공하는 프로토콜 | . | RS-232C 공중 전화 교환망(PSTN)을 통한 DTE와 DCE 간의 인터페이스를 제공하는 프로토콜 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/27/theory177.html",
            "relUrl": "/theory/2021/08/27/theory177.html",
            "date": " • Aug 27, 2021"
        }
        
    
  
    
        ,"post42": {
            "title": "네트워크 관련 장비",
            "content": "1. 네트워크 인터페이스 카드(NIC) . 컴퓨터와 컴퓨터 또는 컴퓨터와 네트워크를 연결하는 장치임 | 정보 전송 시 정보가 케이블을 통해 전송될 수 있도록 정보 형태를 변경함 | 이더넷 카드(LAN 카드) 혹은 네트워크 어댑터라고도 함 | . 2. 허브 . 한 사무실이나 가까운 거리의 컴퓨터들을 연결하는 장치로, 각각의 회선을 통합하여 관리함 | 허브는 신호 중복 기능을 하는 리피터의 역할을 포함함 | 허브 종류 더미 허브: 네트워크에 흐르는 모든 데이터를 단순히 연결하는 기능만 제공하는 허브 | 스위칭 허브: 네트워크상에 흐르는 데이터의 유무 및 흐름을 제어하여 각각의 노드가 허브의 최대 대역폭을 사용할 수 있는 지능형 허브 | . | . 3. 리피터 . 거리가 증가할수록 감쇠하는 디지털 신호의 장거리 전송을 위해 수신한 신호를 재생시키거나 출력 전압을 높여 전송하는 장치임 | OSI 참조 모델의 물리 계층에서 동작하는 장비임 | 전송 거리의 연장 또는 배선의 자유도를 높이기 위한 용도로 사용됨 | . 4. 브리지 . LAN과 LAN을 연결하거나 LAN 안에서의 컴퓨터 그룹을 연결하는 장치임 | 네트워크의 수많은 단말기들에 의해 발생되는 트래픽 병목 현상을 줄일 수 있음 | 네트워크를 분산적으로 구성할 수 있어 보안성을 높일 수 있음 | 브리지를 이용한 서브넷 구성 시 전송 가능한 회선 수는 브리지가 n개일 때, n(n-1)/2개임 | . 5. 스위치 . 브리지와 같이 LAN과 LAN을 연결하여 훨씬 더 큰 LAN을 만드는 장치임 | 하드웨어를 기반으로 처리하므로 전송 속도가 빠름 | 포트마다 서로 다른 전송 속도를 지원하게 제어할 수 있음 | 수십에서 수백 개의 포트를 제공함 | OSI 참조 모델의 데이터 링크 계층에서 사용됨 | . 6. 라우터 . 브리지와 같이 LAN과 LAN의 연결 기능에 데이터 전송의 최적 경로를 선택하는 기능이 추가된 장치임 | 서로 다른 LAN 또는 LAN과 WAN을 연결하는 기능도 함 | OSI 참조 모델의 네트워크 계층에서 동작하는 장비임 | 3계층, 즉 네트워크 계층까지의 프로토콜 구조가 다른 네트워크 간의 연결을 위해 프로토콜 변환 기능을 수행함 | . 7. 게이트웨이 . OSI 전 계층의 프로토콜 구조가 다른 네트워크를 연결하는 장치임 | LAN에서 다른 네트워크에 데이터를 보내거나 다른 네트워크로부터 데이터를 받아들이는 출입구 역할을 함 | 세션 계층, 표현 계층, 응용 계층 간을 연결하여 데이터 형식 변환, 주소 변환, 프로토콜 변환 등을 수행함 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/25/theory176.html",
            "relUrl": "/theory/2021/08/25/theory176.html",
            "date": " • Aug 25, 2021"
        }
        
    
  
    
        ,"post43": {
            "title": "OSI 참조 모델",
            "content": "1. OSI(Open System Interconnection) 참조 모델 . 다른 시스템 간의 원활한 통신을 위해 ISO(국제표준화기구)에서 제안한 통신 규약(Protocol)임 | OSI 7계층은 1~3 계층을 하위 계층, 4~7 계층을 상위 계층이라고 함 하위 계층: 물리 계층 -&gt; 데이터 링크 계층 -&gt; 네트워크 계층 | 상위 계층: 전송 계층 -&gt; 세션 계층 -&gt; 표현 계층 -&gt; 응용 계층 | . | . 2. 물리 계층 . 전송에 필요한 두 장치 간의 실제 접속과 절단 등 기계적, 전기적, 기능적, 절차적 특성에 대한 규칙을 정의함 | 물리적 전송 매체와 전송 신호 방식을 정의함 | RS-232C, X.21 등의 표준이 있음 | 관련 장비: 리피터, 허브 | . 3. 데이터 링크 계층 . 두 개의 인접한 개방 시스템들 간에 신뢰성 있고 효율적인 정보 전송을 할 수 있도록 시스템 간 연결 설정과 유지 및 종료를 담당함 | 송신 측과 수신 측의 속도 차이 해결을 위한 흐름 제어 기능을 함 | 프레임의 시작과 끝을 구분하기 위한 프레임의 동기화 기능을 함 | 오류의 검출과 회복을 위한 오류 제어 기능을 함 | 프레임의 순서적 전송을 위한 순서 제어 기능을 함 | HDLC, LAPB, LLC, MAC, LAPD, PPP 등의 표준이 있음 | 관련 장비: 랜카드, 브리지, 스위치 | . 4. 네트워크 계층 . 개방 시스템들 간의 네트워크 연결을 관리하는 기능과 데이터의 교환 및 중계 기능을 함 | 네트워크 연결을 설정, 유지, 해제하는 기능을 함 | 경로 설정(Routing), 데이터 교환 및 중계, 트래픽 제어, 패킷 정보 전송을 수행함 | X.25, IP 등의 표준이 있음 | 관련 장비: 라우터 | . 5. 전송 계층 . 논리적 안정과 균일한 데이터 전송 서비스를 제공함으로써 종단 시스템 간에 투명한 데이터 전송을 가능하게 함 | OSI 7계층 중 하위 3계층과 상위 3계층의 인터페이스를 담당함 | 종단 시스템 간의 전송 연결 설정, 데이터 전송, 연결 해제 기능을 함 | 주소 설정, 다중화(분할 및 재조립), 오류 제어, 흐름 제어를 수행함 | TCP, UDP 등의 표준이 있음 | 관련 장비: 게이트웨이 | . 6. 세션 계층 . 송.수신 측 간의 관련성을 유지하고 대화 제어를 담당함 | 대화(회화) 구성 및 동기 제어, 데이터 교환 관리 기능을 함 | 동기점은 오류가 있는 데이터의 회복을 위해 사용하는 것으로, 종류에는 소동기점과 대동기점이 있음 | . 7. 표현 계층 . 응용 계층으로부터 받은 데이터를 세션 계층에 보내기 전에 통신에 적당한 형태로 변환하고, 세션 게층에서 받은 데이터는 응용 계층에 맞게 변환하는 기능을 함 | 서로 다른 데이터 표현 형태를 갖는 시스템 간의 상호 접속을 위해 필요한 계층임 | 코드 변환, 데이터 암호화, 데이터 압축, 구문 검색, 정보 형식(포맷) 변환, 문맥관리 기능을 함 | . 8. 응용 계층 . 사용자(응용 프로그램)가 OSI 환경에 접근할 수 있도록 서비스를 제공함 | 응용 프로세스 간의 정보 교환, 전자 사서함, 파일 전송, 가상 터미널 등의 서비스를 제공함 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/24/theory175.html",
            "relUrl": "/theory/2021/08/24/theory175.html",
            "date": " • Aug 24, 2021"
        }
        
    
  
    
        ,"post44": {
            "title": "인터넷",
            "content": "1. 인터넷 . TCP/IP 프로토콜을 기반으로 하여 전 세계 수많은 컴퓨터와 네트워크들이 연결된 광범위한 컴퓨터 통신망임 | 인터넷에 연결된 모든 컴퓨터는 고유한 IP 주소를 가짐 | . 2. IP 주소(Internet Protocol Address) . 인터넷에 연결된 모든 컴퓨터 자원을 구분하기 위한 고유한 주소임 | 8비트의 4부분, 총 32비트로 구성되어 있음 | IP 주소는 네트워크 부분의 길이에 따라 다음과 같이 A 클래스에서 E 클래스까지 총 5단계로 구성되어 있음 | A Class 국가나 대형 통신망에 사용(0~127로 시작) | 2^24 = 16,777,216개의 호스트 사용 가능 | | . | B Class 중대형 통신망에 사용(128~191로 시작) | 2^16 = 65,536개의 호스트 사용 가능 | | . | C Class 소규모 통신망에 사용(192~223으로 시작) | 2^8 = 256개의 호스트 사용 가능 | | . | D Class 멀티캐스트 용으로 사용(224~239로 시작) | | . | E Class 실험적 주소이며 공용되지 않음 | | . | . 3. 서브네팅 . 할당된 네트워크 주소를 다시 여러 개의 작은 네트워크로 나누어 사용하는 것을 말함 . | 4바이트의 IP 주소 중 네트워크 주소와 호스트 주소를 구분하기 위한 비트를 서브넷 마스크라고 하며, 이를 변경하여 네트워크 주소를 여러 개로 분할하여 사용함 . | 서브넷 마스크는 각 클래스마다 다르게 사용됨 . | 서브네팅의 예 . 192.168.1.0/24 네트워크를 FLSM 방식을 이용하여 3개의 Subnet으로 나누시오. (단 IP Subnet-Zero를 적용했음) . | 192.168.1.0/24 네트워크의 서브넷 마스크는 1의 개수가 24개, 즉 C 클래스에 속하는 네트워크임 . | 11111111 11111111 11111111 00000000 255 255 255 0 . | 서브넷 마스크를 Subnet으로 나눌 때는 서브넷 마스크가 0인 부분, 즉 마지막 8비트를 이용하면 됨. Subnet으로 나눌 때 “3개의 Subnet으로 나눈다”는 것처럼 네트워크가 기준일 때는 왼쪽을 기준으로 나눌 네트워크 수에 필요한 비트를 할당하고 나머지 비트로 호스트를 구성하면 됨. 3개의 Subnet으로 구성하라 했으니 8비트 중 3을 표현하는데 필요한 2비트를 제외하고 나머지 6비트를 호스트로 구성하면 됨 . | 11111111 11111111 11111111 11(네트워크 ID) 000000(호스트 ID) 255 255 255 192 . | 호스트 ID가 6Bit로 설정되었고, 문제에서 FLSM(Fixed Length Subnet Mask), 즉 고정된 크기로 주소를 할당하라고 했으므로 3개의 네트워크에 64개(2^6)씩 고정된 크기로 할당하면 다음과 같음 . | 네트워크(id) 호스트 수 IP 주소 범위 . 1(00) | 64 | 192.168.1.0(00000000)~63(00111111) | . 2(01) | 64 | 192.168.1.64(01000000)~127(01111111) | . 3(10) | 64 | 192.168.1.128(10000000)~191(10111111) | . | . | . 4. IPv6(Internet Protocol version 6) . IPv6은 현재 사용하고 있는 IP 주소 체계인 IPv4의 주소 부족 문제를 해결하기 위해 개발되었음 | 128비트의 긴 주소를 사용하여 주소 부족 문제를 해결할 수 있음 | IPv4에 비해 자료 전송 속도가 빠름 | 인증성, 기밀성, 데이터 무결성의 지원으로 보안 문제를 해결할 수 있음 | 주소의 확장성, 융통성, 연동성이 뛰어남 | 실시간 흐름 제어로 향상된 멀티미디어 기능을 지원함 | 패킷 크기를 확장할 수 있으므로 패킷 크기에 제한이 없음 | 기본 헤더 뒤에 확장 헤더를 더함으로써 더욱 다양한 정보의 저장이 가능해져 네트워크 기능 확장이 용이함 | IPv4와 호환성이 뛰어남 | . 5. IPv6의 구성 . 16비트씩 8부분, 총 128비트로 구성되어 있음 | 각 부분을 16진수로 표현하고, 콜론(:)으로 구분함 | IPv6은 다음과 같이 세 가지 주소 체계로 나누어짐 | 유니캐스트 단일 송신자와 단일 수신자 간의 통신(1대 1 통신에 사용) | . | 멀티캐스트 단일 송신자와 다중 수신자 간의 통신(1대 다 통신에 사용) | . | 애니캐스트 단일 송신자와 가장 가까이 있는 단일 수신자 간의 통신(1대 1 통신에 사용) | . | . 6. 도메인 네임 . 숫자로 된 IP 주소를 사람이 이해하기 쉬운 문자 형태로 표현한 것임 | 호스트 컴퓨터 이름, 소속 기관 이름, 소속 기관의 종류, 소속 국가명 순으로 구성되며, 왼쪽에서 오른쪽으로 갈수록 상위 도메일을 의미함 | 문자로 된 도메인 네임을 컴퓨터가 이해할 수 있는 IP 주소로 변환하는 역할을 하는 시스템을 DNS(Domain Name System)라고 하며 이런 역할을 하는 서버를 DNS 서버라고 함 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/24/theory174.html",
            "relUrl": "/theory/2021/08/24/theory174.html",
            "date": " • Aug 24, 2021"
        }
        
    
  
    
        ,"post45": {
            "title": "운영체제 기본 명령어",
            "content": "1. Windows 기본 명령어 . DIR 현재 디렉터리의 파일 목록을 표시함 | dir -&gt; 현재 디렉터리의 파일 목록을 표시함 | . | COPY 파일을 복사함 | copy abc.txt gilbut -&gt; abc.txt 파일을 gilbut 디렉터리로 복사함 | . | DEL 파일을 삭제함 | del abc.txt -&gt; abc.txt 파일을 삭제함 | . | TYPE 파일의 내용을 표시함 | type abc.txt -&gt; abc.txt 파일의 내용을 표시함 | . | REN 파일의 이름을 변경함 | ren abc.txt 123.txt -&gt; abc.txt 파일의 이름을 123.txt로 변경함 | . | MD 디렉터리를 생성함 | md gilbut -&gt; gilbut 디렉터리를 생성함 | . | CD 동일한 드라이브에서 디렉터리의 위치를 변경함 | cd gilbut -&gt; 디렉터리의 위치를 gilbut으로 변경함 | . | CLS 화면의 내용을 지움 | cls -&gt; 화면에 표시되어 있는 모든 내용을 지움 | . | ATTRIB 파일의 속성을 변경함 | attrib +r abc.txt -&gt; abc.txt 파일 속성을 읽기 전용으로 변경함 | . | FIND 파일에서 문자열을 찾음 | find “123” abc.txt -&gt; abc.txt에서 “123”이 포함된 문자열을 찾음 | . | CHKDSK 디스크 상태를 점검함 | chkdsk -&gt; 현재 드라이브 상태를 점검함 | . | FORMAT 디스크 표면을 트랙과 섹터로 나누어 초기화함 | format c: -&gt; c 드라이브를 초기화함 | . | MOVE 파일을 이동함 | move abc.txt gilbut -&gt; abc.txt 파일을 gilbut 디렉터리로 이동함 | . | . 2. UNIX/LINUX 기본 명령어 . cat 파일 내용을 화면에 표시함 | cat abc.txt -&gt; abc.txt 파일 내용을 화면에 표시함 | . | cd 디렉터리의 위치를 변경함 | cd gilbut -&gt; gilbut 디렉터리로 이동함 | . | chmod 파일의 보호 모드를 설정하여 파일의 사용 허가를 지정함 | chmod u=rwx abc.txt -&gt; user(u)에게 abc.txt 파일의 읽기(r), 쓰기(w), 실행(x) 권한을 부여(=)함 | . | chown 파일 소유자와 그룹을 변경함 | chown member1 abc.txt -&gt; abc.txt 파일의 소유자를 member1로 변경함 | . | cp 파일을 복사함 | cp abc.txt gilbut/abc2.txt -&gt; abc.txt 파일을 gilbut 디렉터리에 abc2.txt로 이름을 변경하여 복사함 | . | rm 파일을 삭제함 | rm abc.txt -&gt; abc.txt 파일을 삭제함 | . | find 파일을 찾음 | find abc.txt -&gt; abc.txt 파일을 찾음 | . | lsck 파일 시스템을 검사하고 보수함 | lsck /dev/sda1 -&gt; /dev/sda1에 기록된 모든 파일 시스템을 검사하고 보수함 | . | kill PID(프로세스 고유 번호)를 이용하여 프로세스를 종료함 | kill 1234 -&gt; PID가 1234인 프로세스를 종료함 | . | fork 새로운 프로세스를 생성함 | fork() -&gt; 새로운 프로세스를 종료함 | . | killall 프로세스의 이름을 이용하여 프로세스를 종료함 | killall gilbut -&gt; 프로세스 이름이 gilbut인 모든 프로세스를 종료함 | . | ls 현재 디렉터리의 파일 목록을 표시함 | ls -&gt; 현재 디렉터리의 파일 목록을 표시함 | . | mkdir 디렉터리를 생성함 | mkdir gilbut -&gt; gilbut 디렉터리를 생성함 | . | rmdir 디렉터리를 삭제함 | rmdir gilbut -&gt; gilbut 디렉터리를 삭제함 | . | mv 파일을 이동함 | mv abc.txt gilbut/abc2.txt -&gt; abc.txt 파일을 gilbut 디렉터리에 abc2.txt로 이름을 변경하여 이동함 | . | ps ps -&gt; 현재 실행중인 프로세스를 표시함 | . | pwd pwd -&gt; 현재 작업중인 디렉터리 경로를 화면에 표시함 | . | top top -&gt; 시스템의 프로세스와 메모리 사용 현황을 표시함 | . | who who -&gt; 현재 시스템에 접속해 있는 사용자를 표시함 | . | . UNIX 기반 시스템에서 ‘batch.sh’ 파일에 대해 소유자와 그룹에게는 전체 권한, 기타 사용자에게는 읽기와 실행 권한만 부여하는 명령문을 8진법 숫자를 이용하여 작성하시오. . UNIX에서는 파일의 권한(permission)을 10자리로 표현하는데 1번째 자리는 디렉터리(d) 또는 파일(-)을, 2~4번째 자리는 소유자(Owner) 권한을, 5~7번째 자리는 그룹(Group) 권한을, 8~10번째 자리는 기타 사용자(Other) 권한을 의미함 . | 각 자리는 r(읽기), w(쓰기), x(실행), -(권한없음)으로 표시함 . . 파일 구분(-): 파일을 의미 | 소유자(rwx): 읽기, 쓰기, 실행 가능 | 그룹(rwx): 읽기, 쓰기, 실행 가능 | 기타 사용자(r-x): 읽기, 실행만 가능 | . | 권한을 변경하는 chmod 명령어는 위의 권한 표현 방식을 8진수로 변경하여 사용할 수 있음 . | 변경 방법은 파일 구분을 제외한 각 권한을 권한있음(1)과 권한없음(0)으로 바꾼 뒤 8진수로 변환하여 chmod 명령어의 매개 변수로 사용하면 됨 . | rwx rwx r-x -(‘-‘는 0, 나머지는 1로 바꾸어 줌)-&gt; 111 111 101 -(3자리 2진수를 8진수로 변환함)-&gt; 7 7 5 -(chmod 명령문을 완성함)-&gt; chmod 775 batch.sh . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/22/theory173.html",
            "relUrl": "/theory/2021/08/22/theory173.html",
            "date": " • Aug 22, 2021"
        }
        
    
  
    
        ,"post46": {
            "title": "환경 변수",
            "content": "1. 환경 변수(Environment Variable) . 시스템 소프트웨어의 동작에 영향을 미치는 동적인 값들의 모임을 의미함 | 환경 변수는 변수명과 값으로 구성됨 | 시스템의 기본 정보를 저장함 | 자식 프로세스에 상속됨 | 시스템 전반에 걸쳐 적용되는 시스템 환경 변수와 사용자 계정 내에서만 적용되는 사용자 환경 변수로 구분됨 | . 2. Windows의 주요 환경 변수 . 환경 변수를 명령어나 스크립트에서 사용하려면 변수명 앞뒤에 ‘%’를 입력해야 함 | Windows에서 set을 입력하면 모든 환경 변수와 값을 출력함 | 환경 변수 %ALLUSERPROFILE% 모든 사용자의 프로필이 저장된 폴더 | . | %APPDATA% 설치된 프로그램의 필요 데이터가 저장된 폴더 | . | %COMSPEC% 기본 명령 프롬프트로 사용할 프로그램명 | . | %HOMEDRIVE% 로그인한 계정의 정보가 저장된 드라이브 | . | %HOMEPATH% 로그인한 계정의 기본 폴더 | . | %LOGONSERVER% 로그인한 계정이 접속한 서버명 | . | %PATH% 실행 파일을 찾는 경로 | . | %PATHEXT% cmd에서 실행할 수 있는 파일의 확장자 목록 | . | %PROGRAMFILES% 기본 프로그램의 설치 폴더 | . | %SYSTEMDRIVE% Windows가 부팅된 드라이브 | . | %SYSTEMROOT% 부팅된 운영체제가 들어 있는 폴더 | . | %TEMP% 또는 %TMP% 임시 파일이 저장되는 폴더 | . | %USERDOMAIN% 로그인한 시스템의 도메인명 | . | %USERNAME% 로그인한 계정 이름 | . | %USERPROFILE% 로그인한 유저의 프로필이 저장된 폴더명 | . | . | . 3. UNIX/LINUX의 주요 환경 변수 . UNIX나 LINUX에서 환경 변수를 명령어나 스크립트에서 사용하려면 변수명 앞에 ‘$’를 입력해야 함 | UNIX나 LINUX에서는 set, env, printenv, setenv 중 하나를 입력하면 모든 환경 변수와 값을 표시함 | 환경 변수 $DISPLAY 현재 X 윈도 디스플레이 위치 | . | $HOME 사용자의 홈 디렉터리 | . | $LANG 프로그램 사용 시 기본적으로 지원되는 언어 | . | $MAIL 메일을 보관하는 경로 | . | $PATH 실행 파일을 찾는 경로 | . | $PS1 쉘 프롬프트 정보 | . | $PWD 현재 작업하는 디렉터리 | . | $TERM 로긴 터미널 타입 | . | $USER 사용자의 이름 | . | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/22/theory172.html",
            "relUrl": "/theory/2021/08/22/theory172.html",
            "date": " • Aug 22, 2021"
        }
        
    
  
    
        ,"post47": {
            "title": "주요 스케줄링 알고리즘",
            "content": "1. FCFS(First Come First Service, 선입 선출) = FIFO(First In First Out) . 준비상태 큐에 도착한 순서에 따라 차례로 CPU를 할당하는 기법임 . | 가장 간단한 알고리즘임 . | 다음과 같은 프로세스들이 차례로 준비상태 큐에 들어왔다고 가정할 때, FCFS 기법을 이용하여 평균 실행 시간, 평균 대기 시간, 평균 반환 시간을 구하시오. (제출시간은 없으며 시간의 단위는 초임) . | 프로세스 번호 p1 p2 P3 . 실행 시간 | 20 | 4 | 6 | . | . 실행 시간을 이용하여 다음과 같이 각 프로세스의 대기 시간과 반환 시간을 구함 대기 시간: 프로세스가 대기한 시간으로, 바로 앞 프로세스까지의 진행 시간으로 계산 | 반환 시간: 프로세스의 대기 시간과 실행 시간의 합 | | 실행 시간, 대기 시간, 반환 시간의 평균은 ‘각 프로세스 시간의 합/프로세스의 개수’를 이용함 평균 실행 시간: (20+4+6)/3 = 10 | 평균 대기 기간: (0+20+24)/3 = 14.6 | 평균 반환 시간: (20+24+30)/3 = 24.6 | . | 2. SJF(Shortest Job First, 단기 작업 우선) . 준비상태 큐에서 기다리고 있는 프로세스들 중에서 실행 시간이 가장 짧은 프로세스에게 먼저 CPU를 할당하는 기법임 | 가장 적은 평균 대기 시간을 제공하는 최적 알고리즘임 | 다음과 같은 프로세스들이 차례로 준비상태 큐에 들어왔다고 가정할 때, SJF 기법을 이용하여 평균 실행 시간, 평균 대기 시간, 평균 반환 시간을 구하시오(제출 시간이 없을 경우) . | 프로세스 번호 P1 P2 P3 . 실행 시간 | 20 | 4 | 6 | . | . 아래와 같이 실행 시간이 짧은 프로세스를 먼저 처리하도록 이동시킨 후 각 프로세스의 대기 시간과 반환 시간을 구함 . | 실행시간, 대기 시간, 반환 시간, 각 시간의 평균은 FCFS의 예제와 동일한 방법으로 구함 . . 평균 실행 시간: (4+6+20)/3 = 10 | 평균 대기 시간: (0+4+10)/3 = 4.6 | 평균 반환 시간: (4+10+30)/3 = 14.6 | . | 3. HRN(Highest Response-ratio Next) . 대기 시간과 서비스(실행) 시간을 이용하는 기법 | 실행 시간이 긴 프로세스에 불리한 SJF 기법을 보완하기 위한 것임 | 우선순위를 계산하여 그 숫자가 가장 높은 것부터 낮은 순으로 우선순위가 부여됨 | 우선순위 계산식 | . 우선순위 계산식 = (대기 시간 + 서비스 시간) / 서비스 시간 . 다음과 같은 프로세스가 HRN 기법으로 스케줄링될 때 우선순위를 계산하시오 . | 프로세스 번호 p1 p2 p3 . 실행 시간 | 20 | 4 | 6 | . 대기 시간 | 10 | 20 | 10 | . 우선순위 계산 | (20+10)/20=1.5 | (4+20)/4=6 | (6+10)/6=2.6 | . 우선순위 | P2-&gt;P3-&gt;P1 |   |   | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/21/theory171.html",
            "relUrl": "/theory/2021/08/21/theory171.html",
            "date": " • Aug 21, 2021"
        }
        
    
  
    
        ,"post48": {
            "title": "스케줄링",
            "content": "1. 스케줄링 . 프로세스가 생성되어 실행될 때 필요한 시스템의 여러 자원을 해당 프로세스에게 할당하는 작업을 의미 | 프로세스가 생성되어 완료될 때까지 프로세스는 여러 종류의 스케줄링 과정을 거치게 됨 | 스케줄링의 종류 장기 스케줄링: 어떤 프로세스가 시스템의 자원을 차지할 수 있도록 할 것인가를 결정하여 준비상태 큐로 보내는 작업 | 중기 스케줄링: 어떤 프로세스들이 CPU를 할당받을 것인지 결정하는 작업 | 단기 스케줄링: 프로세스가 실행되기 위해 CPU를 할당받는 시기와 특정 프로세스를 지정하는 작업 | . | . 2. 스케줄링의 목적 . 공정성: 모든 프로세스에게 공정하게 할당 | 처리율 증가: 단위 시간당 프로세스를 처리하는 비율을 증가시킴 | CPU 이용률 증가: CPU가 순수하게 프로세스를 실행하는 데 사용되는 시간 비율을 증가시킴 | 우선순위 제도: 우선순위가 높은 프로세스를 먼저 실행함 | 오버헤드 최소화: 오버헤드를 최소화함 | 응답 시간 최소화: 작업을 지시하고, 반응하기 시작하는 시간을 최소화함 | 반환 시간 최소화: 프로세스를 제출한 시간부터 실행이 완료될 때까지 걸리는 시간을 최소화함 | 대기 시간 최소화: 프로세스가 준비상태 큐에서 대기하는 시간을 최소화함 | 균형 있는 자원의 사용: 메모리, 입.출력장치 등의 자원을 균형 있게 사용함 | 무한 연기 회피: 자원을 사용하기 위해 무한정 연기되는 상태를 회피함 | . 3. 비선점(Non-Preemptive) 스케줄링 . 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케줄링 기법 | 프로세스가 CPU를 할당받으면 해당 프로세스가 완료될 때까지 CPU를 사용함 | 프로세스 응답 시간의 예측이 용이함 | 일괄 처리 방식에 적합함 | 종류: FCFS, SJF, 우선순위, HRN, 기한부 등 | . 4. 선점(Preemptive) 스케줄링 . 선점 스케줄링은 하나의 프로세스가 CPU를 할당받아 실행하고 있을 때 우선순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케줄링 기법 | 우선순위가 높은 프로세스를 빠르게 처리할 수 있음 | 주로 빠른 응답 시간을 요구하는 대화식 시분할 시스템에 사용됨 | 많은 오버헤드(Overhead)를 초래함 | 종류: Round Robin, SRT, 선점 우선순위, 다단계 큐, 다단계 피드백 큐 등 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/20/theory170.html",
            "relUrl": "/theory/2021/08/20/theory170.html",
            "date": " • Aug 20, 2021"
        }
        
    
  
    
        ,"post49": {
            "title": "프로세스의 개요",
            "content": "1. 프로세스 . 일반적으로 프로세서에 의해 처리되는 사용자 프로그램, 시스템 프로그램, 즉 실행중인 프로그램을 의미함 | 프로세스는 다음과 같이 여러 가지로 정의할 수 있음 PCB를 가진 프로그램 | 실기억장치에 저장된 프로그램 | 프로세서가 할당되는 실체로서, 디스패치가 가능한 단위 | 프로시저가 활동중인 것 | 비동기적 행위를 일으키는 주체 | 지정된 결과를 얻기 위한 일련의 계통적 동작 | 목적 또는 결과에 따라 발생되는 사건들의 과정 | 운영체제가 관리하는 실행 단위 | . | . 2. PCB(Process Control Block, 프로세스 제어 블록) . 운영체제가 프로세스에 대한 정보를 저장해 놓는 곳 | 각 프로세스가 생성될 때마다 고유의 PCB가 생성되고, 프로세스가 완료되면 PCB는 제거됨 | PCB에 저장되어 있는 정보 프로세스의 현재 상태 | 포인터 | 프로세스 고유 식별자 | 스케줄링 및 프로세스의 우선순위 | CPU 레지스터 정보 | 주기억장치 관리 정보 | 입.출력 상태 정보 | 계정 정보 | . | . 3. 프로세스 상태 전이 . 프로세스가 시스템 내에 존재하는 동안 프로세스의 상태가 변하는 것을 의미함 . | 프로세스의 상태는 다음과 같이 상태 전이도로 표시할 수 있음 . . 제출(Submit): 작업을 처리하기 위해 사용자가 작업을 시스템에 제출한 상태 | 접수(Hold): 제출된 작업이 스풀 공간인 디스크의 할당 위치에 저장된 상태 | 준비(Ready): 프로세스가 프로세서를 할당받기 위해 기다리고 있는 상태 | 실행(Run): 준비상태 큐에 있는 프로세스가 프로세서를 할당받아 실행되는 상태 | 대기(Wait), 블록(Block): 프로세스에 입.출력 처리가 필요하면 현재 실행 중인 프로세스가 중단되고, 입.출력 처리가 완료될 때까지 대기하고 있는 상태 | 종료(Terminated, Exit): 프로세스의 실행이 끝나고 프로세스 할당이 해제된 상태 | . | . 4. 프로세스 상태 전이 관련 용어 . Dispatch: 준비 상태에서 대기하고 있는 프로세스 중 하나가 프로세서를 할당받아 실행 상태로 전이되는 과정 | Wake Up: 입.출력 작업이 완료되어 프로세스가 대기 상태에서 준비 상태로 전이 되는 과정 | Spooling: 입.출력장치의 공유 및 상대적으로 느린 입.출력장치의 처리 속도를 보완하고 다중 프로그래밍 시스템의 성능을 향상시키기 위해 입.출력할 데이터를 직접 입.출력장치에 보내지 않고 나중에 한꺼번에 입.출력하기 위해 디스크에 저장하는 과정 | 교통량 제어기: 프로세스의 상태에 대한 조사와 통보 담당 | . 5. 스레드(Thread) . 시스템의 여러 자원을 할당받아 실행하는 프로그램의 단위 또는 프로세스 내에서의 작업 단위로 사용됨 | 하나의 프로세스에 하나의 스레드가 존재하는 경우에는 단일 스레드, 하나 이상의 스레드가 존재하는 경우에는 다중 스레드라고 함 | 프로세스의 일부 특성을 갖고 있기 때문에 경량 프로세스라고도 함 | 스레드 기반 시스템에서 스레드는 독립적인 스케줄링의 최소 단위로서 프로세스의 역할을 담당함 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/19/theory169.html",
            "relUrl": "/theory/2021/08/19/theory169.html",
            "date": " • Aug 19, 2021"
        }
        
    
  
    
        ,"post50": {
            "title": "가상기억장치 기타 관리 사항",
            "content": "1. 페이지 크기 . 페이징 기법을 사용하면 프로그램을 페이지 단위로 나누게 되는데, 페이지의 크기에 따라 시스템에 미치는 영향이 다름 | 페이지의 크기가 작을 경우 페이지 단편화가 감소되고, 한 개의 페이지를 주기억장치로 이동시키는 시간이 줄어듦 | 불필요한 내용이 주기억장치에 적재될 확률이 적으므로 효율적인 워킹 셋을 유지할 수 있음 | 페이지 정보를 갖는 페이지 맵 테이블의 크기가 커지고, 매핑 속도가 늦어짐 | 디스크 접근 횟수가 많아져서 전체적인 입.출력 시간은 늘어남 | . | 페이지 크기가 클 경우 페이지 정보를 갖는 페이지 맵 테이블의 크기가 작아지고, 매핑 속도가 빨라짐 | 디스크 접근 횟수가 줄어들어 전체적인 입.출력의 효율성이 증가됨 | 페이지 단편화가 증가되고, 한 개의 페이지를 주기억장치로 이동시키는 시간이 늘어남 | . | . 2. Locality . Locality(국부성, 지역성, 구역성, 국소성)는 프로세스가 실행되는 동안 주기억장치를 참조할 때 일부 페이지만 집중적으로 참조하는 성질이 있다는 이론임 | 스래싱을 방지하기 위한 워킹 셋 이론의 기반이 되었음 | 가상기억장치 관리와 캐시 메모리 시스템의 이론적인 근거임 | 데닝 교수에 의해 Locality의 개념이 증명되었음 | 종류 시간 구역성(Temporal Locality) 프로세스가 실행되면서 하나의 페이지를 일정 시간 동안 집중적으로 액세스하는 현상 | . | 공간 구역성(Spatial Locality) 프로세스 실행 시 일정 위치의 페이지를 집중적으로 액세스하는 현상 | . | . | . 3. 워킹 셋(Working Set) . 프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합임 | 데닝이 제안한 프로그램의 움직임에 대한 모델로, 프로그램의 Locality 특징을 이용함 | 자주 참조되는 워킹 셋을 주기억장치에 상주시킴으로써 페이지 부재 및 페이지 교체 현상이 줄어들어 프로세스의 기억장치 사용이 인정됨 | . 4. 스래싱(Thrashing) . 프로세스의 처리 시간보다 페이지 교체에 소요되는 시간이 더 많아지는 현상 | 다중 프로그래밍 시스템이나 가상기억장치를 사용하는 시스템에서 하나의 프로세스 수행 과정 중에 자주 페이지 부재가 발생함으로써 나타나며, 전체 시스템의 성능이 저하됨 | 다중 프로그래밍의 정도가 높아짐에 따라 CPU의 이용률은 어느 특정 시점까지는 높아지지만, 다중 프로그래밍 정도가 더욱 커지면 스래싱이 나타나고, CPU 이용률은 급격히 감소하게 됨 | | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/18/theory168.html",
            "relUrl": "/theory/2021/08/18/theory168.html",
            "date": " • Aug 18, 2021"
        }
        
    
  
    
        ,"post51": {
            "title": "페이지 교체 알고리즘",
            "content": "1. 페이지 교체 알고리즘 . 페이지 부재(Page Fault)가 발생하면 가상기억장치에서 필요한 페이지를 찾아 주기억장치에 적재해야 하는데, 이때 주기억장치의 모든 페이지 프레임이 사용중이면 어떤 페이지 프레임을 선택하여 교체할 것인지를 결정하는 기법이 페이지 교체 알고리즘임 | 종류: OPT, FIFO, LRU, LFU, NUR, SCR 등 | . 2. OPT(OPTimal replacement, 최적 교체) . 앞으로 가장 오랫동안 사용하지 않을 페이지를 교체하는 기법 | 벨레이디가 제안한 것 | 페이지 부재 횟수가 가장 적게 발생하는 가장 효율적인 알고리즘 | . 3. FIFO(First In First Out) . 각 페이지가 주기억장치에 적재될 때마다 그때의 시간을 기억시켜 가장 먼저 들어와서 가장 오래 있었던 페이지를 교체하는 기법 . | 이해하기 쉽고, 프로그래밍 및 설계가 간단함 . | 다음의 참조 페이지를 세 개의 페이지 프레임을 가진 기억장치에서 FIFO 알고리즘을 사용하여 교체했을 때 페이지 부재의 수는? (단, 초기 페이지 프레임은 모두 비어 있는 상태임) . . | . 참조 페이지를 각 페이지 프레임에 차례로 적재시키되 이미 적재된 페이지는 해당 위치의 페이지 프레임을 사용함 | 사용할 페이지 프레임이 없을 경우 가장 먼저 들어와서 오래 있었던 페이지 2를 제거한 후 5를 적재함 | 그 다음에 적재된 페이지 3을 제거한 후 2를 적재하며, 같은 방법으로 나머지 참조 페이지를 수행함 | 4. LRU(Least Recently Used) . 최근에 가장 오랫동안 사용하지 않은 페이지를 교체하는 기법 . | 각 페이지마다 계수기(Counter)나 스택을 두어 현시점에서 가장 오랫동안 사용하지 않은, 즉 가장 오래전에 사용된 페이지를 교체함 . | 다음의 참조 페이지를 세 개의 페이지 프레임을 가진 기억장치에서 LRU 알고리즘을 사용하여 교체했을 때 페이지 부재의 수는? (단, 초기 페이지 프레임은 모두 비어 있는 상태임) . . | . 참조 페이지를 각 페이지 프레임에 차례로 적재시키되 이미 적재된 페이지는 해당 위치의 페이지 프레임을 사용함 | 사용할 페이지 프레임이 없을 경우 현재 시점에서 가장 오랫동안 사용되지 않은 페이지 3을 제거한 후 5를 적재함 | 같은 방법으로 나머지 참조 페이지를 수행함 | 5. LFU(Least Frequently Used) . 사용 빈도가 가장 적은 페이지를 교체하는 기법 | 활발하게 사용되는 페이지는 사용 횟수가 많아 교체되지 않고 사용됨 | . 6. NUR(Not Used Recently) . LRU와 비슷한 알고리즘으로, 최근에 사용하지 않은 페이지를 교체하는 기법 | 최근에 사용하지 않은 페이지는 향후에도 사용되지 않을 가능성이 높다는 것을 전제로 LRU에서 나타나는 시간적인 오버헤드를 줄일 수 있음 | 최근의 사용 여부를 확인하기 위해서 각 페이지마다 두 개의 비트, 즉 참조 비트(Reference Bit)와 변형 비트(Modified Bit, Dirty Bit)가 사용됨 | 다음과 같이 참조 비트와 변형 비트의 값에 따라 교체될 페이지의 순서가 결정됨 | . 참조 비트 0 0 1 1 . 변형 비트 | 0 | 1 | 0 | 1 | . 교체 순서 | 1 | 2 | 3 | 4 | . 7. SCR(Second Chance Replacement, 2차 기회 교체) . 가장 오랫동안 주기억장치에 있던 페이지 중 자주 사용되는 페이지의 교체를 방지하기 위한 기법 | FIFO 기법의 단점을 보완하는데 사용됨 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/17/theory167.html",
            "relUrl": "/theory/2021/08/17/theory167.html",
            "date": " • Aug 17, 2021"
        }
        
    
  
    
        ,"post52": {
            "title": "가상기억장치 구현 기법",
            "content": "1. 가상기억장치(Virtual Memory) . 보조기억장치의 일부를 주기억장치처럼 사용하는 것으로, 용량이 작은 주기억장치를 마치 큰 용량을 가진 것처럼 사용하는 기법임 | 프로그램을 여러 개의 작은 블록 단위로 나누어서 가상기억장치에 보관해놓고, 프로그램 실행 시 요구되는 블록만 주기억장치에 불연속적으로 할당하여 처리함 | 주기억장치의 이용률과 다중 프로그래밍의 효율을 높일 수 있음 | 블록 단위로 나누어 사용하므로 연속 할당 방식에서 발생할 수 있는 단편화를 해결할 수 있음 | 가상기억장치의 일반적인 구현 방법: 페이징 기법, 세그멘테이션 기법 | . 2. 페이징 기법 . 가상기억장치에 보관되어 있는 프로그램과 주기억장치의 영역을 동일한 크기로 나눈 후 나눠진 프로그램을 동일하게 나눠진 주기억장치의 영역에 적재시켜 실행하는 기법임 | 프로그램을 일정한 크기로 나눈 단위를 페이지라고 하고, 페이지 크기로 일정하게 나누어진 주기억장치의 단위를 페이지 프레임이라고 함 | 외부 단편화는 발생하지 않으나 내부 단편화는 발생할 수 있음 | 주소 변환을 위해서 페이지의 위치 정보를 가지고 있는 페이지 맵 테이블이 필요함 | 페이지 맵 테이블 사용으로 비용이 증가하고, 처리 속도가 감소됨 | . 3. 세그멘테이션 기법 . 가상기억장치에 보관되어 있는 프로그램을 다양한 크기의 논리적인 단위로 나눈 후 주기억장치에 적재시켜 실행시키는 기법임 | 프로그램을 배열이나 함수 등과 같은 논리적인 크기로 나눈 단위를 세그먼트라고 하며, 각 세그먼트는 고유한 이름과 크기를 가짐 | 세그멘테이션 기법을 이용하는 궁극적인 이유는 기억공간을 절약하기 위해서임 | 주소 변환을 위해서 세그먼트가 존재하는 위치 정보를 가지고 있는 세그먼트 맵 테이블이 필요함 | 내부 단편화는 발생하지 않으나 외부 단편화는 발생할 수 있음 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/16/theory166.html",
            "relUrl": "/theory/2021/08/16/theory166.html",
            "date": " • Aug 16, 2021"
        }
        
    
  
    
        ,"post53": {
            "title": "주기억장치 할당 기법",
            "content": "1. 주기억장치 할당 . 주기억장치 할당 기법은 프로그램이나 데이터를 실행시키기 위해 주기억장치에 어떻게 할당할 것인지에 대한 내용임 | 주기억장치 할당 기법의 분류 연속 할당 기법 프로그램을 주기억장치에 연속으로 할당하는 기법 | 종류: 단일 분할 할당 기법, 다중 분할 할당 기법 | . | 분산 할당 기법 프로그램을 특정 단위의 조각으로 나누어 주기억장치 내에 분산하여 할당하는 기법 | 종류: 페이징 기법, 세그멘테이션 기법 | . | . | . 2. 단일 분할 할당 기법 . 주기억장치를 운영체제 영역과 사용자 영역으로 나누어 한순간에는 오직 한 명의 사용자만이 주기억장치의 사용자 영역을 사용하는 기법임 | 가장 단순한 기법으로 쵝의 운영체제에서 많이 사용하던 기법임 | 운영체제를 보호하고, 프로그램이 사용자 영역만을 사용하기 위해 운영체제 영역과 사용자 영역을 구분하는 경계 레지스터가 사용됨 | 프로그램의 크기가 작을 경우 사용자 영역이 낭비될 수 있음 | 종류 오버레이 기법 주기억장치보다 큰 사용자 프로그램을 실행하기 위한 기법 | . | 스와핑 기법 하나의 프로그램 전체를 주기억장치에 할당하여 사용하다 필요에 따라 다른 프로그램과 교체하는 기법 | . | . | . 3. 다중 분할 할당 기법 . 고정 분할 할당 기법 = 정적 할당 기법 프로그램을 할당하기 전에 운영체제가 주기억장치의 사용자 영역을 여러 개의 고정된 크기로 분할하고 준비상태 큐에서 준비중인 프로그램을 각 영역에 할당하여 수행하는 기법 | . | 가변 분할 할당 기법 = 동적 할당 기법 주기억장치를 미리 분할해 놓지 않고 프로그램을 주기억장치에 적재하면서 필요한 만큼의 크기로 영역을 분할하는 기법 | 고정 분할 할당 기법의 단편화를 줄이기 위해 사용됨 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/15/theory165.html",
            "relUrl": "/theory/2021/08/15/theory165.html",
            "date": " • Aug 15, 2021"
        }
        
    
  
    
        ,"post54": {
            "title": "기억장치 관리",
            "content": "1. 기억장치의 관리 전략 . 보조기억장치의 프로그램이나 데이터를 주기억장치에 적재시키는 시기, 적재 위치 등을 지정하여 한정된 주기억장치의 공간을 효율적으로 사용하기 위한 것임 | 종류 반입(Fetch) 전략 | 배치(Placement) 전략 | 교체(Replacement) 전략 | . | . 2. 반입 전략 . 보조기억장치에 보관중인 프로그램이나 데이터를 언제 주기억장치로 적재할 것인지를 결정하는 전략임 | 기법 요구 반입(Demand Fetch) 실행중인 프로그램이 특정 프로그램이나 데이터 등의 참조를 요구할 때 적재하는 방법 | . | 예상 반입(Anticipatory Fetch) 실행중인 프로그램에 의해 참조될 프로그램이나 데이터를 미리 예상하여 적재하는 방법 | . | . | . 3. 배치 전략 . 새로 반입되는 프로그램이나 데이터를 주기억장치의 어디에 위치시킬 것인지를 결정하는 전략 . | 기법 . 최초 적합(First Fit) 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 첫 번째 분할 영역에 배치시키는 방법 | . | 최적 적합(Best Fit) 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 단편화를 가장 작게 남기는 분할 영역에 배치시키는 방법 | . | 최악 적합(Worst Fit) 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 단편화를 가장 많이 남기는 분할 영역에 배치시키는 방법 | . | . | 예제: 기억장치 상태가 다음 표와 같다. 기억장치 관리 전략으로 First Fit, Best Fit, Worst Fit 방법을 사용하려 할 때 각 방법에 대하여 10K의 프로그램이 할당받게 되는 영역의 번호는? . 영역 번호 영역 크기 상태 . 1 | 5K | 공백 | . 2 | 14K | 공백 | . 3 | 10K | 사용 중 | . 4 | 12K | 공백 | . 5 | 16K | 공백 | . | . 먼저 10K가 적재될 수 있는지 각 영역의 크기를 확인함 | First Fit: 빈 영역 중에서 10K 프로그램이 들어갈 수 잇는 첫 번째 영역은 2번임 | Best Fit: 빈 영역 중에서 10K 프로그램이 들어가고 단편화를 가장 작게 남기는 영역은 4번임 | Worst Fit: 빈 영역 중에서 10K 프로그램이 들어가고 단편화를 가장 많이 남기는 영역은 5번임 | | . 4. 교체(Replacement) 전략 . 주기억장치의 모든 영역이 이미 사용중인 상태에서 새로운 프로그램이나 데이터를 주기억장치에 배치하려고 할 때, 이미 사용되고 있는 영역 중에서 어느 영역을 교체하여 사용할 것인지를 결정하는 전략임 | 종류: FIFO, OPT, LRU, LFU, NUR, SCR 등 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/14/theory164.html",
            "relUrl": "/theory/2021/08/14/theory164.html",
            "date": " • Aug 14, 2021"
        }
        
    
  
    
        ,"post55": {
            "title": "운영체제의 종류",
            "content": "1. Windows . 1990년대 마이크로소프트 사가 개발한 운영체제임 | 주요 특징 그래픽 사용자 인터페이스(GUI) 키보드로 명령어를 직접 입력하지 않고, 마우스로 아이콘이나 메뉴를 선택하여 모든 작업을 수행하는 방식 | . | 선점형 멀티태스킹(Preemptive Multi-Tasking) 동시에 여러 개의 프로그램을 실행하는 멀티태스킹을 하면서 운영체제가 각 작업의 CPU 이용 시간을 제어하여 응용 프로그램 실행 중 문제가 발생하면 해당 프로그램을 강제 종료시키고 모든 시스템 자원을 반환하는 방식 | . | PnP(Plug and Play, 자동 감지 기능) 컴퓨터 시스템에 프린터나 사운드 카드 등의 하드웨어를 설치했을 때, 해당 하드웨어를 사용하는 데 필요한 시스템 환경을 운영체제가 자동으로 구성해주는 기능 | . | OLE(Object Linking and Embedding) 다른 여러 응용 프로그램에서 작성된 문자나 그림 등의 개체(Object)를 현재 작성 중인 문서에 자유롭게 연결(Linking)하거나 삽입(Embedding)하여 편집할 수 있게 하는 기능 | . | 255자의 긴 파일명 / * ? “ &lt; &gt; | 를 제외한 모든 문자 및 공백을 사용하여 최대 255자까지 파일 이름을 지정할 수 있음 | . | . | Single-User 시스템 컴퓨터 한 대를 한 사람만이 독점해서 사용함 | . | . | . 2. UNIX . 1960년대 AT&amp;T 벨 연구소, MIT, General Electric이 공동 개발한 운영체제 | 시분할 시스템을 위해 설계된 대화식 운영체제임 | 소스가 공개된 개방형 시스템임 | 대부분 C 언어로 작성되어 있어 이식성이 높으며 장치, 프로세스 간의 호환성이 높음 | 다중 사용자(Multi-User), 다중 작업(Multi-Tasking)을 지원함 | 트리 구조의 파일 시스템을 가짐 | . 3. UNIX 시스템의 구성 . 커널(Kernel) 하드웨어를 보호하고, 프로그램과 하드웨어 간의 인터페이스 역할을 담당 | UNIX의 가장 핵심적인 부분 | 프로세스(CPU 스케줄링) 관리, 기억장치 관리, 파일 관리, 입.출력 관리, 프로세스간 통신, 데이터 전송 및 변환 등 여러 가지 기능을 수행 | . | 쉘(Shell) 사용자의 명령어를 인식하여 프로그램을 호출하고 명령을 수행하는 명령어 해석기 | 시스템과 사용자 간의 인터페이스를 담당함 | 종류: Bourne Shell, C Shell, Korn Shell | . | 유틸리티 프로그램 일반 사용자가 작성한 응용 프로그램을 처리하는 데 사용함 | DOS에서의 외부 명령어에 해당됨 | 종류: 에디터, 컴파일러, 인터프리터, 디버거 등 | . | . 4. LINUX . 1991년 리누스 토발즈가 UNIX를 기반으로 개발한 운영체제임 | 프로그램 소스 코드가 무료로 공개되어 있기 때문에 프로그래머가 원하는 기능을 추가할 수 있음 | 다양한 플랫폼에 설치하여 사용이 가능하며, 재배포가 가능함 | UNIX와 완벽하게 호환됨 | 대부분의 특징이 UNIX와 동일함 | . 5. MacOS . 1980년대 애플 사가 UNIX를 기반으로 개발한 운영체제임 | 아이맥과 맥북 등 애플 사에서 생산하는 제품에서만 사용이 가능함 | 드라이버 설치 및 install과 uninstall의 과정이 단순함 | . 6. Android . 구글 사에서 개발한 리눅스 커널 기반의 개방형 모바일 운영체제임 | 모든 코드가 공개된 개방형 소프트웨어임 | 자바와 코틀린으로 애플리케이션을 작성함 | 스마트폰 등의 휴대용 장치에서 주로 사용됨 | . 7. iOS . 애플 사에서 개발한 유닉스 기반의 모바일 운영체제임 | 아이폰, 아이팟 터치, 아이패드 등에 내장됨 | 애플사 고유의 모바일 운영체제로 타사 제품은 iOS를 탑재할 수 있음 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/13/theory163.html",
            "relUrl": "/theory/2021/08/13/theory163.html",
            "date": " • Aug 13, 2021"
        }
        
    
  
    
        ,"post56": {
            "title": "운영체제의 개념",
            "content": "1. 운영체제(OS; Operating System) . 컴퓨터 시스템의 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임임 | 컴퓨터 사용자와 컴퓨터 하드웨어 간의 인터페이스로 동작하는 시스템 소프트웨어의 일종 | 다른 응용 프로그램이 유용한 작업을 할 수 있도록 환경을 제공해줌 | 운영체제는 프로세스, 기억장치, 주변장치, 파일 등을 관리하는 기능을 수행함 | 종류: Windows, UNIX, LINUX, MacOS, MS-DOS 등 | . 2. 운영체제의 목적 . 처리 능력 향상 | 사용 가능도 향상 | 신뢰도 향상 | 반환 시간 단축 . | 처리 능력(Throughput): 일정 시간 내에 시스템이 처리하는 일의 양 | 반환 시간(Turn Around Time): 시스템에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간 | 사용 가능도(Availability): 시스템을 사용할 필요가 있을 때 즉시 사용 가능한 정도 | 신뢰도(Reliability): 시스템이 주어진 문제를 정확하게 해결하는 정도 | . 3. 운영체제의 기능 . 프로세서(처리기), 기억장치(주기억장치, 보조기억장치), 입.출력장치, 파일 및 정보 등의 자원을 관리함 | 자원을 효율적으로 관리하기 위해 자원의 스케줄링 기능을 제공함 | 사용자와 시스템 간의 편리한 인터페이스를 제공함 | 시스템의 각종 하드웨어와 네트워크를 관리.제어함 | 데이터를 관리하고, 데이터 및 자원의 공유 기능을 제공 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/12/theory162.html",
            "relUrl": "/theory/2021/08/12/theory162.html",
            "date": " • Aug 12, 2021"
        }
        
    
  
    
        ,"post57": {
            "title": "예외 처리",
            "content": "1. 예외 처리(Exception Handling) . 예외 처리는 예외가 발생했을 때 프로그래머가 해당 문제에 대비해 작성해놓은 처리 루틴이 수행되도록 하는 것 | 예외가 발생했을 때 일반적인 처리 루틴은 프로그램을 종료시키거나 로그를 남기는 것임 | C++, Ada, Java, 자바스크립트와 같은 언어에는 예외 처리 기능이 내장되어 있음 | 필요한 경우 조건문을 이용해 예외 처리 루틴을 작성함 | 대표적인 예외의 원인 컴퓨터 하드웨어 문제 | 운영체제의 설정 실수 | 라이브러리 손상 | 사용자의 입력 실수 | 받아들일 수 없는 연산 | 할당하지 못하는 기억장치 접근 | . | . 2. Java의 예외 처리 . 자바는 예외를 객체로 취급하며, 예외와 관련된 클래스를 java.lang 패키지에서 제공함 | 자바에서는 try~catch 문을 이용해 예외를 처리함 | try 블록 코드를 수행하다 예외가 발생하면 예외를 처리하는 catch 블록으로 이동하여 예외 처리 코드를 수행하므로 예외가 발생한 이후의 코드는 실행되지 않음 | catch 블록에서 선언한 변수는 해당 catch 블록에서만 유효함 | try~catch 문 안에 또 다른 try~catch 문을 포함할 수 있음 | try~catch 문 안에서는 실행 코드가 한 줄이라도 중괄호({ })를 생략할 수 없음 . | 기본 형식 . try { . ​ 예외가 발생할 가능성이 있는 코드; . } . catch(예외객체1 매개변수){ . ​ 예외객체1에 해당하는 예외 발생 시 처리 코드; . } . catch(예외객체2 매개변수){ . ​ 예외객체2에 해당하는 예외 발생 시 처리 코드; . } . catch(예외객체n 매개변수){ . ​ 예외객체n에 해당하는 예외 발생 시 처리 코드; . } . catch(Exception 매개변수){ . ​ 예외객체1~n에 해당하지 않는 예외 발생 시 처리 코드; . } . finally{ . ​ 예외의 발생 여부와 관계 없이 무조건 처리되는 코드; . } . | . 3. Java의 주요 예외 객체 . ClassNotFoundException: 클래스를 찾지 못한 경우 | NoSuchMethodException: 메소드를 찾지 못한 경우 | FileNotFoundException: 파일을 찾지 못한 경우 | InterruptedIOException: 입.출력 처리가 중단된 경우 | ArithmeticException: 0으로 나누는 등의 산술 연산에 대한 예외가 발생한 경우 | IllegalArgumentException: 잘못된 인자를 전달한 경우 | NumberFormatException: 숫자 형식으로 변환할 수 없는 문자열을 숫자 형식으로 변환한 경우 | ArrayIndexOutOfBoundsException: 배열의 범위를 벗어난 접근을 시도한 경우 | NegativeArraySizeException: 0보다 작은 값으로 배열의 크기를 지정한 경우 | NullPointerException: 존재하지 않는 객체를 참조한 경우 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/11/theory161.html",
            "relUrl": "/theory/2021/08/11/theory161.html",
            "date": " • Aug 11, 2021"
        }
        
    
  
    
        ,"post58": {
            "title": "라이브러리",
            "content": "1. 라이브러리 . 프로그램을 효율적으로 개발할 수 있도록 자주 사용하는 함수나 데이터들을 미리 만들어 모아 놓은 집합체임 | 자주 사용하는 함수들의 반복적인 코드 작성을 피하기 위해 미리 만들어 놓은 것이며, 필요할 때는 언제든지 호출하여 사용할 수 있음 | 라이브러리의 분류 표준 라이브러리 프로그래밍 언어에 기본적으로 포함되어 있는 라이브러리 | 여러 종류의 모듈이나 패키지 형태임 | . | 외부 라이브러리 개발자들이 필요한 기능들을 만들어 인터넷 등에 공유해 놓은 라이브러리 | 외부 라이브러리를 다운받아 설치한 후 사용함 | . | . | . 2. C언어의 대표적인 표준 라이브러리 . 라이브러리를 헤더 파일로 제공함 | 헤더 파일을 사용하려면 ‘#include &#39;와 같이 include문을 이용해 선언한 후 사용해야 함 | 헤더파일 stdio.h 데이터의 입.출력에 사용되는 기능들을 제공 | 주요 함수: printf, scanf, fprintf, fscanf, fclose, fopen 등 | . | math.h 수학 함수들을 제공함 | 주요 함수: sqrt, pow, abs 등 | . | string.h 문자열 처리에 사용되는 기능들을 제공함 | 주요 함수:strlen, strcpy, strcmp 등 | . | stdlib.h 자료형 변환, 난수 발생, 메모리 할당에 사용되는 기능들을 제공함 | 주요 함수: atoi, atof, srand, rand, malloc, free 등 | . | time.h 시간 처리에 사용되는 기능들을 제공함 | 주요 함수: time, clock 등 | . | . | . 3. Java의 대표적인 표준 라이브러리 . 라이브러리를 패키지에 포함하여 제공함 | 패키지를 사용하려면 ‘import java.util’과 같이 import 문을 이용해 선언한 후 사용해야 함 | import로 선언된 패키지 안에 있는 클래스의 메소드를 사용할 때는 클래스와 메소드를 마침표(.)로 구분하여 ‘Math.abs()’와 같이 사용함 | 패키지 java.lang 자바에 기본적으로 필요한 인터페이스, 자료형, 예외 처리 등에 관련된 기능을 제공 | import문 없이도 사용할 수 있음 | 주요 클래스: String, System, Process, Runtime, Math, Error 등 | . | java.util 날짜 처리, 난수 발생, 복잡한 문자열 처리 등에 관련된 기능을 제공 | 주요 클래스: Date, Calendar, Random, StringTokenizer 등 | . | java.io 파일 입.출력과 관련된 기능 및 프로토콜을 제공 | 주요 클래스: inputStram, OutputStream, Reader, Writer 등 | . | java.net 네트워크와 관련된 기능을 제공 | 주요 클래스: Socket, URL, InetAddress 등 | . | java.awt 사용자 인터페이스(UI)와 관련된 기능을 제공 | 주요 클래스: Frame, Panel, Dialog, Button, Checkbox 등 | . | . | . 4. Python의 대표적인 표준 라이브러리 . 파이썬에서 라이브러리를 사용하려면 ‘import random’과 같이 선언하고, 사용할 때에는 마침표(.)로 구분하여 ‘random.choice()’와 같이 사용함 | 클래스 내장 함수 Python의 기본적인 인터페이스로 import문이나 클래스명 없이도 사용할 수 있음 | 주요 메소드: abs(), slice(), pow(), print() 등 | . | os 운영체제와 상호 작용하기 위한 기능을 제공 | 주요 메소드: getcwd(), chdir(), system() 등 | . | re 고급 문자열 처리를 위한 기능을 제공 | 주요 메소드: findall(), sub() 등 | . | math 복잡한 수학 연산을 위한 기능을 제공 | 주요 메소드: cos(), log() 등 | . | random 무작위 선택을 위한 기능을 제공 | 주요 메소드: choice(), sample(), random(), randrange() 등 | . | statistics 통계값 산출을 위한 기능을 제공 | 주요 메소드: mean(), median(), variance() 등 | . | datetime 날짜와 시간 조작을 위한 기능을 제공 | 주요 메소드: today(), date(), strftime() 등 | . | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/10/theory160.html",
            "relUrl": "/theory/2021/08/10/theory160.html",
            "date": " • Aug 10, 2021"
        }
        
    
  
    
        ,"post59": {
            "title": "선언형 언어",
            "content": "1. 선언형 언어 . 프로그램이 수행해야 할 문제를 기술하는 언어 | 목표를 명시하고 알고리즘은 명시하지 않음 | 선언형 언어의 분류 함수형 언어 수학적 함수를 조합하여 문제를 해결하는 언어 | 알려진 값을 함수에 적용하는 것을 기반으로 함 | 재귀호출이 자주 이용됨 | 종류: LISP | . | 논리형 언어 기호 논리학에 기반을 둔 언어 | 논리 문장을 이용하여 프로그램을 표현하고 계산을 수행함 | 반복문이나 선택문을 사용하지 않음 | 종류: PROLOG | . | . | . 2. 명령형 언어 . 문제를 해결하기 위한 방법을 기술하는 언어 | 순차적인 명령 수행을 기본으로 함 | 폰노이만 구조에 개념적인 기초를 두고 있음 | 명령형 언어에는 절차적 언어와 객체지향 언어가 있음 | 종류: FORTRAN, COBOL, C, Java 등 | . 3. 선언형 언어의 종류 . HTML 인터넷의 표준 문서인 하이퍼텍스트 문서를 만들기 위해 사용하는 언어 | 특별한 데이터 타입이 없는 단순한 텍스트이므로 호환성이 좋고 사용이 편리함 | . | LISP 인공지능 분야에 사용되는 언어 | 기본 자료 구조가 연결 리스트 구조임 | 재귀(Recursion) 호출을 많이 사용함 | . | PROLOG 논리학을 기초로 한 고급 언어 | 인공 지능 분야에서의 논리적인 추론이나 리스트 처리 등에 주로 사용됨 | . | XML 기존 HTML의 단점을 보완하여 웹에서 구조화된 폭넓고 다양한 문서들을 상호 교환할 수 있도록 설계된 언어 | HTML에 사용자가 새로운 태그(Tag)를 정의할 수 있음 | 문서의 내용과 이를 표현하는 방식이 독립적임 | . | Haskell 함수형 프로그래밍 언어로 부작용이 없음 | 코드가 간결하고 에러 발생 가능성이 낮음 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/09/theory159.html",
            "relUrl": "/theory/2021/08/09/theory159.html",
            "date": " • Aug 9, 2021"
        }
        
    
  
    
        ,"post60": {
            "title": "스크립트 언어",
            "content": "1. 스크립트 언어(Script Language) . HTML 문서 안에 직접 프로그래밍 언어를 삽입하여 사용하는 언어 | 기계어로 컴파일되지 않고 별도의 번역기가 소스를 분석하여 동작함 | 게시판 입력, 상품 검색, 회원 가입 등과 같은 데이터베이스 처리 작업을 수행하기 위해 주로 사용함 | 스크립트 언어의 분류 서버용 스크립트 언어 서버에서 해석되어 실행된 후 결과만 클라이언트로 보냄 | 종류: ASP, JSP, PHP, 파이썬 | . | 클라이언트용 스크립트 언어 클라이언트의 웹 브라우저에서 해석되어 실행됨 | 종류: 자바 스크립트, VB 스크립트 | . | . | . 2. 스크립트 언어의 종류 . 자바 스크립트(JAVA Script) 웹 페이지의 동작을 제어하는 데 사용되는 클라이언트용 스크립트 언어 | 클래스가 존재하지 않으며 변수 선언도 필요 없음 | 서버에서 데이터를 전송할 때 아이디, 비밀번호, 수량 등의 입력 사항을 확인하기 위한 용도로 많이 사용됨 | . | VB 스크립트 마이크로소프트 시에서 자바 스크립트에 대응하기 위해 제작한 언어 | Active X를 사용하여 마이크로소프트 사의 애플리케이션들을 컨트롤할 수 있음 | . | ASP(Active Server Page) 서버 측에서 동적으로 수행되는 페이지를 만들기 위한 언어 | 마이크로소프트 사에서 제작하였음 | Windows 계열에서만 수행 가능함 | . | JSP(Java Server Page) JAVA로 만들어진 서버용 스크립트 언어 | 다양한 운영체제에서 사용 가능 | . | PHP(Professional Hypertext Preprocessor) Linux, Unix, Windows 운영체제에서 사용 가능한 서버용 스크립트 언어 | C, Java 등과 문법이 유사하므로 배우기 쉬워 웹 페이지 제작에 많이 사용됨 | . | 파이썬 객체지향 기능을 지원하는 대화형 인터프리터 언어 | 플랫폼에 독립적이고 문법이 간단하여 배우기 쉬움 | . | 쉘 스크립트 유닉스/리눅스 계열의 쉘에서 사용되는 명령어들의 조합으로 구성된 스크립트 언어 | 쉘 스크립트에서 사용되는 제어문 선택형: if, case | 반복형: for, while, until | . | . | Basic 절차지향 기능을 지원하는 대화형 인터프리터 언어 | 초보자도 쉽게 사용할 수 있는 문법 구조를 가짐 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/08/theory158.html",
            "relUrl": "/theory/2021/08/08/theory158.html",
            "date": " • Aug 8, 2021"
        }
        
    
  
    
        ,"post61": {
            "title": "객체지향 프로그래밍 언어",
            "content": "1. 객체지향 프로그래밍 언어 . 현실 세계의 개체를 개체의 부품처럼 하나의 객체로 만들어, 기계의 부품들을 조립하여 제품을 만들 듯이 소프트웨어를 개발할 때도 객체들을 조립해서 프로그램을 작성하는 기법 | 프로시저보다는 명령과 데이터로 구성된 객체를 중심으로 하는 프로그래밍 기법 | 한 프로그램을 다른 프로그램에서 이용할 수 있도록 한다 | . 2. 객체지향 프로그래밍 언어의 종류 . JAVA 분산 네트워크 환경에 적용이 가능 | 멀티스레드 기능을 제공하므로 여러 작업을 동시에 처리할 수 있음 | 운영체제 및 하드웨어에 독립적이며, 이식성이 강함 | . | C++ C 언어에 객체지향 개념을 적용한 언어 | 모든 문제를 객체로 모델링하여 표현 | . | Smalltalk 1세대 객체지향 프로그래밍 언어로, 순수한 객체지향 프로그래밍 언어 | 최초로 GUI를 제공하였음 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/07/theory157.html",
            "relUrl": "/theory/2021/08/07/theory157.html",
            "date": " • Aug 7, 2021"
        }
        
    
  
    
        ,"post62": {
            "title": "절차적 프로그래밍 언어",
            "content": "1. 절차적 프로그래밍 언어 . 일련의 처리 절차를 정해진 문법에 따라 순서대로 기술하는 언어 | 프로그램이 실행되는 절차를 중요시함 | 데이터를 중심으로 프로시저를 구현하며, 프로그램 전체가 유기적으로 연결되어 있음 | 자연어에 가까운 단어와 문장으로 구성됨 | 과학 계산이나 하드웨어 제어에 주로 사용됨 | . 2. 절차적 프로그래밍 언어의 종류 . C 1972년 미국 벨 연구소의 데니스 리치에 의해 개발됨 | 시스템 프로그래밍 언어로 널리 사용됨 | 고급 프로그래밍 언어이면서 저급 프로그램 언어의 특징을 모두 갖춤 | 이식성이 좋아 컴퓨터 기종에 관계없이 프로그램을 작성할 수 있음 | . | ALGOL . 수치 계산이나 논리 연산을 위한 과학 기술 계산용 언어 | PASCAL과 C 언어의 모체가 됨 | . | COBOL . 사무 처리용 언어 | 영어 문장 형식으로 구성되어 있어 이해와 사용이 쉬움 | 4개의 DIVISION으로 구성됨 | . | FORTRAN . 과학 기술 계산용 언어 | 수학과 공학 분야의 공식이나 수식과 같은 형태로 프로그래밍 할 수 있음 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/06/theory156.html",
            "relUrl": "/theory/2021/08/06/theory156.html",
            "date": " • Aug 6, 2021"
        }
        
    
  
    
        ,"post63": {
            "title": "Python의 활용",
            "content": "1. Python의 개요 . 파이썬은 객체지향 기능을 지원하는 스크립트 언어로, 다른 언어에 비해 문법이 간단하다는 장점이 있다. | 파이썬을 C, Java와 비교했을 때 기본 작성법의 차이점은 다음과 같다. 변수의 자료형에 대한 선언이 없다. | 문자와 문자열을 작은따옴표(‘ ‘), 큰따옴표(“ “)로 구분 없이 사용할 수 있으며 3개의 작은따옴표(‘’’ ‘’’), 3개의 큰따옴표(“”” “”“)로도 묶어 표현할 수 있다. | 문장의 끝을 의미하는 세미콜론(;)을 사용할 필요가 없다. | if나 for와 같이 코드 블록을 포함하는 명령문을 작성할 때 중괄호({ }) 대신 콜론(:)과 여백으로 구분한다. | . | 자료형: 리스트(List), 세트(Set) | 입.출력 함수: input, print | 슬라이스(Slice) | Range | . 2. Python 문제1 . 다음 Python으로 구현된 프로그램에 “xyz321”을 입력했을 때 그 실행 결과를 확인하시오. | . x = input(&#39;입력 :&#39;) a = [ &#39;abc123&#39;, &#39;def456&#39;, &#39;ghi789&#39;] a.append(x) a.remove(&#39;def456&#39;) print(a[1][-3:], a[2][:-3], sep = &#39;,&#39;) for i in range(3, 6): print(i, end = &#39; &#39;) . 결과: . 789, xyz 3 4 5 . 3. Python 문제2 . 다음 Python 프로그램의 실행 결과를 확인하시오. | . a = {&#39;apple&#39;, &#39;lemon&#39;, &#39;banana&#39;} a.update( {&#39;kiwi&#39;, &#39;banana&#39;} ) a.remove(&#39;lemon&#39;) a.add(&#39;apple&#39;) for i in a: print(i) . 결과: apple banana kiwi . Range . 연속된 숫자를 생성하는 것으로, 리스트나 반복문에서 많이 사용됩니다. | 형식 range(최종값): 0에서 ‘최종값’-1까지 연속된 숫자를 생성한다. | range(초기값, 최종값): ‘초기값’에서 ‘최종값’-1까지 연속된 숫자를 생성한다. | range(초기값, 최종값, 증가값) ‘초기값’에서 ‘최종값’-1까지 ‘증가값’만큼 증가하면서 숫자를 생성한다. | ‘증가값’이 음수인 경우 ‘초기값’에서 ‘최종값’+1까지 ‘증가값’만큼 감소하면서 숫자를 생성한다. | . | . | . 슬라이스(Slice) . 문자열이나 리스트와 같은 순차형 객체에서 일부를 잘라 반환하는 기능 | 형식 객체명[초기위치:최종위치] ‘초기위치’에서 ‘최종위치’-1까지의 요소들을 가져온다 | . | 객체명[초기위치:최종위치:증가값] ‘초기위치’에서 ‘최종위치’-1까지 ‘증가값’만큼 증가하면서 해당 위치의 요소들을 가져온다 | ‘증가값’이 음수인 경우 ‘초기위치’에서 ‘최종위치’+1까지 ‘증가값’만큼 감소하면서 해당 위치의 요소들을 가져온다. | . | . | 슬라이스는 일부 인수를 생략하여 사용할 수 있다 객체명[:] 또는 객체명[::] 객체의 모든 요소를 반환한다 | . | 객체명[초기위치:] 객체의 ‘초기위치’에서 마지막 위치까지의 요소들을 반환한다 | . | 객체명[:최종위치] 객체의 0번째 위치에서 ‘최종위치’-1까지의 요소들을 반환한다 | . | 객체명[::증가값] 객체의 0번째 위치에서 마지막 위치까지 ‘증가값’만큼 증가하면서 해당 위치의 요소들을 반환한다 | . | . | . 리스트 관련 주요 메소드 . pop(위치) 리스트의 ‘위치’에 있는 값을 출력하고 해당 요소를 삭제 | [10, 11, 12].pop(1) -&gt; 11 출력 -&gt; [10, 12] | . | index(값) 리스트에서 ‘값’이 저장된 요소의 위치를 반환 | [10, 11, 12].index(12) -&gt; 2 | . | count(값) 리스트에서 ‘값’이 저장되어 있는 요소들의 개수를 반환 | [1, 0, 1, 0, 0].count(0) -&gt; 3 | . | extend(리스트) 리스트의 끝에 새로운 ‘리스트’를 추가하여 확장 | [‘a’, ‘b’].extend([‘c’, ‘d’]) -&gt; [‘a’, ‘b’, ‘c’, ‘d’] | . | reverse() 리스트의 순서를 역순으로 뒤집는다 | [1, 2, 3].reverse() -&gt; [3, 2, 1] | . | sort() 리스트를 정렬하며, 기본값은 오름차순이다 | reverse 속성을 이용하여 정렬 방식을 지정할 수 있다 True: 내림차순, False: 오름차순 | . | [2, 1, 3].sort() -&gt; [1, 2, 3] | [2, 1, 3].sort(reverse = True) -&gt; [3, 2, 1] | . | copy() 리스트를 복사 | a = [1, 2, 3], b = a.copy() | . | . 세트 관련 주요 메소드 . pop() 세트의 값을 출력하고 요소를 삭제 | {10, 11, 12}.pop() -&gt; 10 출력 -&gt; {11, 12} | . | add(값) 세트에 ‘값’을 추가 | {10, 11, 12}.add(13) -&gt; {10, 11, 12, 13} | . | update(세트) 세트에 새로운 ‘세트’를 추가하여 확장 | {‘a’, ‘b’, ‘c’}.extend({‘c’, ‘d’}) -&gt; {‘a’, ‘b’, ‘c’, ‘d’} | . | remove(값) 세트에서 ‘값’을 찾아 해당 요소를 삭제 | {10, 11, 12}.remove(10) -&gt; {11, 12} | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/05/theory155.html",
            "relUrl": "/theory/2021/08/05/theory155.html",
            "date": " • Aug 5, 2021"
        }
        
    
  
    
        ,"post64": {
            "title": "Java의 활용",
            "content": "1. 추상 클래스와 형 변환의 개요 . 추상 메소드는 자식 클래스에서 재정의해야만 사용할 수 있는 메소드를 의미하며, 이런 메소드를 하나 이상 포함하는 클래스를 추상 클래스라고 한다. 그리고 이렇게 재정의한 메소드를 부모 클래스의 객체 변수를 통해 사용하려면 부모 클래스의 객체 변수를 선언할 때 자식 클래스의 생성자를 이용해야 하는데, 이것을 클래스의 형 변환이라고 한다. | . 2. Java 문제 . 다음 Java 프로그램의 실행 결과를 확인하시오. | . abstract class Animal{ String a = &quot; is animal&quot;; abstract void look(); void show(){ System.out.println(&quot;Zoo&quot;); } } class Chicken extends Animal{ Chicken(){ look(); } void look(){ System.out.println(&quot;Chick&quot; + a); } void display(){ System.out.println(&quot;two wings&quot;); } } public class Test{ public static void main(String[] args){ Animal a = new Chicken(); a.show(); } } . 결과: Chicken is animal Zoo .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/04/theory154.html",
            "relUrl": "/theory/2021/08/04/theory154.html",
            "date": " • Aug 4, 2021"
        }
        
    
  
    
        ,"post65": {
            "title": "Java의 클래스",
            "content": "1. Java 클래스의 개요 . 클래스는 객체 생성을 위한 필드(속성)와 메소드(함수)를 정의하는 설계도로, Java는 아무리 작은 프로그램이라도 클래스를 만들어서 사용해야 한다. | 클래스를 만들어 사용하는 순서는 다음과 같다. | . 클래스 이름을 정하고 객체 생성을 위한 필드와 메소드를 정의한다. 마치 자동차를 만들기 위한 설계도와 같다. 이때 사용하는 명령이 class이다. | 객체를 생성한다. 자동차 설계도로 자동차를 만들어야 사용할 수 있듯이 클래스를 이용해 객체를 생성해야 프로그램에서 사용할 수 있다. 이때 사용하는 명령이 new이다. | 생성된 객체들을 이용하여 프로그램을 코딩하면 된다. | 2. Java 문제1 . 다음은 Java에서 클래스를 만들고 객체를 생성해서 사용하는 간단한 프로그램이다. 어떤 일을 수행하는지 확인하시오. | . class ClassA{ int a = 10; int funcAdd(int x, int y){ return x + y + a; } } public class Test { public static void main(String[] args){ int x = 3, y = 6, r; ClassA cal = new ClassA(); r = cal.funcAdd(x, y); System.out.print(r); } } . 결과: 19 . 3. Java 문제2 . 다음 Java 프로그램의 실행 결과를 확인하시오. | . class ClassA{ ClassA(){ System.out.print(&#39;A&#39;); this.prn(); } void prn(){ System.out.print(&#39;B&#39;); } } class ClassB extends ClassA{ ClassB(){ super(); System.out.print(&#39;D&#39;); } void prn(){ System.out.print(&#39;E&#39;); } void prn(int x){ System.out.print(x); } } public class Test{ public static void main(String[] args){ int x = 7; ClassB cal = new ClassB(); cal.prn(x); } } . 결과: AED7 .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/03/theory153.html",
            "relUrl": "/theory/2021/08/03/theory153.html",
            "date": " • Aug 3, 2021"
        }
        
    
  
    
        ,"post66": {
            "title": "사용자 정의 함수",
            "content": "1. 사용자 정의 함수의 개요 . 말 그대로 사용자가 직접 만들어 사용하는 함수이다. | . 2. C 문제 . 다음은 재귀 함수를 이용해 팩토리얼(Factorial) 연산을 수행하는 C 프로그램이다. 그 실행 결과를 확인하시오. | . #include &lt;stdio.h&gt; int factorial(int n); main(){ int (*pf)(int); pf = factorial; printf(&quot;%d&quot;, pf(3)); } int factorial(int n){ if(n&lt;=1) return 1; else return n*factorial(n-1); } . 결과: 6 .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/02/theory152.html",
            "relUrl": "/theory/2021/08/02/theory152.html",
            "date": " • Aug 2, 2021"
        }
        
    
  
    
        ,"post67": {
            "title": "포인터",
            "content": "1. 포인터의 개요 . 앞에서 어떤 수나 문자를 저장하기 위해 변수를 사용했다. 사실 이 변수는 기억 장소의 어느 위치에 대한 이름이며 그 위치는 주소로도 표현할 수 있다. 우리는 친구 홍길동의 집에 모이기 위해 “홍길동이네 집으로 와”라고 말하기도 하지만 홍길동의 집 주소인 “서울시 마포구 서교동 00번지로 와”라고 말하기도 한다. C언어에서는 변수의 주소를 포인터라고 하고, 포인터를 저장할 수 있는 변수를 포인터 변수라고 한다. 변수의 주소인 포인터는 출력할 수도 있고 포인터가 가리키는 곳에 값을 저장하거나 읽어 오는 등 다양한 조작이 가능하다. 이런 기능 때문에 C 언어는 주소를 제어할 수 있는 기능이 있다고 말한다. 자바는 포인터를 다룰 수 없다. | . 2. C 문제 . 다음 C언어로 구현된 프로그램의 실행 결과를 확인하시오. | . #include &lt;stdio.h&gt; main(){ int a = 50; int *b = &amp;a; *b = *b + 20; printf(&quot;%d, %d n&quot;, a, *b); char *s; s = &quot;gilbut&quot;; for(int i=0; i&lt;6; i+=2){ printf(&quot;%c, &quot;, s[i]); printf(&quot;%c, &quot;, *(s+i)); printf(&quot;%s n&quot;, s+i); } } . 결과: 70, 70 g, g, gilbut l, l, lbut u, u, ut .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/08/01/theory151.html",
            "relUrl": "/theory/2021/08/01/theory151.html",
            "date": " • Aug 1, 2021"
        }
        
    
  
    
        ,"post68": {
            "title": "제어문",
            "content": "1. 제어문의 개요 . 제어문은 서술된 순서에 따라 무조건 위에서 아래로 실행되는 프로그램의 순서를 변경할 때 사용하는 명령문임 | . 2. C 문제 . 다음 C 언어로 구현된 프로그램의 실행 결과를 확인하시오. | . #include &lt;stdio.h&gt; main(){ int score[] = {86, 53, 95, 76, 61}; char grade; char str[] = &quot;Rank&quot;; for(int i=0; i&lt;5; i++){ switch(score[i] / 10){ case 10: case 9: grade = &#39;A&#39;; break; case 8: grade = &#39;B&#39;; break; case 7: grade = &#39;C&#39;; break; default: grade = &#39;F&#39;; } if(grade != &#39;F&#39;) printf(&quot;%d is %c %s n&quot;, i+1, grade, str); } } . 결과: 1 is B Rank 3 is A Rank 4 is C Rank . 3. Java 문제 . 다음 Java로 구현된 프로그램의 실행 결과를 확인하시오. | . public class Test { public static void main(String[] args){ String str = &quot;agile&quot;; int x[] = {1, 2, 3, 4, 5}; char y[] = new char[5]; int i=0; while(i&lt;str.length()){ y[i] = str.charAt(i); i++; } for(int p : x){ i--; System.out.print(y[i]); System.out.print(p + &quot; &quot;); } } } . 결과: e1 l2 i3 . break와 continue . break: 반복문이나 switch문 안에서 break가 나오면 블록을 벗어난다 | continue: 반복문에서 continue가 나오면 continue 이후의 문장을 실행하지 않고 제어를 반복문의 처음으로 옮긴다 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/07/30/theory150.html",
            "relUrl": "/theory/2021/07/30/theory150.html",
            "date": " • Jul 30, 2021"
        }
        
    
  
    
        ,"post69": {
            "title": "데이터 입.출력",
            "content": "1. 데이터 입.출력의 개요 . 키보드로부터 데이터를 입력받아 화면이나 파일로 출력하는 것을 의미함 | 헝가리안 표기법 | 자료형 | C언어의 입.출력 함수: scanf, printf | Java의 입.출력 함수: Scanner, nextInt, print, printf, println | 서식 지정자와 제어 문자 | 연산자와 우선순위 | . 2. C 문제 . 다음은 키보드로 6과 4를 입력받아 두 수의 덧셈 결과를 출력하는 프로그램이다. 출력 결과를 확인하시오. | . #include &lt;stdio.h&gt; main() { int i, j, k; scanf(&quot;%d %d&quot;, &amp;i, &amp;j); k = i + j; printf(&quot;%d n&quot;, k); } . 결과: 10 . 3. Java 문제 . 다음은 입력받은 정수를 가지고 여러 연산을 수행한 후 출력하는 프로그램이다. 4가 입력되었다고 가정했을 때 출력 결과를 확인하시오. | . import java.util.Scanner; public class Test { public static void main(String[] args) { Scanner scan = new Scanner(System.in); int a = scan.nextInt(); System.out.printf(&quot;a * 3 = %d n&quot;, a*3); System.out.println(&quot;a / 2 = &quot; + (a/2)); System.out.print(&quot;a - 1 = &quot; + (a-1)); scan.close(); } } . 결과: a * 3 = 12 a / 2 = 2 a - 1 = 3 . 헝가리안 표기법 . 변수명 작성 시 변수의 자료형을 알 수 있도록 자료형을 의미하는 문자를 포함하여 작성하는 방법임. 예를 들어 정수형 변수라는 것을 알 수 있도록 변수명에 int를 의미하는 i를 덧붙여 i_inputA, i_inputB, i_Result라고 하는 경우. . 주요 자료형 . 종류 자료형 크기(c) 크기(java) . 정수형 | int | 4Byte | 4Byte | . 문자형 | char | 1Byte | 2Byte | . 실수형 | float | 4Byte | 4Byte | .   | double | 8Byte | 8Byte | . 주요 서식 문자열 . 서식 문자열 의미 . %d | 정수형 10진수의 입.출력에 사용 | . %o | 정수형 8진수의 입.출력에 사용 | . %x | 정수형 16진수의 입.출력에 사용 | . %c | 문자의 입.출력에 사용 | . %s | 문자열의 입.출력에 사용 | . %f | - 소수점을 포함한 실수의 입.출력에 사용- 출력 시 소수점 이하는 기본적으로 6자리가 출력됨 | . 주요 제어문자 . 제어문자 기능 . n | 커서를 다음 줄의 처음으로 이동 | . f | 커서를 일정 간격 띄움 | . 0 | 널 문자 출력 | . 연산자 우선순위 . 대분류 중분류 연산자 결합규칙 우선 순위 . 단항 연산자 | 단항 연산자 | ! ~ ++ – sizeof | &lt;- | 높음 | . 이항 연산자 | 산술 연산자 | * / % | -&gt; |   | .   | 시프트 연산자 | « » |   |   | .   | 관계 연산자 | &lt; &lt;= &gt;= &gt; |   |   | .   |   | == != |   |   | .   | 비트 연산자 | &amp; ^ | |   |   | .   | 논리 연산자 | &amp;&amp; || |   |   | . 삼항 연산자 | 조건 연산자 | ? : | -&gt; |   | . 대입 연산자 | 대입 연산자 | = += -= *= /= %= «= »= 등 | &lt;- |   | . 순서 연산자 | 순서 연산자 | . | -&gt; | 낮음 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/07/29/theory149.html",
            "relUrl": "/theory/2021/07/29/theory149.html",
            "date": " • Jul 29, 2021"
        }
        
    
  
    
        ,"post70": {
            "title": "취약점 분석.평가",
            "content": "1. 취약점 분석.평가 . 사이버 위협으로부터 정보 시스템의 취약점을 분석 및 평가한 후 개선하는 일련의 과정을 말함 | 안정적인 정보 시스템의 운영을 방해하는 사이버 위협에 대한 항목별 세부 점검항목을 파악하여 취약점 분석을 수행함 | 취약점이 발견되면, 위험 등급을 부여하고 개선 방향을 수립함 | . 2. 취약점 분석.평가 범위 및 항목 . 취약점 분석.평가의 범위는 정보 시스템과 정보 시스템 자산에 직.간접적으로 관여된 물리적, 관리적, 기술적 분야를 포함함 | 취약점 분석.평가의 기본 항목은 상, 중, 하 3단계로 중요도를 분리함 | 취약점 분석.평가의 기본 항목은 중요도가 ‘상’인 항목은 필수적으로 점검함 | 취약점 분석.평가의 기본 항목의 중요도가 ‘중’, ‘하’인 항목은 회사의 사정에 따라 선택적으로 점검함 | . 3. 수행 절차 및 방법 . 취약점 분석.평가 계획 수립 . 취약점 분석.평가를 위한 수행 주체, 수행 절차, 소요 예산, 산출물 등의 세부 계획 수립 . | 취약점 분석.평가 대상 선별 . 정보 시스템의 자산을 식별하고, 유형별로 그룹화하여 취약점 분석.평가 대상 목록 작성 . | 취약점 분석 수행 . 취약점 분석 평가를 위한 관리적, 물리적, 기술적 세부 점검 항목표 작성 . | 취약점 평가 수행 . 취약점 분석 세부 결과 작성 . 파악된 취약점별로 위험등급을 상, 중, 하 3단계로 표시 . |",
            "url": "https://eunkyung99.github.io/gang/theory/2021/07/28/theory148.html",
            "relUrl": "/theory/2021/07/28/theory148.html",
            "date": " • Jul 28, 2021"
        }
        
    
  
    
        ,"post71": {
            "title": "보안 솔루션",
            "content": "1. 보안 솔루션 . 접근 통제, 침입 차단 및 탐지 등을 수행하여 외부로부터의 불법적인 침입을 막는 기술 및 시스템을 말함 | 주요 보안 솔루션 방화벽 | 침입 탐지 시스템(IDS) | 침입 방지 시스템(IPS) | 데이터 유출 방지(DLP) | 웹 방화벽 | VPN | NAC | ESM | . | . 2. 방화벽(Firewall) . 기업이나 조직 내부의 네트워크와 인터넷 간에 전송되는 정보를 선별하여 수용.거부.수정하는 기능을 가진 침입 차단 시스템임 | 내부 네트워크에서 외부로 나가는 패킷은 그대로 통과시키고, 외부에서 내부 네트워크로 들어오는 패킷은 내용을 엄밀히 체크하여 인증된 패킷만 통과시키는 구조임 | . 3. 침입 탐지 시스템(IDS; Intrusion Detection System) . 컴퓨터 시스템의 비정상적인 사용, 오용, 남용 등을 실시간으로 탐지하는 시스템 | 오용 탐지(Misuse Detection): 미리 입력해 둔 공격 패턴이 감지되면 이를 알려줌 | 이상 탐지(Anomaly Detection): 평균적인 시스템의 상태를 기준으로 비정상적인 행위나 자원의 사용이 감지되면 이를 알려줌 | . 4. 침입 방지 시스템(IPS; Intrusion Prevention System) . 비정상적인 트래픽을 능동적으로 차단하고 격리하는 등의 방어 조치를 취하는 보안 솔루션임 | 방화벽과 침입 탐지 시스템을 결합한 것임 | 침입 탐지 기능으로 패킷을 하나씩 검사한 후 비정상적인 패킷이 탐지되면 방화벽 기능으로 해당 패킷을 차단함 | . 5. 데이터 유출 방지(DLP; Data Leekage/Loss Prevention) . 내부 정보의 외부 유출을 방지하는 보안 솔루션임 | 사내 직원이 사용하는 PC와 네트워크상의 모든 정보를 검색하고 메일, 메신저, 웹하드, 네트워크 프린터 등의 사용자 행위를 탐지.통제해 외부로의 유출을 사전에 막음 | . 6. 웹 방화벽(Web Firewall) . 일반 방화벽이 탐지하지 못하는 SQL 삽입 공격, Cross-Site Scripting(XSS) 등의 웹 기반 공격을 방어할 목적으로 만들어진 웹 서버에 특화된 방화벽임 | 웹 관련 공격을 감시하고 공격이 웹 서버에 도달하기 전에 이를 차단해 줌 | . 7. VPN(Virtual Private Network, 가상 사설 통신망) . 인터넷 등 통신 사업자의 공중 네트워크와 암호화 기술을 이용하여 사용자가 마치 자신의 전용 회선을 사용하는 것처럼 해주는 보안 솔루션임 | 암호화된 규격을 통해 인터넷망을 전용선의 사설망을 구축한 것처럼 이용하므로 비용 부담을 줄일 수 있음 | 원격지의 지사, 영업소, 이동 근무자가 지역적인 제한 없이 업무를 수행할 수 있음 | . 8. NAC(Network Access Control) . 네트워크에 접속하는 내부 PC의 MAC 주소를 IP 관리 시스템에 등록한 후 일관된 보안 관리 기능을 제공하는 보안 솔루션임 | 내부 PC의 소프트웨어 사용 현황을 관리하여 불법적인 소프트웨어 설치를 방지함 | . 9. ESM(Enterprise Security Management) . 다양한 장비에서 발생하는 로그 및 보안 이벤트를 통합하여 관리하는 보안 솔루션임 | 방화벽, IDS, IPS, 웹 방화벽, VPN 등에서 발생한 로그 및 보안 이벤트를 통합하여 관리함으로써 비용 및 자원을 절약할 수 있음 | 보안 솔루션 간의 상호 연동을 통해 종합적인 보안 관리 체계를 수립할 수 있음 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/07/27/theory147.html",
            "relUrl": "/theory/2021/07/27/theory147.html",
            "date": " • Jul 27, 2021"
        }
        
    
  
    
        ,"post72": {
            "title": "로그 분석",
            "content": "1. 로그(Log) . 시스템 사용에 대한 모든 내역을 기록해 놓은 것임 | 로그 정보를 이용하면 시스템 침해 사고 발생 시 해킹 흔적이나 공격 기법을 파악할 수 있음 | 로그 정보를 정기적으로 분석하면 시스템에 대한 침입 흔적이나 취약점을 확인할 수 있음 | . 2. 리눅스(LINUX) 로그 . 시스템의 모든 로그를 var/log 디렉터리에서 기록하고 관리함 | 로그 파일을 관리하는 syslogd 데몬은 etc/syslog.conf 파일을 읽어 로그 관련 파일들의 위치를 파악한 후 로그 작업을 시작함 | syslog.conf 파일을 수정하여 로그 관련 파일들의 저장 위치와 파일명을 변경할 수 있음 | . 3. 리눅스의 주요 로그 파일 . 로그 파일명 데몬 내용 . 커널 로그 | /dev/console | kernel | 커널에 관련된 내용을 관리자에게 알리기 위해 파일로 저장하지 않고 지정된 장치에 표시함 | . 부팅 로그 | /var/log/boot.log | boot | 부팅 시 나타나는 메시지들을 기록함 | . 크론 로그 | /var/log/cron | crond | 작업 스케줄러인 crond의 작업 내역을 기록함 | . 시스템 로그 | /var/log/messages | syslogd | 커널에서 실시간으로 보내오는 메시지들을 기록함 | . 보안 로그 | /var/log/secure | xinetd | 시스템의 접속에 대한 로그를 기록함 | . FTP 로그 | /var/log/xferlog | ftpd | FTP로 접속하는 사용자에 대한 로그를 기록함 | . 메일 로그 | /var/log/maillog | sendmail popper | 송수신 메일에 대한 로그를 기록함 | . 4. 윈도우 로그 . Windows 시스템에서는 이벤트 로그 형식으로 시스템의 로그를 관리함 | Windows의 이벤트 뷰어를 이용하여 로그를 확인할 수 있음 | . 5. Windows 이벤트 뷰어의 로그 . 응용 프로그램 응용 프로그램에서 발생하는 이벤트가 기록됨 | 기록되는 이벤트는 응용 프로그램 개발자에 의해 결정됨 | . | 보안 로그온 시도, 파일이나 객체 생성, 조회, 제거 등의 리소스 사용과 관련된 이벤트가 기록됨 | . | 시스템 Windows 시스템 구성 요소에 의해 발생하는 이벤트가 기록됨 | . | Setup 프로그램 설치와 관련된 이벤트가 기록됨 | . | Forwarded Events 다른 컴퓨터와의 상호 작용으로 발생하는 이벤트가 기록됨 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/07/26/theory146.html",
            "relUrl": "/theory/2021/07/26/theory146.html",
            "date": " • Jul 26, 2021"
        }
        
    
  
    
        ,"post73": {
            "title": "보안 아키텍처/보안 프레임워크",
            "content": "1. 보안 아키텍처(Security Architecture) . 정보 시스템의 무결성, 가용성, 기밀성을 확보하기 위해 보안 요소 및 보안 체계를 식별하고 이들 간의 관계를 정의한 구조를 말함 | 보안 아키텍처를 통해 관리적, 물리적, 기술적 보안 개념의 수립, 보안 관리 능력의 향상, 일관된 보안 수준의 유지를 기대할 수 있음 | 보안 수준에 변화가 생겨도 기본 보안 아키텍처의 수정 없이 지원이 가능해야 함 | 보안 요구사항의 변화나 추가를 수용할 수 있어야 함 | . 2. 보안 프레임워크(Security Framework) . 안전한 정보 시스템 환경을 유지하고 보안 수준을 향상시키기 위한 체계를 말함 | ISO 27001은 정보보안 관리를 위한 국제 표준으로, 일종의 보안 인증이자 가장 대표적인 보안 프레임워크임 | ISO 27001은 영국의 BSI(British Standards Institute)가 제정한 BS 7799를 기반으로 구성되어 있음 | ISO 27001은 조직에 대한 정보보안 관리 규격이 정의되어 있어 실제 심사/인증용으로 사용됨 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/07/25/theory145.html",
            "relUrl": "/theory/2021/07/25/theory145.html",
            "date": " • Jul 25, 2021"
        }
        
    
  
    
        ,"post74": {
            "title": "서버 인증",
            "content": "1. 보안 서버 . 인터넷을 통해 개인정보를 암호화하여 송.수신할 수 있는 기능을 갖춘 서버를 말함 | 기능 서버에 SSL(Secure Socket Layer) 인증서를 설치하여 전송 정보를 암호화하여 송.수신하는 기능 | 서버에 암호화 응용 프로그램을 설치하고 전송 정보를 암호화하여 송.수신하는 기능 | . | . 2. 인증(Authentication) . 다중 사용자 컴퓨터 시스템이나 네트워크 시스템에서 로그인을 요청한 사용자의 정보를 확인하고 접근 권한을 검증하는 보안 절차임 | 인증에는 네트워크를 통해 컴퓨터에 접속하는 사용자의 등록 여부를 확인하는 것과 전송된 메시지의 위.변조 여부를 확인하는 것이 있음 | 인증의 주요 유형 지식 기반 인증(Something You Know) | 소유 기반 인증(Something You Have) | 생체 기반 인증(Something You Are) | 위치 기반 인증(Somewhere You Are) | . | . 3. 지식 기반 인증 . 사용자가 기억하고 있는 정보를 기반으로 인증을 수행하는 것임 | 사용자의 기억을 기반으로 하므로 관리 비용이 저렴함 | 사용자가 인증 정보를 기억하지 못하면 본인이라도 인증받지 못함 | 유형 고정된 패스워드(Password) 사용자가 알고 있는 비밀번호를 접속할 때마다 반복해서 입력함 | . | 패스 프레이즈(Passphrase) 일반 패스워드보다 길이가 길고 기억하기 쉬운 문장을 활용하여 비밀번호를 구성하는 방법 | . | 아이핀(i-PIN) 인터넷에서 주민등록번호 대신 쓸 수 있도록 만든 사이버 주민등록번호 | 사용자에 대한 신원확인을 완료한 후에 본인확인 기관에서 온라인으로 발행함 | . | . | . 4. 소유 기반 인증 . 사용자가 소유하고 있는 것을 기반으로 인증을 수행하는 것 | 소유물이 쉽게 도용될 수 있으므로 지식 기반 인증 방식이나 생체 인증 방식과 함께 사용됨 | 유형 신분증 사용자의 사진이 포함된 주민등록증, 운전면허증, 여권 등을 사용하여 사용자의 신분 확인 | . | 메모리 카드(토큰) 마그네틱 선에 보안 코드를 저장해서 사용하는 것으로, 카드 리더기를 통해서만 읽을 수 있음 | . | 스마트 카드 마이크로프로세서, 카드 운영체제, 메모리 등으로 구성되어 사용자의 정보뿐만 아니라 특정 업무를 처리할 수 있는 기능이 내장되어 있음 | . | OTP(One Time Password) 사용자가 패스워드를 요청할 때마다 암호 알고리즘을 통해 새롭게 생성된 패스워드를 사용하는 것 | 한 번 사용된 패스워드는 폐기됨 | . | . | . 5. 생체 기반 인증 . 사용자의 고유한 생체 정보를 기반으로 인증을 수행하는 것 | 사용이 쉽고 도난의 위험도 적으며 위조가 어려움 | 생체 인증 대상: 지문, 홍채/망막, 얼굴, 음성, 정맥 등 | . 6. 기타 인증 방법 . 행위 기반 인증(Something You Do) 사용자의 행동 정보를 이용해 인증 수행 ex. 서명, 동작 | . | 위치 기반 인증(Somewhere You Are) 인증을 시도하는 위치의 적절성 확인 ex. 콜백, GPS나 IP 주소를 이용한 위치 기반 인증 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/07/24/theory144.html",
            "relUrl": "/theory/2021/07/24/theory144.html",
            "date": " • Jul 24, 2021"
        }
        
    
  
    
        ,"post75": {
            "title": "서비스 공격 유형",
            "content": "1. 서비스 거부(DoS; Denial of Service) 공격 . 표적이 되는 서버의 자원을 고갈시킬 목적으로 다수의 공격자 또는 시스템에서 대량의 데이터를 한 곳의 서버에 집중적으로 전송함으로써, 표적이 되는 서버의 정상적인 기능을 방해하는 것임 | 주요 서비스 거부 공격의 유형 Ping of Death | SMURFING | SYN Flooding | TearDrop | LAND Attack | DDoS 공격 | . | . 2. Ping of Death(죽음의 핑) . Ping 명령을 전송할 때 패킷의 크기를 인터넷 프로토콜 허용 범위 이상으로 전송하여 공격 대상의 네트워크를 마비시키는 서비스 거부 공격 방법임 | 공격에 사용되는 큰 패킷은 수백 개의 패킷으로 분할되어 전송되는데, 공격 대상은 분할된 대량의 패킷을 수신함으로써 분할되어 전송된 패킷을 재조립해야 하는 부담과 분할되어 전송된 각각의 패킷들의 ICMP Ping 메시지에 대한 응답을 처리하느라 시스템이 다운되게 됨 | . 3. SMURFING(스머핑) . IP나 ICMP의 특성을 악용하여 엄청난 양의 데이터를 한 사이트에 집중적으로 보냄으로써 네트워크를 불능 상태로 만드는 공격 방법 | 공격자는 송신 주소를 공격 대상지의 IP 주소로 위장하고 해당 네트워크 라우터의 브로드캐스트 주소를 수신지로 하여 패킷을 전송하면, 라우터의 브로드캐스트 주소로 수신된 패킷은 해당 네트워크 내의 모든 컴퓨터로 전송됨 . | 해당 네트워크 내의 모든 컴퓨터는 수신된 패킷에 대한 응답 메시지를 송신 주소인 공격 대상지로 집중적으로 전송하게 되는데, 이로 인해 공격 대상지는 네트워크 과부하로 인해 정상적인 서비스를 수행할 수 없게 됨 | SMURFING 공격을 무력화하는 방법 중 하나는 각 네트워크 라우터에서 브로드캐스트 주소를 사용할 수 없게 미리 설정해 놓는 것임 | . 4. SYN Flooding . TCP(Transmission Control Protocol)는 신뢰성 있는 전송을 위해 3-way-handshake를 거친 후에 데이터를 전송하게 되는데, SYN Flooding은 공격자가 가상의 클라이언트로 위장하여 3-way-handshake 과정을 의도적으로 중단시킴으로써 공격 대상지인 서버가 대기 상태에 놓여 정상적인 서비스를 수행하지 못하게 하는 공격 방법임 | SYN Flooding에 대비하기 위해 수신지의 ‘SYN’ 수신 대기 시간을 줄이거나 침입 차단 시스템을 활용함 | . 5. TearDrop . 데이터의 송.수신 과정에서 패킷의 크기가 커 여러 개로 분할되어 전송될 때 분할 순서를 알 수 있도록 Fragment Offset 값을 함께 전송하는데, TearDrop은 이 Offset 값을 변경시켜 수신 측에서 패킷을 재조립할 때 오류로 인한 과부하를 발생시킴으로써 시스템이 다운되도록 하는 공격 방법임 | TearDrop에 대비하기 위해 Fragment Offset이 잘못된 경우 해당 패킷을 폐기하도록 설정함 | . 6. LAND Attack(Local Area Network Denial Attack) . 패킷을 전송할 때 송신 IP 주소와 수신 IP 주소를 모두 공격 대상의 IP 주소로 하여 공격 대상에게 전송하는 것으로, 이 패킷을 받은 공격 대상은 송신 IP 주소가 자신이므로 자신에게 응답을 수행하게 되는데, 이러한 패킷이 계속해서 전송될 경우 자신에 대해 무한히 응답하게 하는 공격임 | LAND Attack에 대비하기 위해 송신 IP 주소와 수신 IP 주소의 적절성을 검사함 | . 7. DDoS(Distributed Denial of Service, 분산 서비스 거부) 공격 . 여러 곳에 분산된 공격 지점에서 한 곳의 서버에 대해 분산 서비스 공격을 수행하는 것 | 네트워크에서 취약점이 있는 호스트들을 탐색한 후 이들 호스트들에 분산 서비스 공격용 툴을 설치하 에이전트로 만든 후 DDoS 공격에 이용함 | 분산 서비스 공격용 툴: 에이전트의 역할을 수행하도록 설계된 프로그램으로 데몬이라고 부르며, 다음과 같은 종류가 있음 Trin00: 가장 초기 형태의 데몬으로, 주로 UDP Flooding 공격을 수행함 | TFN(Tribe Flood Netword): UDP Flooding 뿐만 아니라 TCP SYN Flood 공격, ICMP 응답 요청, 스머핑 공격 등을 수행함 | TFN2K: TFN의 확장판 | Stacheldraht 이전 툴들의 기능을 유지하면서, 공격자, 마스터, 에이전트가 쉽게 노출되지 않도록 암호화된 통신을 수행함 | 툴이 자동으로 업데이트됨 | . | . | . 8. 네트워크 침해 공격 관련 용어 . 스미싱(Smishing) 문자 메시지를 이용해 사용자의 개인 신용 정보를 빼내는 수법 | 초기에는 문자 메시지를 이용해 개인 비밀정보나 소액 결제를 유도하는 형태로 시작되었음 | 현재는 각종 행사 안내, 경품 안내 등의 문자 메시지에 링크를 걸어 안드로이드 앱 설치 파일인 apk 파일을 설치하도록 유도하여 사용자 정보를 빼가는 수법으로 발전하고 있음 | . | 스피어 피싱(Spear Phishing) 사회 공학의 한 기법으로, 특정 대상을 선정한 후 그 대상에게 일반적인 이메일로 위장한 메일을 지속적으로 발송하여, 발송 메일의 본문 링크나 첨부된 파일을 클릭하도록 유도해 사용자의 개인 정보를 탈취함 | . | APT(Advanced Persistent Threats, 지능형 지속 위협) 다양한 IT 기술과 방식들을 이용해 조직적으로 특정 기업이나 조직 네트워크에 침투해 활동 거점을 마련한 뒤 때를 기다리면서 보안을 무력화시키고 정보를 수집한 다음 외부로 빼돌리는 형태의 공격 | 공격 방법 내부자에게 악성코드가 포함된 이메일을 오랜 기간 동안 꾸준히 발송해 한 번이라도 클릭되길 기다리는 형태 | 스턱스넷과 같이 악성코드가 담긴 이동식 디스크 등으로 전파하는 형태 | 악성코드에 감염된 P2P 사이트에 접속하면 악성코드에 감염되는 형태 등 | . | 무작위 대입 공격(Brute Force Attack) 암호화된 문서의 암호키를 찾아내기 위해 적용 가능한 모든 값을 대입하여 공격하는 방식 | . | 큐싱(Qshing) QR코드(Quick Response Code)를 통해 악성 앱의 다운로드를 유도하거나 악성 프로그램을 설치하도록 하는 금융사기 기법의 하나로, QR코드와 개인정보 및 금융정보를 낚는다는 의미의 합성 신조어 | . | SQL 삽입(Injection) 공격 전문 스캐너 프로그램 혹은 봇넷 등을 이용해 웹사이트를 무차별적으로 공격하는 과정에서 취약한 사이트가 발견되면 데이터베이스 등의 데이터를 조작하는 일련의 공격 방식 | . | 크로스 사이트 스크립팅(XSS: Cross Site Scripting) 네트워크를 통한 컴퓨터 보안 공격의 하나로, 웹 페이지의 내용을 사용자 브라우저에 표현하기 위해 사용되는 스크립트의 취약점을 악용한 해킹 기법 | 사용자가 특정 게시물이나 이메일의 링크를 클릭하면 악성 스크립트가 실행되어 페이지가 깨지거나, 사용자의 컴퓨터에 있는 로그인 정보나 개인 정보, 내부 자료 등이 해커에게 전달됨 | . | 스니핑(Sniffing) 네트워크의 중간에서 남의 패킷 정보를 도청하는 해킹 유형의 하나로 수동적 공격에 해당함 | . | . | . 9. 정보 보안 침해 공격 관련 용어 . 좀비(Zombie) PC 악성코드에 감염되어 다른 프로그램이나 컴퓨터를 조종하도록 만들어진 컴퓨터로, C&amp;C(Command&amp;Control) 서버의 제어를 받아 주로 DDoS 공격 등에 이용됨 | . | C&amp;C 서버 해커가 원격지에서 감염된 좀비 PC에 명령을 내리고 악성코드를 제어하기 위한 용도로 사용하는 서버를 말함 | . | 봇넷(Botnet) 악성 프로그램에 감염되어 악의적인 의도로 사용될 수 있는 다수의 컴퓨터들이 네트워크로 연결된 형태를 말함 | . | 웜(Worm) 네트워크를 통해 연속적으로 자신을 복제하여 시스템의 부하를 높임으로써 결국 시스템을 다운시키는 바이러스의 일종으로, 분산 서비스 공격, 버퍼 오버플로 공격, 슬래머 등이 웜 공격의 한 형태임 | . | 제로 데이 공격(Zero Day Attack) 보안 취약점이 발견되었을 때 발견된 취약점의 존재 자체가 널리 공표되기도 전에 해당 취약점을 통하여 이루어지는 보안 공격으로, 공격의 신속성을 의미함 | . | 키로거 공격(Key Logger Attack) 컴퓨터 사용자의 키보드 움직임을 탐지해 ID, 패스워드, 계좌번호, 카드번호 등과 같은 개인의 중요한 정보를 몰래 빼가는 해킹 공격 | . | 랜섬웨어(Ransomware) 인터넷 사용자의 컴퓨터에 잠입해 내부 문서나 파일 등을 암호화해 사용자가 열지 못하게 하는 프로그램으로, 암호 해독용 프로그램의 전달을 조건으로 사용자에게 돈을 요구하기도 함 | . | 백도어(Back Door, Trap Door) 시스템 설계자가 서비스 기술자나 유지 보수 프로그램 작성자의 액세스 편의를 위해 시스템 보안을 제거하여 만들어놓은 비밀 통로로, 컴퓨터 범죄에 악용되기도 함 | 백도어 탐지 방법: 무결성 검사, 열림 포트 확인, 로그 분석, SetUID 파일 검사 등 | . | 트로이 목마(Trojan Horse) 정상적인 기능을 하는 프로그램으로 위장하여 프로그램 내에 숨어 있다가 해당 프로그램이 동작할 때 활성화되어 부작용을 일으키는 것으로, 자기 복제 능력은 없음 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/07/23/theory143.html",
            "relUrl": "/theory/2021/07/23/theory143.html",
            "date": " • Jul 23, 2021"
        }
        
    
  
    
        ,"post76": {
            "title": "암호 알고리즘",
            "content": "1. 암호 알고리즘 . 패스워드, 주민번호, 은행계좌와 같은 중요 정보를 보호하기 위해 평문을 암호화된 문장으로 만드는 절차 또는 방법을 의미 | 암호 방식 분류 | . . 2. 개인키 암호화(Private Key Encryption) 기법 . 동일한 키로 데이터를 암호화하고 복호화하는 암호화 기법임 | 대칭 암호 기법 또는 단일키 암호화 기법이라고도 함 | 암호화/복호화 속도가 빠르지만, 관리해야 할 키의 수가 많음 | 종류 스트림 암호 방식 평문과 동일한 길이의 스트림을 생성하여 비트 단위로 암호화하는 방식 | 종류: LFSR, RC4 | . | 블록 암호화 방식 한 번에 하나의 데이터 블록을 암호화하는 방식 | 종류: DES, SEED, AES, ARIA | . | . | . 3. 공개키 암호화(Public Key Encryption) 기법 . 데이터를 암호화할 때 사용하는 공개키는 사용자에게 공개하고, 복호화할 때의 비밀키는 관리자가 비밀리에 관리하는 암호화 기법 | 비대칭 암호 기법이라고도 함 | 관리해야 할 키의 수가 적지만, 암호화/복호화 속도가 느림 | 대표적으로는 RSA(Rivest Shamir Adleman) 기법이 있음 | . 4. 양방향 알고리즘의 종류 . SEED 1999년 한국인터넷진흥원에서 개발한 블록 암호화 알고리즘 | 블록 크기는 128비트이며, 키 길이에 따라 128, 256으로 분류됨 | . | ARIA(Academy, Research Institute, Agency) 2004년 국가정보원과 산학연협회가 개발한 블록 암호화 알고리즘 | . | DES(Data Encryption Standard) 1975년 미국 NBS에서 발표한 개인키 암호화 알고리즘 | DES를 3번 적용하여 보안을 더욱 강화한 3DES(Triple DES)도 있음 | . | AES(Advanced Encryption Standard) 2001년 미국 표준 기술 연구소(NIST)에서 발표한 개인키 암호화 알고리즘 | DES의 한계를 느낀 NIST에서 공모한 후 발표 | . | RSA(Rivest Shamir Adleman) 1978년 MIT의 라이베스트, 샤미르, 애들먼에 의해 제안된 공개키 암호화 알고리즘 | 큰 숫자를 소인수분해 하기 어렵다는 것에 기반하여 만들어짐 | . | . 5. 해시(Hash) . 임의의 길이의 입력 데이터나 메시지를 고정된 길이의 값이나 키로 변환하는 것을 의미 | 해시 알고리즘을 해시 함수라고 부르며, 해시 함수로 변환된 값이나 키를 해시값 또는 해시키라고 부름 | 데이터의 암호화, 무결성 검증을 위해 사용될 뿐만 아니라 정보보호의 다양한 분야에서 활용됨 | 해시 함수의 종류 SHA 시리즈 1993년 미국 국가안보국이 설계, 미국 국립표준기술연구소에 의해 발표됨 | 초기 개발된 SHA-0 이후 SHA-1이 발표되었고, 다시 SHA-2라고 불리는 SHA-224, SHA-256, SHA-384, SHA-512가 발표됨 | . | MD5(Message Digest algorithm 5) 1991년 R.Rivest가 MD4를 대체하기 위해 고안한 암호화 해시 함수 | 블록 크기가 512비트이며, 키 길이는 128비트임 | . | N-NASH 1989년 일본의 전신전화주식회사에서 발표한 암호화 해시 함수 | 블록 크기와 키 길이가 모두 128비트임 | . | SNEFRU 1990년 R.C.Merkle가 발표한 해시 함수 | 32비트 프로세서에서 구현을 용이하게 할 목적으로 개발됨 | . | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/07/22/theory142.html",
            "relUrl": "/theory/2021/07/22/theory142.html",
            "date": " • Jul 22, 2021"
        }
        
    
  
    
        ,"post77": {
            "title": "API 오용",
            "content": "1. API 오용 . 소프트웨어 구현 단계에서 API를 잘못 사용하거나 보안에 취약한 API를 사용하지 않도록 하기 위한 보안 점검 항목들임 | 보안 약점 DNS Lookup에 의존한 보안 결정 도메인명에 의존하여 인증이나 접근 통제 등의 보안 결정을 내리는 경우 발생하는 보안 약점 | DNS 검색을 통해 도메인 이름을 비교하지 않고 IP 주소를 직접 입력하여 접근함으로써 방지할 수 있음 | . | 취약한 API 사용 보안 문제로 사용이 금지된 API를 사용하거나, 잘못된 방식으로 API를 사용했을 때 발생하는 보안 약점 | 보안 문제로 금지된 함수는 안전한 함수로 대체하고, API의 메뉴얼을 참고하여 보안이 보장되는 인터페이스를 사용함으로써 방지할 수 있음 | . | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/07/21/theory141.html",
            "relUrl": "/theory/2021/07/21/theory141.html",
            "date": " • Jul 21, 2021"
        }
        
    
  
    
        ,"post78": {
            "title": "캡슐화",
            "content": "1. 캡슐화 . 정보 은닉이 필요한 중요한 데이터와 기능을 불완전하게 캡슐화하거나 잘못 사용함으로써 발생할 수 있는 문제를 예방하기 위한 보안 점검 항목들임 . | 보안 약점 . 잘못된 세션에 의한 정보 노출 다중 스레드 환경에서 멤버 변수에 정보를 저장할 때 발생하는 보안 약점 | 멤버 변수보다 지역 변수를 활용하여 변수의 범위를 제한함으로써 방지할 수 있음 | . | 제거되지 않고 남은 디버그 코드 개발 중에 버그 수정이나 결과값 확인을 위해 남겨둔 코드들로 인해 발생하는 보안 약점 | 소프트웨어 배포 전에 코드 검사를 수행하여 남아있는 디버그 코드를 삭제함으로써 방지할 수 있음 | . | 시스템 데이터 정보 노출 시스템의 내부 정보를 시스템 메시지 등을 통해 외부로 출력하도록 코딩했을 때 발생하는 보안 약점 | 노출되는 메시지에는 최소한의 정보만을 제공함으로써 방지할 수 있음 | . | Public 메소드로부터 반환된 Private 배열 선언된 클래스 내에서만 접근이 가능한 Private 배열을 모든 클래스에서 접근이 가능한 Public 메소드에서 반환할 때 발생하는 보안 약점 | Private 배열을 별도의 메소드를 통해 조작하거나, 동일한 형태의 복제본으로 반환받은 후 값을 전달하는 방식으로 방지할 수 있음 | . | Private 배열에 Public 데이터 할당 Private 배열에 Public으로 선언된 데이터 또는 메소드의 파라미터를 저장할 대 발생하는 보안 약점 | Public으로 선언된 데이터를 Private 배열에 저장할 때, 레퍼런스가 아닌 값을 직접 저장함으로써 방지할 수 있음 | . | . 2. 접근 제어자 . 프로그래밍 언어에서 특정 개체를 선언할 때 외부로부터의 접근을 제한하기 위해 사용되는 예약어 . | 접근 제어자의 종류(접근 가능: O, 접근 불가능: X) . 접근 제어자 클래스 내부 패키지 내부 하위 클래스 패키지 외부 . Public | O | O | O | O | . Protected | O | O | O | X | . Default | O | O | X | X | . Private | O | X | X | X | . | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/07/20/theory140.html",
            "relUrl": "/theory/2021/07/20/theory140.html",
            "date": " • Jul 20, 2021"
        }
        
    
  
    
        ,"post79": {
            "title": "코드 오류",
            "content": "1. 코드 오류 . 소프트웨어 구현 단계에서 개발자들이 코딩 중 실수하기 쉬운 형변환, 자원 반환 등의 오류를 예방하기 위한 보안 점검 항목들임 | 보안 약점 널 포인터 역참조 널 포인터가 가리키는 메모리의 위치에 값을 저장할 때 발생하는 보안 약점 | 포인터를 이용하기 전에 널 값을 갖고 있는지 검사함으로써 방지할 수 있음 | . | 부적절한 자원 해제 자원을 반환하는 코드를 누락하거나 프로그램 오류로 할당된 자원을 반환하지 못했을 때 발생하는 보안 약점 | 프로그램 내에 자원 반환 코드가 누락되었는지 확인하고, 오류로 인해 함수가 중간에 종료되었을 때 예외처리에 관계없이 자원이 반환되도록 코딩함으로써 방지할 수 있음 | . | 해제된 자원 사용 이미 사용이 종료되어 반환된 메모리를 참조하는 경우 발생하는 보안 약점 | 반환된 메모리에 접근할 수 없도록 주소를 저장하고 있는 포인터를 초기화함으로써 방지할 수 있음 | . | 초기화되지 않은 변수 사용 변수 선언 후 값이 부여되지 않은 변수를 사용할 때 발생하는 보안 약점 | 변수 선언 시 할당된 메모리를 초기화함으로써 방지할 수 있음 | . | . | . 2. 스택 가드 . 널 포인터 역참조와 같이 주소가 저장되는 스택에서 발생하는 보안 약점을 막는 기술 중 하나임 | 메모리상에서 프로그램의 복귀 주소와 변수 사이에 특정 값을 저장한 후 그 값이 변경되었을 경우 오버플로우 상태로 판단하여 프로그램 실행을 중단함으로써 잘못된 복귀 주소의 호출을 막음 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/07/19/theory139.html",
            "relUrl": "/theory/2021/07/19/theory139.html",
            "date": " • Jul 19, 2021"
        }
        
    
  
    
        ,"post80": {
            "title": "에러처리",
            "content": "1. 에러처리 . 소프트웨어 실행 중 발생할 수 있는 오류들을 사전에 정의하여 오류로 인해 발생할 수 있는 문제들을 예방하기 위한 보안 점검 항목들임 | 보안 약점 오류 메시지를 통한 정보노출 오류 발생으로 실행 환경, 사용자 정보, 디버깅 정보 등의 중요한 정보가 메시지를 통해 외부에 노출되는 보안 약점 | 가능한 한 내부에서만 처리되도록 하거나 메시지를 출력할 경우 최소한의 정보 또는 사전에 준비된 메시지만 출력되도록 하여 방지할 수 있음 | . | 오류 상황 대응 부재 소프트웨어 개발 중 에러처리를 하지 않았거나 미비로 인해 발생하는 보안 약점 | 오류가 발생할 수 있는 부분에 에러처리 구문을 작성하고, 제어문을 활용하여 오류가 악용되지 않도록 코딩함으로써 방지할 수 있음 | . | 부적절한 예외처리 함수의 반환값 또는 오류들을 세분화하여 처리하지 않고 광범위하게 묶어 한 번에 처리하거나, 누락된 예외가 존재할 때 발생하는 보안 약점 | 모든 함수의 반환값이 의도대로 출력되는지 확인하고, 세분화된 예외처리를 수행함으로써 방지할 수 있음 | . | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/07/18/theory138.html",
            "relUrl": "/theory/2021/07/18/theory138.html",
            "date": " • Jul 18, 2021"
        }
        
    
  
    
        ,"post81": {
            "title": "시간 및 상태",
            "content": "1. 시간 및 상태 . 동시 수행을 지원하는 병렬 처리 시스템이나 다수의 프로세스가 동작하는 환경에서 시간과 실행 상태를 관리하여 시스템이 원활하게 동작되도록 하기 위한 보안 점검 항목들임 . | 보안 약점 . TOCTOU 경쟁 조건 . 검사 시점(Time Of Check)과 사용 시점(Time Of Use)을 고려하지 않고 코딩하는 경우 발생하는 보안 약점 | 코드 내에 동기화 구문을 사용하여 해당 자원에는 한 번에 하나의 프로세스만 접근 가능하도록 구성함으로써 방지할 수 있음 | . | 종료되지 않는 반복문 또는 재귀 함수 . 반복문이나 재귀 함수에서 종료 조건을 정의하지 않았거나 논리 구조상 종료될 수 없는 경우 발생하는 보안 약점 | 모든 반복문이나 재귀 함수의 수행 횟수를 제한하는 설정을 추가하거나, 종료 조건을 점검하여 반복 또는 호출의 종료 여부를 확인함으로써 방지할 수 있음 | . | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/07/17/theory137.html",
            "relUrl": "/theory/2021/07/17/theory137.html",
            "date": " • Jul 17, 2021"
        }
        
    
  
    
        ,"post82": {
            "title": "보안 기능",
            "content": "1. 보안 기능 . 소프트웨어 개발의 구현 단계에서 코딩하는 기능인 인증, 접근 제어, 기밀성, 암호화 등을 올바르게 구현하기 위한 보안 점검 항목들임 . | 보안 약점 . 적절한 인증 없이 중요기능 허용 . 보안검사를 우회하여 인증과정 없이 중요한 정보 또는 기능에 접근 및 변경이 가능함 | 중요정보나 기능을 수행하는 페이지에서는 재인증 기능을 수행하도록 하여 방지할 수 있음 | . | 부적절한 인가 . 접근제어 기능이 없는 실행경로를 통해 정보 또는 권한을 탈취할 수 있음 | 모든 실행경로에 대해 접근제어 검사를 수행하고, 사용자에게는 반드시 필요한 접근 권한만을 부여하여 방지할 수 있음 | . | 중요한 자원에 대한 잘못된 권한 설정 . 권한 설정이 잘못된 자원에 접근하여 해당 자원을 임의로 사용할 수 있음 | 소프트웨어 관리자만 자원들을 읽고 쓸 수 있도록 설정하고, 인가되지 않은 사용자의 중요 자원에 대한 접근 여부를 검사함으로써 방지할 수 있음 | . | 취약한 암호화 알고리즘 사용 . 암호화된 환경설정 파일을 해독하여 비밀번호 등의 중요정보를 탈취할 수 있음 | 안전한 암호화 알고리즘을 이용하고, 업무관련 내용이나 개인 정보 등에 대해서는 IT 보안인증사무국이 안정성을 확인한 암호모듈을 이용함으로써 방지할 수 있음 | . | 중요정보 평문 저장 및 전송 . 암호화되지 않은 평문 데이터를 탈취하여 중요한 정보를 획득할 수 있음 | 중요한 정보를 저장하거나 전송할 때는 반드시 암호화 과정을 거치도록 하고, HTTPS 또는 SSL과 같은 보안 채널을 이용함으로써 방지할 수 있음 | . | 하드코드된 암호화 키 . 암호화된 키도 하드코드된 경우 유출 시 역계산 또는 무차별 대입 공격에 의해 탈취될 수 있음 | 상수 형태의 암호키를 사용하지 않고, 암호화 키 생성 모듈 또는 보안이 보장된 외부 공간을 이용함으로써 방지할 수 있음 | . | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/07/16/theory136.html",
            "relUrl": "/theory/2021/07/16/theory136.html",
            "date": " • Jul 16, 2021"
        }
        
    
  
    
        ,"post83": {
            "title": "입력 데이터 검증 및 표현",
            "content": "1. 입력 데이터 검증 및 표현 . 입력 데이터로 인해 발생하는 문제들을 예방하기 위해 구현 단계에서 검증해야 하는 보안 점검 항목들임 | 보안 약점 SQL 삽입(Injection) 웹 응용 프로그램에 SQL을 삽입하여 내부 데이터베이스(DB) 서버의 데이터를 유출 및 변조하고, 관리자 인증을 우회하는 보안 약점 | 동적 쿼리에 사용되는 입력 데이터에 예약어 및 특수문자가 입력되지 않게 필터링 되도록 설정하여 방지할 수 있음 | . | 경로 조작 및 자원 삽입 데이터 입출력 경로를 조작하여 서버 자원을 수정.삭제할 수 있는 보안 약점 | 사용자 입력값을 식별자로 사용하는 경우, 경로 순회 공격을 막는 필터를 사용하여 방지할 수 있음 | . | 크로스사이트 스크립팅(XSS) 웹페이지에 악의적인 스크립트를 삽입하여 방문자들의 정보를 탈취하거나, 비정상적인 기능 수행을 유발하는 보안 약점 | HTML 태그의 사용을 제한하거나 스크립트에 삽입되지 않도록 ‘&lt;’, ‘&gt;’, ‘&amp;’ 등의 문자를 다른 문자로 치환함으로써 방지할 수 있음 | . | 운영체제 명령어 삽입 외부 입력값을 통해 시스템 명령어의 실행을 유도함으로써 권한을 탈취하거나 시스템 장애를 유발하는 보안 약점 | 웹 인터페이스를 통해 시스템 명령어가 전달되지 않도록 하고, 외부 입력값을 검증 없이 내부 명령어로 사용하지 않음으로써 방지할 수 있음 | . | 위험한 형식 파일 업로드 악의적인 명령어가 포함된 스크립트 파일을 업로드함으로써 시스템에 손상을 주거나, 시스템을 제어할 수 있는 보안 약점 | 업로드 되는 파일의 확장자 제한, 파일명의 암호화, 웹사이트와 파일 서버의 경로 분리, 실행 속성을 제거하는 등의 방법으로 방지할 수 있음 | . | 신뢰되지 않는 URL 주소로 자동접속 연결 입력 값으로 사이트 주소를 받는 경우 이를 조작하여 방문자를 피싱 사이트로 유도하는 보안 약점 | 연결되는 외부 사이트의 주소를 화이트 리스트로 관리함으로써 방지할 수 있음 | . | 메모리 버퍼 오버플로 연속된 메모리 공간을 사용하는 프로그램에서 할당된 메모리의 범위를 넘어선 위치에서 자료를 읽거나 쓰려고 할 때 발생하는 보안 약점 | 메모리 버퍼를 사용할 경우 적절한 버퍼의 크기를 설정하고, 설정된 범위의 메모리 내에서 올바르게 읽거나 쓸 수 있도록 함으로써 방지할 수 있음 | . | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/07/15/theory135.html",
            "relUrl": "/theory/2021/07/15/theory135.html",
            "date": " • Jul 15, 2021"
        }
        
    
  
    
        ,"post84": {
            "title": "세션 통제",
            "content": "1. 세션 통제 . 세션의 연결과 연결로 인해 발생하는 정보를 관리하는 것을 의미 | 소프트웨어 개발 과정 중 요구사항 분석 및 설계 단계에서 진단해야 하는 보안 점검 내용임 | 세션 통제의 보안 약점 불충분한 세션 관리 일정한 규칙이 존재하는 세션ID가 발급되거나 타임아웃이 너무 길게 설정되어 있는 경우 발생하는 보안 약점 | . | 잘못된 세션에 의한 정보 노출 다중 스레드 환경에서 멤버 변수에 정보를 저장할 때 발생하는 보안 약점 | . | . | . 2. 세션 설계 시 고려 사항 . 시스템의 모든 페이지에서 로그아웃이 가능하도록 UI를 구성함 | 로그아웃 요청 시 할당된 세션이 완전히 제거되도록 함 | 세션 타임아웃은 중요도가 높으면 2~5분, 낮으면 15~30분으로 설정함 | 이전 세션이 종료되지 않으면 새 세션이 생성되지 못하도록 설계함 | 중복 로그인을 허용하지 않은 경우 클라이언트의 중복 접근에 대한 세션 관리 정책을 수립함 | . 3. 세션ID의 관리 방법 . 안전한 서버에서 최소 128비트의 길이로 생성함 | 예측이 불가능하도록 안전한 난수 알고리즘을 적용함 | 노출되지 않도록 URL Rewrite 기능을 사용하지 않는 방향으로 설계함 | 로그인 시 로그인 전의 세션ID를 삭제하고 재할당함 | 장기간 접속하고 있는 세션ID는 주기적으로 재할당되도록 설계함 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/07/14/theory134.html",
            "relUrl": "/theory/2021/07/14/theory134.html",
            "date": " • Jul 14, 2021"
        }
        
    
  
    
        ,"post85": {
            "title": "Secure SDLC",
            "content": "1. Secure SDLC . 보안상 안전한 소프트웨어를 개발하기 위해 SDLC에 보안 강화를 위한 프로세스를 포함한 것을 의미함 | 요구사항 분석, 설계, 구현, 테스트, 유지보수 등 SDLC 전체 단계에 걸쳐 수행되어야 할 보안 활동을 제시함 | 대표적인 방법론 CLASP: SDLC의 초기 단계에서 보안을 강화하기 위해 개발된 방법론 | SDL: 마이크로소프트 사에서 안전한 소프트웨어 개발을 위해 기존의 SDLC를 개선한 방법론 | Seven Touchpoints: 소프트웨어 보안의 모범사례를 SDLC에 통합한 방법론 | . | . 2. SDLC 단계별 보안 활동 . 요구사항 분석 단계 보안 항목에 해당하는 요구사항을 식별하는 작업을 수행 | . | 설계 단계 식별된 보안 요구사항들을 소프트웨어 설계서에 반영하고, 보안 설계서를 작성함 | . | 구현 단계 표준 코딩 정의서 및 소프트웨어 개발 보안 가이드를 준수하며, 설계서에 따라 보안 요구사항들을 구현함 | . | 테스트 단계 설계 단계에서 작성한 보안 설계서를 바탕으로 보안 사항들이 정확히 반영되고 동작되는지 점검함 | . | 유지보수 단계 이전 과정을 모두 수행하였음에도 발생할 수 있는 보안사고들을 식별함 | 사고 발생 시 이를 해결하고 보안 패치를 실시함 | . | 3. 소프트웨어 개발 보안 요소 . 기밀성 시스템 내의 정보와 자원은 인가된 사용자에게만 접근이 허용됨 | 정보가 전송 중에 노출되더라도 데이터를 읽을 수 없음 | . | 무결성 시스템 내의 정보는 오직 인가된 사용자만 수정할 수 있음 | . | 가용성 인가받은 사용자는 시스템 내의 정보와 자원을 언제라도 사용할 수 있음 | . | 인증 시스템 내의 정보와 자원을 사용하려는 사용자가 합법적인 사용자인지를 확인하는 모든 행위 | 대표적 방법: 패스워드, 인증용 카드, 지문 검사 등 | . | 부인 방지 데이터를 송.수신한 자가 송.수신 사실을 부인할 수 없도록 송.수신 증거를 제공 | . | . 4. 시큐어 코딩 . 구현 단계에서 발생할 수 있는 보안 취약점들을 최소화하기 위해 보안 요소들을 고려하며 코딩하는 것을 의미함 | 보안 취약점을 사전 대응하여 안정성과 신뢰성을 확보함 | 보안 정책을 바탕으로 시큐어 코딩 가이드를 작성하고, 개발 참여자에게는 시큐어 코딩 교육을 실시함 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/07/13/theory133.html",
            "relUrl": "/theory/2021/07/13/theory133.html",
            "date": " • Jul 13, 2021"
        }
        
    
  
    
        ,"post86": {
            "title": "쿼리 성능 최적화",
            "content": "1. 쿼리 성능 최적화 . 데이터 입.출력 애플리케이션의 성능 향상을 위해 SQL 코드를 최적화하는 것 | 쿼리 성능을 최적화하기 전에 성능 측정 도구인 APM을 사용하여 최적화할 쿼리를 선정해야 함 | 최적화 할 쿼리에 대해 옵티마이저가 수립한 실행 계획을 검토하고 SQL 코드와 인덱스를 재구성함 | . 2. 옵티마이저 . 작성된 SQL이 가장 효율적으로 수행되도록 최적의 경로를 찾아 주는 모듈 . | RBO(Rule Based Optimizer)와 CBO(Cost Based Optimizer) 두 종류가 있음 . | RBO는 데이터베이스 관리자(DBA)가 사전에 정의해둔 규칙에 의거하여 경로를 찾는 규칙 기반 옵티마이저임 . | CBO는 입.출력 속도, CPU 사용량, 블록 개수, 개체의 속성, 튜플 개수 등을 종합하여 각 DBMS마다 고유의 알고리즘에 따라 산출되는 ‘비용’으로 최적의 경로를 찾는 비용 기반 옵티마이저임 . | RBO와 CBO의 차이점 .   RBO CBO . 최적화 기준 | 규칙에 정의된 우선순위 | 액세스 비용 | . 성능 기준 | 개발자의 SQL 숙련도 | 옵티마이저의 예측 성능 | . 특징 | 실행 계획 예측이 쉬움 | 성능 통계치 정보 활용, 예측이 복잡함 | . 고려사항 | 개발자의 규칙 이해도, 규칙의 효율성 | 비용 산출 공식의 정확성 | . | . 3. 실행 계획 . DBMS의 옵티마이저가 수립한 SQL 코드의 실행 절차와 방법을 의미 | EXPLAIN 명령어를 통해 확인할 수 있으며, 그래픽이나 텍스트로 표현됨 | 실행 계획에는 요구사항들을 처리하기 위한 연산 순서가 적혀 있으며, 연산에는 조인, 테이블 검색, 필터, 정렬 등이 있음 | . 4. 쿼리 성능 최적화 방법 . 실행 계획에 표시된 연산 순서, 조인 방식, 테이블 조회 방법 등을 참고하여 SQL문이 더 빠르고 효율적으로 작동하도록 SQL 코드와 인덱스를 재구성하는 것을 의미함 | SQL 코드 재구성 WHERE 절 추가 | WHERE 절에 연산자 사용 제한 | IN을 EXISTS로 대체 | 힌트로 액세스 경로 및 조인 순서 변경 | . | 인덱스 재구성 조회되는 속성과 조건을 고려하여 인덱스 구성 | 인덱스 추가 및 기존 인덱스의 열 순서 변경 | 테이블을 참조하는 다른 SQL문으로의 영향 고려 | IOT(Index-Organized Table) 구성 고려 | 불필요한 인덱스 제거 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/07/12/theory132.html",
            "relUrl": "/theory/2021/07/12/theory132.html",
            "date": " • Jul 12, 2021"
        }
        
    
  
    
        ,"post87": {
            "title": "ORM(Object-Relational Mapping)",
            "content": "1. ORM(Object-Relational Mapping) . 객체지향 프로그래밍의 객체와 관계형 데이터베이스의 데이터를 연결하는 기술을 의미 | 객체지향 프로그래밍에서 사용할 수 있는 가상의 객체지향 데이터베이스를 만들어 프로그래밍 코드와 데이터를 연결함 | ORM으로 생성된 가상의 객체지향 데이터베이스는 프로그래밍 코드 또는 데이터베이스와 독립적이므로 재사용 및 유지보수가 용이함 | . 2. ORM 프레임워크 . ORM을 구현하기 위한 구조와 구현을 위해 필요한 여러 기능들을 제공하는 소프트웨어를 의미함 . | 종류 . | 기반 언어 orm 프레임워크 . Java | JPA, Hibernate, EclipseLink, DataNucleus, Ebean 등 | . C++ | ODM, QxOrm 등 | . Python | Django, SQLAlchemy, Storm 등 | . .NET | NHibernate, DatabaseObjects, Dapper 등 | . PHP | Doctrine, Propel, RedBean 등 | . | . 3. ORM의 한계 . 프레임워크가 자동으로 SQL을 작성하기 때문에 의도대로 SQL이 작성되었는지 확인해야 함 | 객체지향적인 사용을 고려하고 설계된 데이터베이스가 아닌 경우 프로젝트가 크고 복잡해질수록 ORM 기술을 적용하기 어려움 | 기존의 기업들은 ORM을 고려하지 않은 데이터베이스를 사용하고 있기 때문에 ORM에 적합하게 변환하려면 많은 시간과 노력이 필요함 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/07/11/theory131.html",
            "relUrl": "/theory/2021/07/11/theory131.html",
            "date": " • Jul 11, 2021"
        }
        
    
  
    
        ,"post88": {
            "title": "SQL 테스트",
            "content": "1. SQL 테스트 . SQL이 작성 의도에 맞게 원하는 기능을 수행하는지 검증하는 과정 | 단문 SQL은 SQL 코드를 직접 실행한 후 결과를 확인하는 것으로, 간단히 테스트가 가능함 | 절차형 SQL은 테스트 전에 생성을 통해 구문 오류나 참조 오류의 존재 여부를 확인함 | 정상적으로 생성된 절차형 SQL은 디버깅을 통해 로직을 검증하고, 결과를 통해 최종적으로 확인함 | . 2. 단문 SQL 테스트 . DDL, DML, DCL이 포함되어 있는 SQL과 TCL을 테스트하는 것으로, 직접 실행하여 결과물을 확인함 | DDL로 작성된 개체는 DESCRIBE 명령어를 이용하여 속성, 자료형, 옵션들을 확인할 수 있음 DESC [개체명]; | . | DML로 변경한 데이터는 SELECT문으로 데이터의 정상적인 변경 여부를 확인할 수 있음 | DCL로 설정된 사용자 권한은 사용자 권한 정보가 저장된 테이블을 조회하여 확인할 수 있음 | MySQL에서 테이블의 정보를 확인하는 SQL문을 작성하시오. | DESC 학생; | . 3. 절차형 SQL 테스트 . 프로시저, 사용자 정의 함수, 트리거 등의 절차형 SQL은 디버깅을 통해 기능의 적합성 여부를 검증하고, 실행을 통해 결과를 확인하는 테스트를 수행함 | 많은 코드로 구성된 절차형 SQL의 특성상 오류 및 경고 메시지가 상세히 출력되지 않으므로 SHOW 명령어를 통해 오류 내용을 확인하고 문제를 수정함 형식: SHOW ERRORS; | . | 데이터베이스에 변화를 줄 수 있는 SQL문은 주석으로 처리하고, 출력문을 이용하여 화면에 출력하여 확인함 | 디버깅이 완료되면 출력문을 삭제하고, 주석 기호를 삭제한 후 절차형 SQL을 실행하여 결과를 검토함 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/07/10/theory130.html",
            "relUrl": "/theory/2021/07/10/theory130.html",
            "date": " • Jul 10, 2021"
        }
        
    
  
    
        ,"post89": {
            "title": "DBMS 접속",
            "content": "1. DBMS 접속 . 사용자가 데이터를 사용하기 위해 응용 시스템을 이용하여 DBMS에 접근하는 것을 의미 | 응용 시스템은 사용자로부터 매개 변수를 전달받아 SQL을 실행하고 DBMS로부터 전달받은 결과를 사용자에게 전달하는 매개체 역할을 수행함 | 인터넷을 통해 구동되는 웹 응용 프로그램은 웹 응용 시스템을 통해 DBMS에 접근함 | 웹 응용 시스템은 웹 서버와 웹 애플리케이션 서버(WAS)로 구성됨 | . 2. DBMS 접속 기술 . DBMS에 접근하기 위해 사용하는 API 또는 API의 사용을 편리하게 도와주는 프레임워크 등을 의미함 . | 종류 . | 접속 기술 특징 . JDBC(Java DataBase Connectivity) | -Java 언어로 다양한 종류의 데이터베이스에 접속할 때 사용하는 표준 API-1997년 2월 썬 마이크로시스템에서 출시-접속하려는 DBMS에 대한 드라이버가 필요함 | . ODBC(Open DataBase Connectivity) | -개발 언어에 관계없이 데이터베이스에 접근하기 위한 표준 개방형 API-1992년 9월 마이크로소프트에서 출시-접속하려는 DBMS의 인터페이스에 관계없이 ODBC 문장을 사용하여 접속이 가능함 | . MyBatis | -JDBC 코드를 단순화하여 사용할 수 있는 SQL Mapping 기반 오픈 소스 접속 프레임워크-SQL 문장을 분리하여 XML 파일을 만들고, Mapping을 통해 SQL을 실행함 | . | . 3. 동적 SQL(Dynamic SQL) . 다양한 조건에 따라 SQL 구문을 동적으로 변경하여 처리할 수 있는 SQL 처리 방식임 | 사용자로부터 SQL문의 일부 또는 전부를 입력받아 실행할 수 있음 | 응용 프로그램 수행 시 SQL이 변형될 수 있으므로 프리컴파일할 때 구문 분석, 접근 권한 확인 등을 할 수 없음 | 정적 SQL에 비해 속도가 느리지만, 상황에 따라 다양한 조건을 첨가하는 등 유연한 개발이 가능함 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/07/09/theory129.html",
            "relUrl": "/theory/2021/07/09/theory129.html",
            "date": " • Jul 9, 2021"
        }
        
    
  
    
        ,"post90": {
            "title": "커서",
            "content": "1. 커서 . 쿼리문의 처리 결과가 저장되어 있는 메모리 공간을 가리키는 포인터 | 커서의 수행은 열기, 패치, 닫기의 세 단계로 진행됨 | . 2. 묵시적 커서 . DBMS에 의해 내부에서 자동으로 생성되어 사용되는 커서 | 커서의 속성을 조회하여 사용된 쿼리 정보를 열람하는 것이 가능함 | 수행된 쿼리문의 정상적인 수행 여부를 확인하기 위해 사용됨 | 속성의 종류 SQL%FOUND: 쿼리 수행의 결과로 패치된 튜플 수가 1개 이상이면 TRUE | SQL%NOTFOUND: 쿼리 수행의 결과로 패치된 튜플 수가 0개이면 TRUE | SQL%ROWCOUNT: 쿼리 수행의 결과로 패치된 튜플 수를 반환 | SQL%ISOPEN: 커서가 열린 상태이면 TRUE. 묵시적 커서는 자동으로 생성된 후 자동으로 닫히기 때문에 항상 FALSE | . | . 3. 명시적 커서 . 사용자가 직접 정의해서 사용하는 커서 . | 쿼리문의 결과를 저장하여 사용함으로써 동일한 쿼리가 반복 수행되어 데이터베이스 자원이 낭비되는 것을 방지함 . | 커서는 기본적으로 ‘열기-패치-닫기’ 순으로 이루어지며, 명시적 커서를 사용하기 위해서는 열기 단계 전에 선언해야 함 . | 선언 형식 . | . CURSOR 커서명(매개변수1, 매개변수2, …) IS SELECT 문; . 열기 형식 . OPEN 커서명(매개변수1, 매개변수2, …); . | 패치 형식 . FETCH 커서명 INTO 변수1, 변수2, …; . | 닫기 형식 . CLOSE 커서명; . | 다음은 테이블로부터 id가 20보다 크거나 같은 튜플의 name을 출력하는 절차형 SQL을 PL/SQL로 구현한 것임 . | DECLARE p_name employee.name%TYPE; CURSOR cur_name(ff INT) IS SELECT name FROM employee WHERE id &gt;= ff; . BEGIN . ​ OPEN cur_name(20); ​ LOOP ​ FETCH cur_name INTO p_name; ​ EXIT WHEN cur_name%NOTFOUND; ​ DBMS_OUTPUT.PUT_LINE(p_name); ​ END LOOP; ​ CLOSE cur_name; END; . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/07/08/theory128.html",
            "relUrl": "/theory/2021/07/08/theory128.html",
            "date": " • Jul 8, 2021"
        }
        
    
  
    
        ,"post91": {
            "title": "제어문",
            "content": "1. 제어문 . 위에서 아래로 차례대로 실행되는 절차형 SQL의 진행 순서를 변경하기 위해 사용하는 명령문 | 제어문에는 IF, LOOP 등이 있음 | . 2. IF문 . 조건에 따라 실행할 문장을 달리하는 제어문 . | 형식1: 조건이 참일 때만 실행 . IF 조건 THEN 실행할 문장1; 실행할 문장2; … END IF; . | x가 10보다 크면 화면에 “true”를 출력하기 . | DECLARE x INT := 20; BEGIN IF x &gt; 10 THEN DBMS_OUTPUT.PUT_LINE(‘true’); END IF; END; . | 형식2: 조건이 참일 때와 거짓일 때 실행할 문장이 다름 . | IF 조건 THEN 실행할 문장1; ELSE 실행할 문장2; END IF; . | x가 10보다 크면 화면에 “true”를 출력하고, 아니면 “false”를 출력하기 . | DECLARE x INT := 10; BEGIN IF x &gt; 10 THEN DBMS_OUTPUT.PUT_LINE(‘true’); ELSE DBMS_OUTPUT.PUT_LINE(‘false’); END IF; END; . | . 3. LOOP문 . 조건에 따라 실행할 문장을 반복 수행하는 제어문 . | 형식 . LOOP 실행할 문장; EXIT WHEN 조건; END LOOP; . | 다음은 1부터 10까지 합을 구하는 절차형 SQL을 PL/SQL로 구현한 것임 . | DECLARE i INT := 0; i_sum INT := 0; BEGIN LOOP i := i+1; i_sum := i_sum + i; EXIT WHEN i &gt;=10; END LOOP; END; . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/07/07/theory127.html",
            "relUrl": "/theory/2021/07/07/theory127.html",
            "date": " • Jul 7, 2021"
        }
        
    
  
    
        ,"post92": {
            "title": "사용자 정의 함수",
            "content": "1. 사용자 정의 함수 . 프로시저와 유사하게 SQL을 사용하여 일련의 작업을 연속적으로 처리하지만, 종료 시 처리 결과로 단일값만을 반환하는 절차형 SQL임 | 데이터베이스에 저장되어 SELECT, INSERT, DELETE, UPDATE 등 DML문의 호출에 의해 실행됨 | 예약어 RETURN을 통해 단일값을 반환하며, 출력 파라미터가 없음 | . 2. 사용자 정의 함수의 구성도 . . DECLARE: 사용자 정의 함수의 명칭, 변수, 인수, 데이터 타입을 정의하는 선언부임 | BEGIN/END: 사용자 정의 함수의 시작과 종료를 의미함 | CONTROL: 조건문 또는 반복문이 삽입되어 순차적으로 처리됨 | SQL: SELECT문이 삽입되어 데이터 조회 작업을 수행함 | EXCEPTION: BEGIN~END 안의 구문 실행 시 예외가 발생하면 이를 처리하는 방법을 정의함 | RETURN: 호출 프로그램에 반환할 값이나 변수를 정의함 | . 3. 사용자 정의 함수 생성 . 사용자 정의 함수를 생성하기 위해서는 CREATE FUNCTION 명령어를 사용함 . | 표기 형식 . CREATE [OR REPLACE] FUNCTION 사용자 정의 함수명(파라미터) [지역변수 선언] BEGIN 사용자 정의 함수 BODY; RETURN 반환값; END; . | OR REPLACE: 선택적인 예약어임. 이 예약어를 사용하면 동일한 사용자 정의 함수의 이름이 이미 존재하는 경우, 기존의 사용자 정의 함수를 대체할 수 있음 . | 파라미터: 사용자 정의 함수의 파라미터로는 다음과 같은 것들이 올 수 있음 . IN: 호출 프로그램이 사용자 정의 함수에게 값을 전달할 대 지정함 | 매개변수명: 호출 프로그램으로부터 전달받은 값을 저장할 변수의 이름을 지정함 | 자료형: 변수의 자료형을 지정함 | . | 사용자 정의 함수 BODY . 사용자 정의 함수의 코드를 기록하는 부분임 | BEGIN에서 시작하여 END로 끝나며, BEGIN과 END 사이에는 적어도 하나의 SQL문이 있어야 함 | . | RETURN 반환값: 반환할 값이나 반환할 값이 저장된 변수를 호출 프로그램으로 돌려줌 . | ‘i_성별코드’를 입력받아 1이면 “남자”를 2면 “여자”를 반환하는 사용자 정의 함수를 ‘Get _ S _ 성별’이라는 이름으로 정의하시오. . | CREATE FUNCTION Get_S_성별( i _성별코드 IN INT) RETURN VARCHAR2 IS BEGIN IF i _성별코드 = 1 THEN RETURN ‘남자’; ELSE RETURN ‘여자’; END IF; END; . | . 4. 사용자 정의 함수 실행 . DML에서 속성명이나 값이 놓일 자리를 대체하여 사용됨 . | 표기 형식 . SELECT 사용자 정의 함수명 FROM 테이블명; . INSERT INTO 테이블명(속성명) VALUES (사용자 정의 함수명); . DELETE FROM 테이블명 WHERE 속성명 = 사용자 정의 함수명; . UPDATE 테이블명 SET 속성명 = 사용자 정의 함수명; . | 다음의 테이블을 출력하되, &#39;성별코드&#39;는 앞에서 사용자 정의 함수 &#39;Get_S_성별&#39;에 값을 전달하여 반환받은 값으로 대체하여 출력하시오. . . | SELECT 이름, Get_S_성별(성별코드) FROM 사원; . | . 5. 사용자 정의 함수 제거 . 사용자 정의 함수를 제거하기 위해서는 DROP FUNCTION 명령어를 사용함 . | 표기 형식 . DROP FUNCTION 사용자 정의 함수명; . | 앞에서 생성된 사용자 정의 함수 ‘Get_S_성별’을 제거하시오. . | DROP FUNCTION Get_S_성별; . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/07/06/theory126.html",
            "relUrl": "/theory/2021/07/06/theory126.html",
            "date": " • Jul 6, 2021"
        }
        
    
  
    
        ,"post93": {
            "title": "트리거",
            "content": "1. 트리거(Trigger) . 데이터베이스 시스템에서 데이터의 삽입, 갱신, 삭제 등의 이벤트가 발생할 때 관련 작업이 자동으로 수행되게 하는 절차형 SQL임 | 트리거는 데이터베이스에 저장되며, 데이터 변경 및 무결성 유지, 로그 메시지 출력 등의 목적으로 사용됨 | 트리거의 구문에는 DCL(데이터 제어어)을 사용할 수 없으며, DCL이 포함된 프로시저나 함수를 호출하는 경우에 오류가 발생함 | . 2. 트리거의 구성도 . . DECLARE: 트리거의 명칭, 변수 및 상수, 데이터 타입을 정의하는 선언부 | EVENT: 트리거가 실행되는 조건을 명시 | BEGIN/END: 트리거의 시작과 종료를 의미 | CONTROL: 조건문 또는 반복문이 삽입되어 순차적으로 처리됨 | SQL: DML문이 삽입되어 데이터 관리를 위한 조회, 추가, 수정, 삭제 작업을 수행함 | EXCEPTION: BEGIN~END 안의 구문 실행 시 예외가 발생하면 이를 처리하는 방법을 정의 | . 3. 트리거의 생성 . 트리거를 생성하기 위해서는 CREATE TRIGGER 명령을 사용 . | 표기 형식 . CREATE [OR REPLACE] TRIGGER 트리거명 [동작시기 옵션] [동작 옵션] ON 테이블명 REFERENCING [NEW | OLD] AS 테이블명 FOR EACH ROW [WHEN 조건식] BEGIN 트리거 BODY; END; . OR REPLACE: 선택적인 예약어임. 이 예약어를 사용하면 동일한 트리거 이름이 이미 존재하는 경우, 기존의 트리거를 대체할 수 있음 | 동작시기 옵션: 트리거가 실행될 때를 지정함 AFTER: 테이블이 변경된 후에 트리거가 실행됨 | BEFORE: 테이블이 변경되기 전에 트리거가 실행됨 | . | 동작 옵션: 트리거가 실행되게 할 작업의 종류를 지정함 INSERT: 테이블에 새로운 튜플을 삽입할 때 트리거가 실행됨 | DELETE: 테이블의 튜플을 삭제할 때 트리거가 실행됨 | UPDATE: 테이블의 튜플을 수정할 때 트리거가 실행됨 | . | NEW/OLD: 트리거가 적용될 테이블의 별칭을 지정함 NEW: 추가되거나 수정에 참여할 튜플들의 집합(테이블)을 의미함 | OLD: 수정되거나 삭제 전 대상이 되는 튜플들의 집합(테이블)을 의미함 | . | FOR EACH ROW: 각 튜플마다 트리거를 적용한다는 의미임 | WHEN 조건식: 선택적인 예약어임. 트리거를 적용할 튜플의 조건을 지정함 | 트리거 BODY 트리거의 본문 코드를 입력하는 부분 | BEGIN으로 시작해서 END로 끝나는데, 적어도 하나 이상의 SQL문이 있어야 함. 그렇지 않으면 오류가 발생함. | . | 테이블에 새로운 튜플이 삽입될 때, 삽입되는 튜플에 학년 정보가 누락됐으면 &#39;학년&#39; 속성에 &quot;신입생&quot;을 저장하는 트리거를 &quot;학년정보_tri&quot;라는 이름으로 정의하시오. | CREATE TRIGGER 학년정보_tri BEFORE INSERT ON 학생 REFERENCING NEW AS new_table FOR EACH ROW WHEN (new_table.학년 IS NULL) BEGIN : new_table.학년 := ‘신입생’; END; | . 4. 트리거의 제거 . 트리거를 제거하기 위해서는 DROP TRIGGER 명령어를 사용함 . | 표기 형식 . DROP TRIGGER 트리거명; . | ‘학년정보_tri’라는 트리거를 제거하는 SQL문을 작성하시오. . | DROP TRIGGER 학년정보_tri; . | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/07/05/theory125.html",
            "relUrl": "/theory/2021/07/05/theory125.html",
            "date": " • Jul 5, 2021"
        }
        
    
  
    
        ,"post94": {
            "title": "프로시저",
            "content": "1. 프로시저(Procedure) . SQL을 사용하여 작성한 일련의 작업을 저장해두고 호출을 통해 원할 때마다 저장한 작업을 수행하도록 하는 절차형 SQL임 | 데이터베이스에 저장되어 수행되기 때문에 스토어드 프로시저라고도 불림 | 시스템의 일일 마감 작업, 일괄 작업 등에 주로 사용됨 | . 2. 프로시저의 구성도 . . DECLARE: 프로시저의 명칭, 변수, 인수, 데이터 타입을 정의하는 선언부임 | BEGIN/END: 프로시저의 시작과 종료를 의미 | CONTROL: 조건문 또는 반복문이 삽입되어 순차적으로 처리됨 | SQL: DML, DCL이 삽입되어 데이터 관리를 위한 조회, 추가, 수정, 삭제 작업을 수행함 | EXCEPTION: BEGIN~END 안의 구문 실행 시 예외가 발생하면 이를 처리하는 방법을 정의함 | TRANSACTION: 수행된 데이터 작업들을 DB에 적용할지 취소할지를 결정하는 처리부임 | . 3. 프로시저 생성 . 프로시저를 생성하기 위해서는 CREATE PROCEDURE 명령어를 사용 | 표기 형식 | . CREATE [OR REPLACE] PROCEDURE 프로시저명(파라미터) [지역변수 선언] BEGIN 프로시저 BODY; END; . OR REPLACE: 선택적인 예약어임. 이 예약어를 사용하면 동일한 프로시저 이름이 이미 존재하는 경우, 기존의 프로시저를 대체할 수 있음 | 프로시저명: 생성하려는 프로시저의 이름을 지정함 | 파라미터: 프로시저 파라미터로는 다음과 같은 것들이 올 수 있음 IN: 호출 프로그램이 프로시저에게 값을 전달할 때 지정함 | OUT: 프로시저가 호출 프로그램에게 값을 반환할 때 지정함 | INOUT: 호출 프로그램이 프로시저에게 값을 전달하고, 프로시저 실행 후 호출 프로그램에 값을 반환할 때 지정함 | 매개변수명: 호출 프로그램으로부터 전달받은 값을 저장할 변수의 이름을 지정함 | 자료형: 변수의 자료형을 지정함 | . | 프로시저 BODY 프로시저의 코드를 기록하는 부분 | BEGIN에서 시작하여 END로 끝나며, BEGIN과 END 사이에는 적어도 하나의 SQL문이 있어야 함 | . | ‘사원번호’를 입력받아 해당 사원의 ‘지급방식’을 “S”로 변경하는 프로시저를 생성하시오. | CREATE OR REPLACE PROCEDURE emp_change_s(i_사원번호 IN INT) IS BEGIN UPDATE 급여 SET 지급방식=’S’ WHERE 사원번호=i _사원번호; EXCEPTION WHEN PROGRAM_ERROR THEN ROLLBACK; COMMIT; END; | . 4. 프로시저 실행 . 프로시저를 실행하기 위해서는 EXECUTE 명령어 또는 CALL 명령어를 사용하며, EXECUTE 명령어를 줄여서 EXEC로 사용하기도 함 . | 표기 형식 . EXECUTE 프로시저명; EXEC 프로시저명; CALL 프로시저명; . | ‘사원번호’ 32를 인수로 하여 위에서 생성된 emp_change_s 프로시저를 실행하시오. . | EXECUTE emp_change_s(32); . | . 5. 프로시저 제거 . 프로시저를 제거하기 위해서는 DROP PROCEDURE 명령어를 사용함 . | 표기 형식 . DROP PROCEDURE 프로시저명; . | 위에서 생성된 emp_change_s를 제거하시오. . | DROP PROCEDURE emp_change_s; . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/07/04/theory124.html",
            "relUrl": "/theory/2021/07/04/theory124.html",
            "date": " • Jul 4, 2021"
        }
        
    
  
    
        ,"post95": {
            "title": "DML - JOIN",
            "content": "1. JOIN . 2개의 릴레이션에서 연관된 튜플들을 결합하여, 하나의 새로운 릴레이션을 반환함 | 일반적으로 FROM절에 기술하지만, 릴레이션이 사용되는 곳 어디에나 사용할 수 있음 | 크게 INNER JOIN과 OUTER JOIN으로 구분됨 | . 2. INNER JOIN . 일반적으로 EQUI JOIN과 NON-EQUI JOIN으로 구분됨 . | 조건이 없는 INNER JOIN을 수행하면 CROSS JOIN과 동일한 결과를 얻을 수 있음 . | EQUI JOIN . JOIN 대상 테이블에서 공통 속성을 기준으로 ‘=’(equal) 비교에 의해 같은 값을 가지는 행을 연결하여 결과를 생성하는 JOIN 방법임 . | EQUI JOIN에서 JOIN 조건이 ‘=’일 때 동일한 속성이 두 번 나타나게 되는데, 이 중 중복된 속성을 제거하여 같은 속성을 한 번만 표기하는 방법을 NATURAL JOIN이라고 함 . | EQUI JOIN에서 연결 고리가 되는 공통 속성을 JOIN 속성이라고 함 . | WHERE절을 이용한 EQUI JOIN의 표기 형식 . SELECT [테이블명1.]속성명, [테이블명2.]속성명, … FROM 테이블명1, 테이블명2, … WHERE 테이블명1.속성명 = 테이블명2.속성명; . | NATURAL JOIN절을 이용한 EQUI JOIN의 표기 형식 . SELECT [테이블명1.]속성명, [테이블명2.]속성명, … FROM 테이블명1 NATURAL JOIN 테이블명2; . | JOIN ~ USING절을 이용한 EQUI JOIN의 표기 형식 . SELECT [테이블명1.]속성명, [테이블명2.]속성명, … FROM 테이블명1 JOIN 테이블명2 USING(속성명); . . | 테이블과 테이블에서 &#39;학과코드&#39; 값이 같은 튜플을 JOIN하여 &#39;학번&#39;, &#39;이름&#39;, &#39;학과코드&#39;, &#39;학과명&#39;을 출력하는 SQL 문을 작성하시오. &gt; - SELECT 학번, 이름, 학생.학과코드, 학과명 &gt; FROM 학생, 학과 &gt; WHERE 학생.학과코드 = 학과.학과코드 &gt; - SELECT 학번, 이름, 학생.학과코드, 학과명 &gt; FROM 학생 NATURAL JOIN 학과; &gt; - SELECT 학번, 이름, 학생.학과코드, 학과명 &gt; FROM 학생 JOIN 학과 USING(학과코드); | NON-EQUI JOIN . JOIN 조건에 ‘=’ 조건이 아닌 나머지 비교 연산자, 즉 &gt;, &lt;, &lt;&gt;, &gt;=, &lt;= 연산자를 사용하는 JOIN 방법임 . | 표기 형식 . SELECT [테이블명1.]속성명, [테이블명2.]속성명, … FROM 테이블명1, 테이블명2, … WHERE (NON-EQUI-JOIN 조건); . | . | 테이블과 테이블을 JOIN하여 각 학생의 &#39;학번&#39;, &#39;이름&#39;, &#39;성적&#39;, &#39;등급&#39;을 출력하는 SQL문을 작성하시오. &gt; SELECT 학번, 이름, 성적, 등급 &gt; FROM 학생, 성적등급 &gt; WHERE 학생.성적 BETWEEN 성적등급.최저 AND 성적등급.최고; | . | . 3. OUTER JOIN . 릴레이션에서 JOIN 조건에 만족하지 않는 튜플도 결과로 출력하기 위한 JOIN 방법으로, LEFT OUTER JOIN, RIGHT OUTER JOIN, FULL OUTER JOIN이 있음 . | LEFT OUTER JOIN: INNER JOIN의 결과를 구한 후, 우측 항 릴레이션의 어떤 튜플과도 맞지 않는 좌측 항의 릴레이션에 있는 튜플들에 NULL 값을 붙여서 INNER JOIN의 결과에 추가함 . | 표기 형식 . SELECT [테이블명1.]속성명, [테이블명2.]속성명, … FROM 테이블명1 LEFT OUTER JOIN 테이블명2 ON 테이블명1.속성명 = 테이블명2.속성명; | SELECT [테이블명1.]속성명, [테이블명2.]속성명, … FROM 테이블명1, 테이블명2 WHERE 테이블명1.속성명 = 테이블명2.속성명(+); | . | RIGHT OUTER JOIN: INNER JOIN의 결과를 구한 후, 좌측 항 릴레이션의 어떤 튜플과도 맞지 않는 우측 항의 릴레이션에 있는 튜플들에 NULL 값을 붙여서 INNER JOIN의 결과에 추가함 . | 표기 형식 . SELECT [테이블명1.]속성명, [테이블명2.]속성명, … FROM 테이블명1 RIGHT OUTER JOIN 테이블명2 ON 테이블명1.속성명 = 테이블명2.속성명; | SELECT [테이블명1.]속성명, [테이블명2.]속성명, … FROM 테이블명1, 테이블명2 WHERE 테이블명1.속성명(+) = 테이블명2.속성명; | . | FULL OUTER JOIN . LEFT OUTER JOIN과 RIGHT OUTER JOIN을 합쳐 놓은 것 . | INNER JOIN의 결과를 구한 후, 좌측 항의 릴레이션의 튜플들에 대해 우측 항의 릴레이션의 어떤 튜플과도 맞지 않는 튜플들에 NULL 값을 붙여서 INNER JOIN의 결과에 추가함. 그리고 유사하게 우측 항의 릴레이션의 튜플들에 대해 좌측 항의 릴레이션의 어떤 튜플과도 맞지 않는 튜플들에 NULL 값을 붙여서 INNER JOIN의 결과에 추가함 . | 표기 형식 . SELECT [테이블명1.]속성명, [테이블명2.]속성명, … FROM 테이블명1 FULL OUTER JOIN 테이블명2 ON 테이블명1.속성명 = 테이블명2.속성명; . | . | 테이블과 테이블에서 &#39;학과코드&#39; 값이 같은 튜플을 JOIN하여 &#39;학번&#39;, &#39;이름&#39;, &#39;학과코드&#39;, &#39;학과명&#39;을 출력하는 SQL문을 작성하시오. 이때 &#39;학과코드&#39;가 입력되지 않은 학생도 출력하시오. | SELECT 학번, 이름, 학생.학과코드, 학과명 FROM 학생 LEFT OUTER JOIN 학과 ON 학생.학과코드 = 학과.학과코드; . | SELECT 학번, 이름, 학생.학과코드, 학과명 FROM 학생, 학과 WHERE 학생.학과코드 = 학과.학과코드(+); . | SELECT 학번, 이름, 학생.학과코드, 학과명 FROM 학과 RIGHT OUTER JOIN 학생 ON 학과.학과코드 = 학생.학과코드; . | SELECT 학번, 이름, 학생.학과코드, 학과명 FROM 학과, 학생 WHERE 학과.학과코드(+)=학생.학과코드; . | 테이블과 테이블에서 &#39;학과코드&#39; 값이 같은 튜플을 JOIN하여 &#39;학번&#39;, &#39;이름&#39;, &#39;학과코드&#39;, &#39;학과명&#39;을 출력하는 SQL문을 작성하시오. 이때, &#39;학과코드&#39;가 입력 안 된 학생이나 학생이 없는 &#39;학과코드&#39;도 모두 출력하시오. | SELECT 학번, 이름, 학과.학과코드, 학과명 FROM 학생 FULL OUTER JOIN 학과 ON 학생.학과코드 = 학과.학과코드; | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/07/03/theory123.html",
            "relUrl": "/theory/2021/07/03/theory123.html",
            "date": " • Jul 3, 2021"
        }
        
    
  
    
        ,"post96": {
            "title": "DML-SELECT-2",
            "content": "1. 일반 형식 . SELECT [PREDICATE] [테이블명.]속성명 [AS 별칭] [, [테이블명.]속성명, …] [, 그룹함수(속성명) [AS 별칭]] [, WINDOW함수 OVER (PARTITION BY 속성명1, 속성명2, … ORDER BY 속성명3, 속성명4, …) [AS 별칭]] FROM 테이블명[, 테이블명, …] [WHERE 조건] [GROUP BY 속성명, 속성명, …] [HAVING 조건] [ORDER BY 속성명 [ASC | DESC]]; . 그룹함수: GROUP BY 절에 지정된 그룹별로 속성의 값을 집계할 함수를 기술함 | WINDOW 함수: GROUP BY 절을 이용하지 않고 속성의 값을 집계할 함수를 기술 PARTITION BY: WINDOW 함수의 적용 범위가 될 속성을 지정 | ORDER BY: PARTITION 안에서 정렬 기준으로 사용할 속성을 지정 | . | GROUP BY 절: 특정 속성을 기준으로 그룹화하여 검색할 때 사용함. 일반적으로 GROUP BY 절은 그룹 함수와 함께 사용됨 | HAVING절: GROUP BY와 함께 사용되며, 그룹에 대한 조건을 지정함 | . 2. 그룹 함수 . GROUP BY절에 지정된 그룹별로 속성의 값을 집계할 때 사용됨 | COUNT(속성명): 그룹별 튜플 수를 구하는 함수 | SUM(속성명): 그룹별 합계를 구하는 함수 | AVG(속성명): 그룹별 평균을 구하는 함수 | MAX(속성명): 그룹별 최대값을 구하는 함수 | MIN(속성명): 그룹별 최소값을 구하는 함수 | STDDEV(속성명): 그룹별 표준편차를 구하는 함수 | VARIANCE(속성명): 그룹별 분산을 구하는 함수 | ROLLUP(속성명, 속성명, …): 인수로 주어진 속성을 대상으로 그룹별 소계를 구하는 함수. 속성의 개수가 n개이면 n+1 레벨까지, 하위 레벨에서 상위 레벨 순으로 데이터가 집계됨 | CUBE(속성명, 속성명, …): ROLLUP과 유사한 형태지만 CUBE는 인수로 주어진 속성을 대상으로 모든 조합의 그룹별 소계를 구함. 속성의 개수가 n개이면, 2^n 레벨까지, 상위 레벨에서 하위 레벨 순으로 데이터가 집계됨 | . 3. WINDOW 함수 . GROUP BY절을 이용하지 않고 함수의 인수로 지정한 속성의 값을 집계함 | 함수의 인수로 지정한 속성이 집계할 범위가 되는데, 이를 윈도우라고 부름 | WINDOW 함수 ROW_NUMBER(): 윈도우별로 각 레코드에 대한 일련번호를 반환 | RANK(): 윈도우별로 순위를 반환하며, 공동 순위를 반영 | DENSE_RANK(): 윈도우별로 순위를 반환하며, 공동 순위를 무시하고 순위를 부여 | . | . 4. WINDOW 함수 이용 검색 . GROUP BY절을 이용하지 않고 함수의 인수로 지정한 속성을 범위로 하여 속성의 값을 집계함 | | | 테이블에서 &#39;상여내역&#39;별로 &#39;상여금&#39;에 대한 일련 번호를 구하시오. (단 순서는 내림차순이며 속성명은 &#39;NO&#39;로 할 것) | SELECT 상여내역, 상여금, ROW_NUMBER() OVER (PARTITION BY 상여내역 ORDER BY 상여금 DESC) AS NO FROM 상여금; | 테이블에서 &#39;상여내역&#39;별로 &#39;상여금&#39;에 대한 순위를 구하시오. (단, 순서는 내림차순이며, 속성명은 &#39;상여금순위&#39;로 하고, RANK() 함수를 이용할 것) | SELECT 상여내역, 상여금 RANK() OVER (PARTITION BY 상여내역 ORDER BY 상여금 DESC) AS 상여금순위 FROM 상여금; | . 5. 그룹 지정 검색 . GROUP BY절에 지정한 속성을 기준으로 자료를 그룹화하여 검색함 | 테이블에서 &#39;부서&#39;별 &#39;상여금&#39;의 평균을 구하시오. | SELECT 부서, AVG(상여금) AS 평균 FROM 상여금 GROUP BY 부서; | 테이블에서 부서별 튜플 수를 검색하시오. | SELECT 부서, COUNT(*) AS 사원수 FROM 상여금 GROUP BY 부서; | 테이블에서 &#39;상여금&#39;이 100 이상인 사원이 2명 이상이 &#39;부서&#39;의 튜플 수를 구하시오. | SELECT 부서, COUNT(*) AS 사원수 FROM 상여금 WHERE 상여금 &gt;= 100 GROUP BY 부서 HAVING COUNT( *)&gt;=2; | 테이블의 &#39;부서&#39;, &#39;상여내역&#39;, 그리고 &#39;상여금&#39;에 대해 부서별 상여내역별 소계와 전체 합계를 검색하시오. (단, 속성명은 &#39;상여금합계&#39;로 하고, ROLLUP 함수를 사용할 것) | SELECT 부서, 상여내역, SUM(상여금) AS 상여금합계 FROM 상여금 GROUP BY ROLLUP(부서, 상여내역); | 테이블의 &#39;부서&#39;, &#39;상여내역&#39;, 그리고 &#39;상여금&#39;에 대해 부서별 상여내역별 소계와 전체 합계를 검색하시오.(단, 속성명은 &#39;상여금합계&#39;로 하고, CUBE 함수를 사용할 것) | SELECT 부서, 상여금내역, SUM(상여금) AS 상여금합계 FROM 상여금 GROUP BY CUBE(부서, 상여내역); | . 6. 집합 연산자를 이용한 통합 질의 . 집합 연산자를 사용하여 2개 이상의 테이블의 데이터를 하나로 통합함 | 표기 형식 | . SELECT 속성명1, 속성명2, … FROM 테이블명 UNION | UNION ALL | INTERSECT | EXCEPT SELECT 속성명1, 속성명2, … FROM 테이블명 [ORDER BY 속성명 [ASC | DESC]]; . 두 개의 SELECT문에 기술한 속성들은 개수와 데이터 유형이 서로 동일해야 함 . | 집합 연산자의 종류(통합 질의의 종류) . 집합 연산자 설명 집합 종류 . UNION | - 두 SELECT문의 조회 결과를 통합하여 모두 출력- 중복된 행은 한 번만 출력 | 합집합 | . UNION ALL | - 두 SELECT문의 조회 결과를 통합하여 모두 출력- 중복된 행도 그대로 출력 | 합집합 | . INTERSECT | 두 SELECT문의 조회 결과 중 공통된 행만 출력 | 교집합 | . EXCEPT | 첫 번째 SELECT문의 조회 결과에서 두 번째 SELECT문의 조회 결과를 제외한 행을 출력 | 차집합 | . | | 테이블과 테이블을 통합하는 질의문을 작성하시오. (단, 같은 레코드가 중복되어 나오지 않게 하시오.) | SELECT * FROM 사원 UNION SELECT * FROM 직원; | 테이블과 테이블에 공통으로 존재하는 레코드만 통합하는 질의문을 작성하시오. | SELECT * FROM 사원 UNION SELECT * FROM 직원; | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/07/02/theory122.html",
            "relUrl": "/theory/2021/07/02/theory122.html",
            "date": " • Jul 2, 2021"
        }
        
    
  
    
        ,"post97": {
            "title": "DML-SELECT-1",
            "content": "1. 일반 형식 . SELECT [PREDICATE] [테이블명.]속성명 [AS 별칭] [, [테이블명.]속성명, …] [, 그룹함수(속성명) [AS 별칭]] [, Windows함수 OVER (PARTITION BY 속성명1, 속성명2, … ORDER BY 속성명3, 속성명4, …)] FROM 테이블명[, 테이블명, …] [WHERE 조건] [GROUP BY 속성명, 속성명, …] [HAVING 조건] [ORDER BY 속성명 [ASC | DESC]]; . SELECT 절 PREDICATE: 검색할 튜플 수를 제한하는 명령어를 기술 DISTINCT: 중복된 튜플이 있으면 그 중 첫번째 한 개만 표시 | . | 속성명: 검색하여 불러올 속성(열) 또는 속성을 이용한 수식을 지정 | AS: 속성이나 연산의 이름을 다른 이름으로 표시하기 위해 사용 | . | FROM 절: 검색할 데이터가 들어있는 테이블 이름을 기술 | WHERE 절: 검색할 조건을 기술 | ORDER BY 절: 데이터를 정렬하여 검색할 때 사용 속성명: 정렬의 기준이 되는 속성명을 기술 | [ASC | DESC] : 정렬 방식으로, ‘ASC’는 오름차순, ‘DESC’는 내림차순임. 생략하면 오름차순으로 지정됨 | . | . | . 2. 조건 연산자 . 비교 연산자 | = : 같다 / &lt;&gt; : 같지 않다 / &gt; : 크다 / &lt; : 작다 / &gt;= : 크거나 같다 / &lt;= : 작거나 같다 | 논리 연산자: NOT, AND, OR | LIKE 연산자: 대표 문자를 이용해 지정된 속성의 값이 문자 패턴과 일치하는 튜플을 검색하기 위해 사용됨 | % : 모든 문자를 대표함 / _ : 문자 하나를 대표함 / # : 숫자 하나를 대표함 | 다음과 같은 기본 테이블에 대해 다음 예제의 결과를 확인하시오. | | . 3. 기본 검색 . SELECT 절에 원하는 속성을 지정하여 검색함 | 테이블의 모든 튜플을 검색하시오. SELECT * FROM 사원; | SELECT 사원.* FROM 사원; | SELECT 이름, 부서, 생일, 주소, 기본급 FROM 사원; | SELECT 사원.이름, 사원.부서, 사원.생일, 사원.주소, 사원.기본급 FROM 사원; | . | 위의 SQL은 모두 보기에 주어진 테이블 전체를 그대로 출력함 | 테이블에서 &#39;주소&#39;만 검색하되 같은 &#39;주소&#39;는 한 번만 출력하시오. SELECT DISTINCT 주소 FROM 사원; | . | 테이블에서 &#39;기본급&#39;에 특별수당 10을 더한 월급을 &quot;XX부서의 XXX의 월급 XXX&quot; 형태로 출력하시오. SELECT 부서+’부서의’ AS 부서2, 이름 + ‘의 월급’ AS 이름2, 기본급+10 AS 기본급2 FROM 사원; | . | . 4. 조건 지정 검색 . WHERE 절에 조건을 지정하여 조건에 만족하는 튜플만 검색함 | 테이블에서 &#39;기획&#39;부의 모든 튜플을 검색하시오. | SELECT * FROM 사원 WHERE 부서=’기획’; | 테이블에서 &quot;기획&quot; 부서에 근무하면서 &quot;대흥동&quot;에 사는 사람의 튜플을 검색하시오. | SELECT * FROM 사원 WHERE 부서=’기획’ AND 주소=’대흥동’; | 테이블에서 &#39;부서&#39;가 &quot;기획&quot;이거나 &quot;인터넷&quot;인 튜플을 검색하시오. | SELECT * FROM 사원 WHERE 부서=’기획’ OR 부서=’인터넷’; | 테이블에서 성이 &#39;김&#39;인 사람의 튜플을 검색하시오. | SELECT * FROM 사원 WHERE 이름 LIKE “김%”; | 테이블에서 &#39;생일&#39;이 &#39;01/01/69&#39;에서 &#39;12/31/73&#39; 사이인 튜플을 검색하시오. | SELECT * FROM 사원 WHERE 생일 BETWEEN #01/01/69# AND #12/31/73#; | 테이블에서 &#39;주소&#39;가 NULL인 튜플을 검색하시오. | SELECT * FROM 사원 WHERE 주소 IS NULL; | . 5. 정렬 검색 . ORDER BY 절에 특정 속성을 지정하여 지정된 속성으로 자료를 정렬하여 검색함 | 테이블에서 &#39;주소&#39;를 기준으로 내림차순 정렬시켜 상위 2개 튜플만 검색하시오. | SELECT TOP 2 * FROM 사원 ORDER BY 주소 DESC; | 테이블에서 &#39;부서&#39;를 기준으로 오름차순 정렬하고, 같은 &#39;부서&#39;에 대해서는 &#39;이름&#39;을 기준으로 내림차순 정렬시켜서 검색하시오. | SELECT * FROM 사원 ORDER BY 부서 ASC, 이름 DESC; | . 6. 하위 질의 . 조건절에 주어진 질의를 먼저 수행하여 그 검색 결과를 조건절의 피연산자로 사용함 | “취미”가 “나이트댄스”인 사원의 ‘이름’과 ‘주소’를 검색하시오. | SELECT 이름, 주소 FROM 사원 WHERE 이름 = (SELECT 이름 FROM 여가활동 WHERE 취미=’나이트댄스’); | 취미활동을 하지 않는 사원들을 검색하시오. | SELECT * FROM 사원 WHERE 이름 NOT IN (SELECT 이름 FROM 여가활동); | 취미활동을 하는 사원들의 부서를 검색하시오. | SELECT 부서 FROM 사원 WHERE EXISTS (SELECT 이름 FROM 여가활동 WHERE 여가활동.이름 = 사원.이름); | . 7. 복수 테이블 검색 . 여러 테이블을 대상으로 검색을 수행함 | ‘경력’이 10년 이상인 사원의 ‘이름’, ‘부서’, ‘취미’, ‘경력’을 검색하시오. | SELECT 사원.이름, 사원.부서, 여가활동.취미, 여가활동.경력 FROM 사원, 여가활동 WHERE 여가활동.경력 &gt;= 10 AND 사원.이름 = 여가활동.이름; | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/07/01/theory121.html",
            "relUrl": "/theory/2021/07/01/theory121.html",
            "date": " • Jul 1, 2021"
        }
        
    
  
    
        ,"post98": {
            "title": "SQL-DML",
            "content": "1. DML(Data Manipulation Language, 데이터 조작어) . 데이터베이스 사용자가 저장된 데이터를 실질적으로 관리하는데 사용하는 언어 | 데이터베이스 사용자와 데이터베이스 관리 시스템 간의 인터페이스를 제공 | 유형 SELECT: 테이블에서 튜플을 검색 | INSERT: 테이블에 새로운 튜플을 삽입 | DELETE: 테이블에서 튜플을 삭제 | UPDATE: 테이블에서 튜플의 내용을 갱신 | . | . 2. 삽입문(INSERT INTO ~) . 기본 테이블에 새로운 튜플을 삽입할 때 사용 | 일반 형식 | . INSERT INTO 테이블명([속성명1, 속성명2, …]) VALUES (데이터1, 데이터2, …); . 대응하는 속성과 데이터는 개수와 데이터 유형이 일치해야 함 | 기본 테이블의 모든 속성을 사용할 때는 속성명을 생략할 수 있음 | SELECT문을 사용하여 다른 테이블의 검색 결과를 삽입할 수 있음 | . . 테이블에 (이름 -홍승현, 부서-인터넷)을 삽입하시오. | INSERT INTO 사원(이름, 부서) VALUES(‘홍승현’, ‘인터넷’); | 테이블에 (장보고, 기획, 05/03/73, 홍제동, 90)을 삽입하시오. | INSERT INTO 사원 VALUES (‘장보고’, ‘기획’, #05/03/73#, ‘홍제동’, 90); | 테이블에 있는 편집부의 모든 튜플을 편집부원(이름, 생일, 주소, 기본급) 테이블에 삽입하시오. | INSERT INTO 편집부원(이름, 생일, 주소, 기본급) SELECT 이름, 생일, 주소, 기본급 FROM 사원 WHERE 부서=’편집’; | . 3 삭제문(DELETE FROM~) . 기본 테이블에 있는 튜플들 중에서 특정 튜플(행)을 삭제할 때 사용 | 일반 형식 | . DELETE FROM 테이블명 [WHERE 조건]; . 모든 레코드를 삭제할 때는 WHERE 절을 생략함 | 모든 레코드를 삭제하더라도 테이블 구조는 남아 있기 때문에 디스크에서 테이블을 완전히 제거하는 DROP과는 다름 | 테이블에서 &quot;임꺽정&quot;에 대한 튜플을 삭제하시오. | DELETE FROM 사원 WHERE 이름=’임꺽정’; | 테이블에서 &quot;인터넷&quot; 부서에 대한 모든 튜플을 삭제하시오. | DELETE FROM 사원 WHERE 부서=’인터넷’; | 테이블의 모든 레코드를 삭제하시오. | DELETE FROM 사원; | . 4. 갱신문(UPDATE~ SET~) . 기본 테이블에 있는 튜플들 중에서 특정 튜플의 내용을 변경할 때 사용 | 일반 형식 | . UPDATE 테이블명 SET 속성명 = 데이터[, 속성명=데이터, …] [WHERE 조건]; . 테이블에서 &quot;홍길동&quot;의 &#39;주소&#39;를 &quot;수색동&quot;으로 수정하시오. | UPDATE 사원 SET 주소=’수색동’ WHERE 이름=’홍길동’; | 테이블에서 &quot;황진이&quot;의 &#39;부서&#39;를 &quot;기획부&quot;로 변경하고 &#39;기본급&#39;을 5만원 인상시키시오. | UPDATE 사원 SET 부서=’기획’, 기본급=기본급+5 WHERE 이름=’황진이’; | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/06/30/theory120.html",
            "relUrl": "/theory/2021/06/30/theory120.html",
            "date": " • Jun 30, 2021"
        }
        
    
  
    
        ,"post99": {
            "title": "SQL-DCL",
            "content": "1. DCL(Data Control Language, 데이터 제어어) . 데이터의 보안, 무결성, 회복, 병행 제어 등을 정의하는 데 사용하는 언어 | 데이터베이스 관리자(DBA)가 데이터 관리를 목적으로 사용함 | 종류 COMMIT: 명령에 의해 수행된 결과를 실제 물리적 디스크로 저장하고, 데이터베이스 조작 작업이 정상적으로 완료되었음을 관리자에게 알려줌 | ROLLBACK: 데이터베이스 조작 작업이 비정상적으로 종료되었을 때 원래의 상태로 복구함 | GRANT: 데이터베이스 사용자에게 사용 권한을 부여함 | REVOKE: 데이터베이스 사용자의 사용 권한을 취소함 | . | . 2. GRANT / REVOKE . 데이터베이스 관리자가 데이터베이스 사용자에게 권한을 부여하거나 취소하기 위한 명령어임 . | GRANT: 권한 부여를 위한 명령어 . | REVOKE: 권한 취소를 위한 명령어 . | 사용자 등급 지정 및 해제 . GRANT 사용자등급 TO 사용자ID리스트 [IDENTIFIED BY 암호]; . REVOKE 사용자등급 FROM 사용자ID리스트; . 사용자 ID가 “NABI”인 사람에게 데이터베이스 및 테이블을 생성할 수 있는 권한을 부여하는 SQL 문을 작성하시오. | GRANT RESOURCE TO NABI; | 사용자 ID가 “STAR”인 사람에게 단순히 데이터베이스에 있는 정보를 검색할 수 있는 권한을 부여하는 SQL 문을 작성하시오. | GRANT CONNECT TO STAR; | . | 테이블 및 속성에 대한 권한 부여 및 취소 . GRANT 권한_리스트 ON 개체 TO 사용자 [WITH GRANT OPTION]; . REVOKE [GRANT OPTION FOR] 권한_리스트 ON 개체 FROM 사용자 [CASCADE]; . 권한 종류: ALL, SELECT, INSERT, DELETE, UPDATE, ALTER 등 | WITH GRANT OPTION: 부여받은 권한을 다른 사용자에게 다시 부여할 수 있는 권한을 부여 | GRANT OPTION FOR: 다른 사용자에게 권한을 부여할 수 있는 권한을 취소 | CASCADE: 권한 취소 시 권한을 부여받았던 사용자가 다른 사용자에게 부여한 권한도 연쇄적으로 취소 | 사용자 ID가 “NABI”인 사람에게 테이블에 대한 모든 권한과 다른 사람에게 권한을 부여할 수 있는 권한까지 부여하는 SQL 문을 작성하시오. | GRANT ALL ON 고객 TO NABI WITH GRANT OPTION; | 사용자 ID가 “STAR”인 사람에게 부여한 테이블에 대한 권한 중 UPDATE 권한을 다른 사람에게 부여할 수 있는 권한만 취소하는 SQL 문을 작성하시오. | REVOKE GRANT OPTION FOR UPDATE ON 고객 FROM STAR; | . | . 3. COMMIT . 트랜잭션 처리가 정상적으로 완료된 후 트랜잭션이 수행한 내용을 데이터베이스에 반영하는 명령임 | COMMIT 명령을 실행하지 않아도 DML 문이 성공적으로 완료되면 자동으로 COMMIT 되고, DML이 실패하면 자동으로 ROLLBACK이 되도록 Auto Commit 기능을 설정할 수 있음 | . 4. ROLLBACK . 변경되었으나 아직 COMMIT되지 않은 모든 내용들을 취소하고 데이터베이스를 이전 상태로 되돌리는 명령어 | 트랜잭션 전체가 성공적으로 끝나지 못하면 일부 변경된 내용만 데이터베이스에 반영되는 비일관성 상태가 될 수 있기 때문에 일부분만 완료된 트랜잭션은 롤백되어야 함 | . 5. SAVEPOINT . 트랜잭션 내에 ROLLBACK 할 위치인 저장점을 지정하는 명령어 | 저장점을 지정할 때는 이름을 부여함 | ROLLBACK 할 때 지정된 저장점까지의 트랜잭션 처리 내용이 모두 취소됨 | | 테이블에서 &#39;사원번호&#39;가 40인 사원의 정보를 삭제한 후 COMMIT을 수행하시오. | DELETE FROM 사원 WHERE 사원번호=40; COMMIT; | ‘사원번호’가 30인 사원의 정보를 삭제하시오. | DELETE FROM 사원 WHERE 사원번호=30; | SAVEPOINT ‘S1’을 설정하고 ‘사원번호’가 20인 사원의 정보를 삭제하시오. | SAVEPOINT S1; DELTE FROM 사원 WHERE 사원번호=20; | SAVEPOINT ‘S2’를 설정하고 ‘사원번호’가 10인 사원의 정보를 삭제하시오. | SAVEPOINT S2; DELETE FROM 사원 WHERE 사원번호=10; | SAVEPOINT ‘S2’ 까지 ROLLBACK을 수행하시오. | ROLLBACK TO S2; | SAVEPOINT ‘S1’까지 ROLLBACK을 수행하시오. | ROLLBACK TO S1; | SAVEPOINT 없이 ROLLBACK을 수행하시오. | ROLLBACK; | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/06/29/theory119.html",
            "relUrl": "/theory/2021/06/29/theory119.html",
            "date": " • Jun 29, 2021"
        }
        
    
  
    
        ,"post100": {
            "title": "SQL-DDL",
            "content": "1. DDL(Data Define Language, 데이터 정의어) . DDL은 DB 구조, 데이터 형식, 접근 방식 등 DB를 구축하거나 수정할 목적으로 사용하는 언어 | 번역한 결과가 데이터 사전(Data Dictionary)이라는 특별한 파일에 여러 개의 테이블로 저장됨 | DDL의 3가지 유형 CREATE: SCHEMA, DOMAIN, TABLE, VIEW, INDEX를 정의함 | ALTER: TABLE에 대한 정의를 변경하는 데 사용 | DROP: SCHEMA, DOMAIN, TABLE, VIEW, INDEX를 삭제함 | . | . 2. CREATE SCHEMA . 스키마를 정의하는 명령문 . | 표기 형식 . CREATE SCHEMA 스키마명 AUTHORIZATION 사용자_id; . 소유권자의 사용자 ID가 ‘홍길동’인 스키마 ‘대학교’를 정의하는 sql문: CREATE SCHEMA 대학교 AUHORIZATION 홍길동; | . | . 3. CREATE DOMAIN . 도메인을 정의하는 명령문 . | 표기 형식 . CREATE DOMAIN 도메인명 [AS] 데이터_타입 [DEFAULT 기본값] [CONSTRAINT 제약조건명 CHECK (범위값)]; . 데이터 타입: SQL에서 지원하는 데이터 타입 | 기본값: 데이터를 입력하지 않았을 때 자동으로 입력되는 값 | ‘성별’을 ‘남’ 또는 ‘여’와 같이 정해진 1개의 문자로 표현되는 도메인 SEX를 정의하는 SQL문: CREATE DOMAIN SEX CHAR(1) DEFAULT ‘남’ CONSTRAINT VALID-SEX CHECK(VALUE IN(‘남’, ‘여’)); | . | . 4. CREATE TABLE . 테이블을 정의하는 명령문 . | 표기 형식 . CREATE TABLE 테이블명 (속성명 데이터_타입[DEFAULT 기본값] [NOT NULL], [, PRIMARY KEY(기본키속성명, …)] [, UNIQUE(대체키속성명, …)] [, FOREIGN KEY(외래키속성명, …)] REFERENCES 참조테이블(기본키속성명), …] [ON DELETE 옵션] [ON UPDATE 옵션] [, CONSTRAINT 제약조건명] [CHECK (조건식)]); . 기본 테이블에 포함될 모든 속성에 대학여 속성명과 그 속성의 데이터 타입, 기본값, NOT NULL 여부를 지정함 | PRIMARY KEY: 기본키로 사용할 속성을 지정함 | UNIQUE: 대체키로 사용할 속성을 지정함, 중복된 값 가질 수 없음 | FOREIGN KEY~REFERENCES~: 외래키로 사용할 속성을 지정 ON DELETE 옵션: 참조 테이블의 튜플이 삭제되었을 때 기본 테이블에 취해야 할 사항을 지정 | ON UPDATE 옵션: 참조 테이블의 참조 속성 값이 변경되었을 때 기본 테이블에 취해야 할 사항을 지정 | CONSTRAINT: 제약 조건의 이름을 지정 | CHECK: 속성 값에 대한 제약 조건을 정의 | . | ‘이름’, ‘학번’, ‘전공’, ‘성별’, ‘생년월일’로 구성된 테이블을 정의하는 SQL 문을 작성하시오. 단 제약 조건은 다음과 같다. ‘이름’은 NULL이 올 수 없고, ‘학번’은 기본키 | ‘전공’은 테이블의 &#39;학과코드&#39;를 참조하는 외래키로 사용됨 | 테이블에서 &#39;학과코드&#39;가 변경되면 전공 값도 같은 값으로 변경함 | ‘생년월일’은 1980-01-01 이후의 데이터만 저장할 수 있음 | 제약 조건의 이름은 ‘생년월일제약’으로 함 | 각 속성의 데이터 타입은 적당하게 지정함. 단, ‘성별’은 도메인 ‘SEX’를 사용함 | CREATE TABLE 학생 (이름 VARCHAR(15) NOT NULL, 학번 CHAR(8), 전공 CHAR(5), 성별 SEX, 생년월일 DATE, PRIMARY KEY(학번), FOREIGN KEY(전공) REFERENCES 학과(학과코드)) ON DELETE SET NULL ON UPDATE CASCADE, CONSTRAINT 생년월일제약 CHECK(생년월일&gt;=’1980-01-01’)); | . | . | . 5. CREATE VIEW . 뷰를 정의하는 명령문 . | 표기 형식 . CREATE VIEW 뷰명(속성명[, 속성명, …])] AS SELECT문; . 테이블에서 &#39;주소&#39;가 &#39;안산시&#39;인 고객들의 &#39;성명&#39;과 &#39;전화번호&#39;를 &#39;안산고객&#39;이라는 뷰로 정의하시오. | CREATE VIEW 안산고객(성명, 전화번호) AS SELECT 성명, 전화번호 FROM 고객 WHERE 주소=’안산시’; | . | . 6. CREATE INDEX . 인덱스를 정의하는 명령문 . | 표기 형식 . CREATE [UNIQUE] INDEX 인덱스명 ON 테이블명(속성명[ASC | DESC] [, 속성명[ASC | DESC]]) [CLUSTER]; . UNIQUE 사용된 경우: 중복 값이 없는 속성으로 인덱스를 생성 | 생략된 경우: 중복 값을 허용하는 속성으로 인덱스를 생성 | . | 정렬 여부 지정 ASC: 오름차순 정렬 | DESC: 내림차순 정렬 | 생략된 경우: 오름차순으로 정렬됨 | . | CLUSTER: 사용하면 인덱스가 클러스터드 인덱스로 설정됨 | 테이블에서 UNIQUE한 특성을 갖는 &#39;고객번호&#39; 속성에 대해 내림차순으로 정렬하여 &#39;고객번호_idx&#39;라는 이름으로 인덱스를 정의하시오. | CREATE UNIQUE INDEX 고객번호_idx ON 고객(고객번호 DESC); | . | . 7. ALTER TABLE . 테이블에 대한 정의를 변경하는 명령문 . | 표기 형식 . ALTER TABLE 테이블명 ADD 속성명 데이터_타입[DEFAULT ‘기본값’]; . ALTER TABLE 테이블명 ALTER 속성명 [SET DEFAULT ‘기본값’]; . ALTER TABLE 테이블명 DROP COLUMN 속성명 [CASCADE]; . ADD: 새로운 속성(열)을 추가할 때 사용 | ALTER: 특정 속성의 Default 값을 변경할 때 사용 | DROP COLUMN: 특정 속성을 삭제할 때 사용 | 테이블에 최대 3문자로 구성되는 &#39;학년&#39; 속성 추가하시오. | ALTER TABLE 학생 ADD 학년 VARCHAR(3); | 테이블의 &#39;학번&#39; 필드의 데이터 타입과 크기를 VARCHAR(10)으로 하고 NULL 값이 입력되지 않도록 변경하시오. | ALTER TABLE 학생 ALTER 학번 VARCHAR(10) NOT NULL; | . | . 8. DROP . 스키마, 도메인, 기본 테이블, 뷰 테이블, 인덱스, 제약 조건 등을 제거하는 명령문 . | 표기 형식 . DROP SCHEMA 스키마명 [CASCADE | RESTRICT]; | . DROP DOMAIN 도메인명 [CASCADE | RESTRICT]; | . DROP TABLE 테이블명 [CASCADE | RESTRICT]; | . DROP VIEW 뷰명 [CASCADE | RESTRICT]; | . DROP INDEX 인덱스명 [CASCADE | RESTRICT]; | . DROP CONSTRAINT 제약조건명; . CASCADE: 제거할 요소를 참조하는 다른 모든 개체를 함께 제거함 | RESTRICT: 다른 개체가 제거할 요소를 참조중일 때는 제거를 취소 | 테이블을 제거하되, 테이블을 참조하는 모든 데이터를 함께 제거하시오. | DROP TABLE 학생 CASCADE; | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/06/28/theory118.html",
            "relUrl": "/theory/2021/06/28/theory118.html",
            "date": " • Jun 28, 2021"
        }
        
    
  
    
        ,"post101": {
            "title": "애플리케이션 성능 개선",
            "content": "1. 소스 코드 최적화 . 나쁜 코드를 배제하고 클린 코드로 작성하는 것 | 클린 코드: 누구나 쉽게 이해하고 수정 및 추가할 수 있는 단순, 명료한 코드. 즉 잘 작성된 코드 | 나쁜 코드: 프로그램의 로직이 복잡하고 이해하기 어려운 코드 대표적인 나쁜 코드 스파게티 코드: 코드의 로직이 서로 복잡하게 얽혀 있는 코드 | 외계인 코드: 아주 오래되거나 참고문서 또는 개발자가 없어 유지보수 작업이 어려운 코드 | . | . | 나쁜 코드로 작성된 애플리케이션의 코드를 클린 코드로 수정하면 애플리케이션의 성능이 개선됨 | . 2. 클린 코드 작성 원칙 . 가독성 누구든지 코드를 쉽게 읽을 수 있도록 작성 | 이해하기 쉬운 용어를 사용하거나 들여쓰기 기능 사용 | . | 단순성 코드를 간단하게 작성 | 한 번에 한 가지를 처리하도록 코드를 작성하고 클래스/메소드/함수 등을 최소 단위로 분리 | . | 의존성 배제 코드가 다른 모듈에 미치는 영향 최소화 | 코드 변경 시 다른 부분에 영향이 없도록 작성 | . | 중복성 최소화 코드의 중복 최소화 | 중복된 코드는 삭제하고 공통된 코드 사용 | . | 추상화 상위 클래스/메소드/함수에서는 간략하게 애플리케이션의 특성을 나타내고, 상세 내용은 하위 클래스/메소드/함수에서 구현 | . | . 3. 소스 코드 최적화 유형 . 클래스 분할 배치: 하나의 클래스는 하나의 역할만 수행하도록 응집도를 높이고 크기를 작게 작성함 | 느슨한 결합: 인터페이스 클래스를 이용하여 추상화된 자료 구조와 메소드를 구현함으로써 클래스 간의 의존성을 최소화 | . 4. 소스 코드 품질 분석 도구 . 소스 코드의 코딩 스타일, 코드에 설정된 코딩 표준, 코드의 복잡도, 코드에 존재하는 메모리 누수 현상, 스레드 결함 등을 발견하기 위해 사용하는 분석 도구 | 정적 분석 도구 작성한 소스 코드를 실행하지 않고 코딩 표준이나 코딩 스타일, 결함 등을 확인하는 코드 분석 도구 | 종류: pmd, cppcheck, SonarQube, checkstyle, ccm, cobertura 등 | . | 동적 분석 도구 작성한 소스 코드를 실행하여 코드에 존재하는 메모리 누수, 스레드 결함 등을 분석하는 도구 | 종류: Avalanche, Valgrind 등 | . | . 5. 소스 코드 품질 분석 도구의 종류 . 도구 설명 지원 환경 . pmd | 소스 코드에 대한 미사용 변수, 최적화되지 않은 코드 등 결함을 유발할 수 있는 코드 검사 | Linux, Windows | . cppcheck | C/C++ 코드에 대한 메모리 누수, 오버플로우 등 분석 | Windows | . SonarQube | 중복 코드, 복잡도, 코딩 설계 등을 분석하는 소스 분석 통합 플랫폼 | Cross-Platform | . checkstyle | -자바 코드에 대해 소스 코드 표준을 따르고 있는지 검사-다양한 개발 도구에 통합하여 사용 가능 | Cross-Platform | . ccm | 다양한 언어의 코드 복잡도를 분석 | Cross-Platform | . cobertura | 자바 언어의 소스 코드 복잡도 분석 및 테스트 커버리지를 측정 | Cross-Platform | . Avalanche | -Valgrind 프레임워크 및 STP 기반으로 구현-프로그램에 대한 결함 및 취약점 등을 분석 | Linux, Android | . Valgrind | 프로그램 내에 존재하는 메모리 및 쓰레드 결함 등을 분석 | Cross-Platform | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/06/27/theory117.html",
            "relUrl": "/theory/2021/06/27/theory117.html",
            "date": " • Jun 27, 2021"
        }
        
    
  
    
        ,"post102": {
            "title": "복잡도",
            "content": "1. 복잡도(Complexity) . 시스템이나 시스템 구성 요소 또는 소프트웨어의 복잡한 정도를 나타내는 말 | 시스템 또는 소프트웨어를 어느 정도의 수준까지 테스트해야 하는지 또는 개발하는 데 어느 정도의 자원이 소요되는지 예측하는 데 사용 | . 2. 시간 복잡도 . 알고리즘을 수행하기 위해 프로세스가 수행하는 연산 횟수를 수치화한 것을 의미 | 시간 복잡도가 낮을수록 알고리즘의 실행시간이 짧고, 높을수록 실행시간이 길어짐 | 점근 표기법의 종류 빅오 표기법 알고리즘의 실행시간이 최악일 때를 표기하는 방법 | 입력값에 대해 알고리즘을 수행했을 때 명령어의 실행 횟수는 어떠한 경우에도 표기 수치보다 많을 수 없음 | . | 세타 표기법 알고리즘의 실행시간이 평균일 때를 표기하는 방법 | 입력값에 대해 알고리즘을 수행했을 때 명령어 실행 횟수의 평균적인 수치를 표기 | . | 오메가 표기법 알고리즘의 실행시간이 최상일 때를 표기하는 방법 | 입력값에 대해 알고리즘을 수행했을 때 명령어의 실행 횟수는 어떠한 경우에도 표기 수치보다 적을 수 없음 | . | . | . 3. 빅오 표기법으로 표현한 최악의 알고리즘 시간 복잡도 . O(1) 입력값(n)에 관계 없이 일정하게 문제 해결에 하나의 단계만을 거침 | 스택의 삽입, 삭제 | . | O(logn) 문제 해결에 필요한 단계가 입력값(n) 또는 조건에 의해 감소함 | 이진 트리, 이진 검색 | . | O(n) 문제 해결에 필요한 단계가 입력값(n)과 1:1의 관계를 가짐 | for 문 | . | O(nlogn) 문제 해결에 필요한 단계가 n(logn)번만큼 수행됨 | 힙 정렬, 2-way 합병 정렬 | . | O(n^2) 문제 해결에 필요한 단계가 입력값(n)의 제곱만큼 수행됨 | 삽입 정렬, 쉘 정렬, 선택 정렬, 버블 정렬, 퀵 정렬 | . | O(2^n) 문제 해결에 필요한 단계가 2의 입력값(n) 제곱만큼 수행됨 | 피보나치 수열 | . | . 4. 순환 복잡도 . 한 프로그램의 논리적인 복잡도를 측정하기 위한 소프트웨어의 척도 . | 맥케이브 순환도 또는 맥케이브 복잡도 메트릭스라고도 함 . | 제어 프름도 이론에 기초를 둠 . | 제어 흐름도 G에서 순환 복잡도 V(G)는 다음과 같은 방법으로 계산 가능 . 순환 복잡도는 제어 흐름도의 영역 수와 일치하므로 영역 수를 계산 | V(G) = E - N + 2 : E는 화살표 수, N은 노드의 수 | . | 제어 흐름도가 다음과 같을 때 순환 복잡도를 계산하시오. . . 제어 흐름도에서 화살표로 구분되는 각 영역의 개수를 구하면 4 | 순환 복잡도 = 화살표의 수 - 노드의 수 + 2이므로 11 - 9 + 2 = 4 | | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/06/26/theory116.html",
            "relUrl": "/theory/2021/06/26/theory116.html",
            "date": " • Jun 26, 2021"
        }
        
    
  
    
        ,"post103": {
            "title": "애플리케이션 성능 분석",
            "content": "1. 애플리케이션 성능 . 최소한의 자원을 사용하여 최대한 많은 기능을 신속하게 처리하는 정도 | 성능 측정 지표 처리량: 일정 시간 내에 애플리케이션이 처리하는 일의 양 | 응답 시간: 애플리케이션에 요청을 전달한 시간부터 응답이 도착할 때까지 걸린 시간 | 경과 시간: 애플리케이션에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간 | 자원 사용률: 애플리케이션이 의뢰한 작업을 처리하는 동안의 CPU 사용량, 메모리 사용량, 네트워크 사용량 등 자원 사용률 | . | . 2. 성능 테스트 도구 . 애플리케이션의 성능을 테스트하기 위해 애플리케이션에 부하나 스트레스를 가하면서 애플리케이션의 성능 측정 지표를 점검하는 도구 . | 종류 . 도구명 도구 설명 지원 환경 . JMeter | HTTP, FTP 등 다양한 프로토콜을 지원하는 부하 테스트 도구 | Cross-Platform | . LoadUI | - 서버 모니터링, Drag&amp;Drop 등 사용자의 편리성이 강화된 부하 테스트 도구 | Cross-Platform | . OpenSTA | HTTP, HTTPS 프로토콜에 대한 부하 테스트 및 생산품 모니터링 도구 | Windows | . | . 3. 시스템 모니터링 도구 . 애플리케이션이 실행되었을 때 시스템 자원의 사용량을 확인하고 분석하는 도구 . | 종류 . 도구명 도구 설명 지원 환경 . Scouter | -단일 뷰 통합/실시간 모니터링, 튜닝에 최적화된 인프라 통합 모니터링 도구-애플리케이션의 성능을 모니터링/통제하는 도구 | Cross-Platform | . Zabbix | 웹기반 서버, 서비스, 애플리케이션 등의 모니터링 도구 | Cross-Platform | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/06/25/theory115.html",
            "relUrl": "/theory/2021/06/25/theory115.html",
            "date": " • Jun 25, 2021"
        }
        
    
  
    
        ,"post104": {
            "title": "결함 관리",
            "content": "1. 결함 . 오류 발생, 작동 실패 등과 같이 소프트웨어가 개발자가 설계한 것과 다르게 동작하거나 다른 결과가 발생되는 것 | 사용자가 예상한 결과와 실행 결과 간의 차이나 업무 내용과의 물일치 등으로 인해 변경이 필요한 부분도 모두 결함에 해당됨 | . 2. 결함 관리 프로세스 . 결함 관리 계획 전체 프로세스에 대한 결함 관리 일정, 인력, 업무 프로세스 등을 확보하여 계획 수립 | | 결함 기록 테스터는 발견된 결함을 결함 관리 DB에 등록함 | | 결함 검토 테스터, 프로그램 리더, 품질 관리(QA) 담당자 등은 등록된 결함을 검토하고 결함을 수정할 개발자에게 전달 | | 결함 수정 개발자는 전달받은 결함을 수정 | | 결함 재확인 테스터는 개발자가 수정한 내용을 확인하고 다시 테스트를 수행 | | 결함 상태 추적 및 모니터링 활동 결함 관리 DB를 이용하여 프로젝트별 결함 유형, 발생률 등을 한눈에 볼 수 있는 대시보드 또는 게시판 형태의 서비스를 제공 | | 최종 결함 분석 및 보고서 작성 발견된 결함에 대한 정보와 이해관계자들의 의견이 반영된 보고서를 작성하고 결함 관리를 종료 | | 3. 결함 상태 추적 . 테스트에서 발견된 결함은 지속적으로 상태 변화를 추적하고 관리해야 함 | 발견된 결함에 대해 결함 관리 측정 지표의 속성 값들을 분석하여 향후 결함이 발견될 모듈 또는 컴포넌트를 추정할 수 있음 | 결함 관리 측정 지표 결함 분포: 모듈 또는 컴포넌트의 특정 속성에 해당하는 결함 수 측정 | 결함 추세: 테스트 진행 시간에 따른 결함 수의 추이 분석 | 결함 에이징: 특정 결함 상태로 지속되는 시간 측정 | . | . 4. 결함 추적 순서 . 결함 등록 테스터와 품질 관리 담당자에 의해 발견된 결함이 등록된 상태 | | 결함 검토 등록된 결함이 테스터, 품질 관리 담당자, 프로그램 리더, 담당 모듈 개발자에 의해 검토된 상태 | | 결함 할당 결함을 수정하기 위해 개발자와 문제 해결 담당자에게 결함이 할당된 상태 | | 결함 수정 개발자가 결함 수정을 완료한 상태 | | 결함 조치 보류 결함의 수정이 불가능해 연기된 상태로, 우선순위, 일정 등에 따라 재오픈을 준비중인 상태 | | 결함 종료 결함이 해결되어 테스터와 품질 관리 담당자가 종료를 승인한 상태 | | 결함 해제 테스터, 프로그램 리더, 품질 관리 담당자가 종료 승인한 결함을 검토하여 결함이 아니라고 판명한 상태 | | 5. 결함 분류 . 시스템 결함: 애플리케이션 환경이나 데이터베이스 처리에서 발생된 결함 | 기능 결함: 애플리케이션의 기획, 설계, 업무 시나리오 등의 단계에서 유입된 결함 | GUI 결함: 사용자 화면 설계에서 발생된 결함 | 문서 결함: 기획자, 사용자, 개발자 간의 의사소통 및 기록이 원활하지 않아 발생된 결함 | . 6. 결함 심각도 . 애플리케이션에 발생한 결함이 전체 시스템에 미치는 치명도를 나타내는 척도 | High, Medium, Low 또는 치명적, 주요, 보통, 경미, 단순 등으로 분류 | . 7. 결함 우선순위 . 발견된 결함 처리에 신속성을 나타내는 척도 | 결함의 중요도와 심각도에 따라 설정되고 수정 여부가 결정됨 | 결정적, 높음, 보통, 낮음 또는 즉시 해결, 주의 요망, 대기, 개선 권고 등으로 분류됨 | . 8. 결함 관리 도구 . Mantis: 결함 및 이슈 관리 도구로 소프트웨어 설계 시 단위별 작업 내용을 기록할 수 있어 결함 추적도 가능한 도구 | Trac: 결함 추적은 물론 결함을 통합하여 관리할 수 있는 도구 | Redmine: 프로젝트 관리 및 결함 추적이 가능한 도구 | Bugzilla: 결함 신고, 확인, 처리 등 결함을 지속적으로 관리할 수 있는 도구. 결함의 심각도와 우선순위를 지정할 수도 있음 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/06/24/theory114.html",
            "relUrl": "/theory/2021/06/24/theory114.html",
            "date": " • Jun 24, 2021"
        }
        
    
  
    
        ,"post105": {
            "title": "테스트 자동화 도구",
            "content": "1. 테스트 자동화 . 사람이 반복적으로 수행하던 테스트 절차를 스크립트 형태로 구현하는 자동화 도구를 적용함으로써 쉽고 효율적으로 테스트를 수행할 수 있도록 한 것임 | 테스트 유형에 따른 테스트 자동화 도구의 종류 정적 분석 도구 | 테스트 실행 도구 | 성능 테스트 도구 | 테스트 통제 도구 | . | . 2. 정적 분석 도구(Static Analysis Tools) . 프로그램을 실행하지 않고 분석하는 도구 | 소스 코드에 대한 코딩 표준, 코딩 스타일, 코드 복잡도 및 남은 결함 등을 발견하기 위해 사용 | . 3. 테스트 실행 도구(Test Execution Tools) . 스크립트 언어를 사용하여 테스트를 실행하는 도구 | 테스트 데이터와 테스트 수행 방법 등이 포함된 스크립트를 작성한 후 실행 | 데이터 주도 접근 방식: 스프레드시트에 테스트 데이터를 저장하고, 이를 읽어 실행하는 방식 | 키워드 주도 접근 방식: 스프레드시트에 테스트를 수행할 동작을 나타내는 키워드와 테스트 데이터를 저장하여 실행하는 방식 | . 4. 성능 테스트 도구(Performance Test Tools) . 애플리케이션의 처리량, 응답 시간, 경과 시간, 자원 사용률 등을 인위적으로 적용한 가상의 사용자를 만들어 테스트를 수행함으로써 성능의 목표 달성 여부를 확인하는 도구 | . 5. 테스트 통제 도구(Test Control Tools) . 테스트 계획 및 관리, 테스트 수행, 결함 관리 등을 수행하는 도구 | 종류: 형상 관리 도구, 결함 추적/관리 도구 등 | . 6. 테스트 하네스 도구(Test Harness Tools) . 테스트가 실행될 환경을 시뮬레이션 하여 컴포넌트 및 모듈이 정상적으로 테스트되도록 하는 도구 | 테스트 하네스: 애플리케이션의 컴포넌트 및 모듈을 테스트하는 환경의 일부분으로, 테스트를 지원하기 위해 생성된 코드와 데이터를 의미 | . 7. 테스트 하네스의 구성 요소 . 테스트 드라이버 테스트 대상의 하위 모듈을 호출하고, 파라미터를 전달하고, 모듈 테스트 수행 후의 결과를 도출하는 도구 | . | 테스트 스텁 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구로, 일시적으로 필요한 조건만을 가지고 있는 테스트용 모듈 | . | 테스트 슈트 테스트 대상 컴포넌트나 모듈, 시스템에 사용되는 테스트 케이스의 집합 | . | 테스트 케이스 사용자의 요구사항을 정확하게 준수했는지 확인하기 위한 입력 값, 실행 조건, 기대 결과 등으로 만들어진 테스트 항목의 명세서 | . | 테스트 스크립트 자동화된 테스트 실행 절차에 대한 명세서 | . | 목 오브젝트 사전에 사용자의 행위를 조건부로 입력해 두면 그 상황에 맞는 예정된 행위를 수행하는 객체 | . | . 8. 테스트 수행 단계별 테스트 자동화 도구 . 테스트 단계 자동화 도구 설명 . 테스트 계획 | 요구사항 관리 | 사용자의 요구사항 정의 및 변경 사항 등을 관리하는 도구 | . 테스트 분석/설계 | 테스트 케이스 생성 | 테스트 기법에 따른 테스트 데이터 및 테스트 케이스 작성을 지원하는 도구 | . 테스트 수행 | 테스트 자동화 | 테스트의 자동화를 도와주는 도구로 테스트의 효율성을 높임 | .   | 정적 분석 | 코딩 표준, 런타임 오류 등을 검증하는 도구 | .   | 동적 분석 | 대상 시스템의 시뮬레이션을 통해 오류를 검출하는 도구 | .   | 성능 테스트 | 가상의 사용자를 생성하여 시스템의 처리 능력을 측정하는 도구 | .   | 모니터링 | CPU, Memory 등과 같은 시스템 자원의 상태 확인 및 분석을 지원하는 도구 | . 테스트 관리 | 커버리지 분석 | 테스트 완료 후 테스트의 충분성 여부 검증을 지원하는 도구 | .   | 형상 관리 | 테스트 수행에 필요한 다양한 도구 및 데이터를 관리하는 도구 | .   | 결함 추적/관리 | 테스트 시 발생한 결함 추적 및 관리 활동을 지원하는 도구 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/06/23/theory113.html",
            "relUrl": "/theory/2021/06/23/theory113.html",
            "date": " • Jun 23, 2021"
        }
        
    
  
    
        ,"post106": {
            "title": "테스트 케이스/테스트 시나리오/테스트 오라클",
            "content": "1. 테스트 케이스(Test Case) . 구현된 소프트웨어가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위해 설계된 입력 값, 실행 조건, 기대 결과 등으로 구성된 테스트 항목에 대한 명세서 | 미리 설계하면 테스트 오류 방지, 테스트 수행에 필요한 인력, 시간 등의 자원 낭비를 줄일 수 있음 | . 2. 테스트 시나리오(Test Scenario) . 테스트 케이스를 적용하는 순서에 따라 여러 개의 테스트 케이스를 묶은 집합 | 테스트 케이스를 적용하는 구체적인 절차를 명세함 | 테스트 순서에 대한 구체적인 절차, 사전 조건, 입력 데이터 등이 설정되어 있음 | . 3. 테스트 오라클(Test Oracle) . 테스트 결과가 올바른지 판단하기 위해 사전에 정의된 참 값을 대입하여 비교하는 기법 | 결과를 판단하기 위해 테스트 케이스에 대한 예상 결과를 계산하거나 확인함 | 특징 제한된 검증: 모든 테스트에 적용 불가능 | 수학적 기법: 테스트 오라클의 값을 수학적 기법을 이용해 구할 수 있음 | 자동화 기능: 프로그램의 실행, 결과 비교, 커버리지 측정 등 자동화 가능 | . | . 4. 테스트 오라클의 종류 . 참(True) 오라클 모든 테스트 케이스의 입력 값에 대해 기대하는 결과 제공 | 발생된 모든 오류 검출 가능 | . | 샘플링(Sampling) 오라클 특정한 몇몇 테스트 케이스의 입력 값들에 대해서만 기대하는 결과를 제공하는 오라클로 전수 테스트가 불가능한 경우 사용 | . | 추정(Heuristic) 오라클 특정 테스트 케이스의 입력 값에 대해 기대하는 결과를 제공하고 나머지 입력 값들에 대해서는 추정으로 처리 | . | 일관성 검사(Consistent) 오라클 애플리케이션에 변경이 있을 때 테스트 케이스의 수행 전과 후의 결과 값이 동일한지를 확인 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/06/22/theory112.html",
            "relUrl": "/theory/2021/06/22/theory112.html",
            "date": " • Jun 22, 2021"
        }
        
    
  
    
        ,"post107": {
            "title": "애플리케이션 테스트 프로세스",
            "content": "1. 애플리케이션 테스트 프로세스 . 개발된 소프트웨어가 사용자의 요구대로 만들어졌는지, 결함은 없는지 등을 테스트하는 절차 | . 테스트 계획 프로젝트 계획서, 요구 명세서 등을 기반으로 테스트 목표를 정의하고 테스트 대상 및 범위를 결정 | | 테스트 분석 및 디자인 테스트의 목적과 원칙을 검토하고 사용자의 요구 사항을 분석 | | 테스트 케이스 및 시나리오 작성 테스트 케이스를 작성하고 검토하고 확인한 다음 테스트 시나리오를 작성 | | 테스트 수행 테스트 환경을 구축한 후 테스트 수행 | | 테스트 결과 평가 및 리포팅 테스트 결과를 비교 분석하여 테스트 결과서를 작성 | | 결함 추적 및 관리 테스트한 후 결함 발생 위치나 종류 등 결함을 추적하고 관리 | | 2. 결함 관리 프로세스 . 에러 발견 에러가 발견되면 테스트 전문가와 프로젝트팀이 논의 | | 에러 등록 발견된 에러를 결함 관리 대장에 등록 | | 에러 분석 등록된 에러가 실제 결함인지 아닌지를 분석 | | 결함 확정 등록된 에러가 실제 결함이면 결함 확정 상태로 설정 | | 결함 할당 결함을 해결할 담당자에게 결함을 할당하고 결함 할당 상태로 설정 | | 결함 조치 결함을 수정하고 수정이 완료되면 결함 조치 상태로 설정 | | 결함 조치 검토 및 승인 수정이 완료된 결함에 대해 확인 테스트를 수행하고, 이상이 없으면 결함 조치 완료 상태로 설정 | |",
            "url": "https://eunkyung99.github.io/gang/theory/2021/06/21/theory111.html",
            "relUrl": "/theory/2021/06/21/theory111.html",
            "date": " • Jun 21, 2021"
        }
        
    
  
    
        ,"post108": {
            "title": "통합 테스트",
            "content": "1. 통합 테스트 . 단위 테스트가 끝난 모듈을 통합하는 과정에서 발생하는 오류 및 결함을 찾는 테스트 기법 | 종류 비점진적 통합 방식 | 점진적 통합 방식 | . | . 2. 하향식 통합 테스트(Top Down Integration Test) . 프로그램의 상위 모듈에서 하위 모듈 방향으로 통합하면서 테스트하는 기법 | 깊이 우선 통합법이나 넓이 우선 통합법을 사용 | 절차 | . 주요 제어 모듈은 작성된 프로그램을 사용하고, 주요 제어 모듈의 종속 모듈들은 스텁으로 대체함 | 깊이 우선 또는 넓이 우선 등의 통합 방식에 따라 하위 모듈인 스텁들이 한 번에 하나씩 실제 모듈로 교체됨 | 모듈이 통합될 때마다 테스트 실시 | 새로운 오류가 발생하지 않음을 보증하기 위해 회귀 테스트 실시 | 3. 상향식 통합 테스트(Bottom Up Integration Test) . 프로그램의 하위 모듈에서 상위 모듈 방향으로 통합하면서 테스트하는 기법 | 절차 | . 하위 모듈들을 클러스터로 결합 | 상위 모듈에서 데이터의 입.출력을 확인하기 위해 더미 모듈인 드라이버를 작성 | 통합된 클러스터 단위로 테스트함 | 테스트가 완료되면 클러스터는 프로그램 구조의 상위로 이동하여 결합하고 드라이버는 실제 모듈로 대체됨 | 4. 혼합식 통합 테스트 . 하위 수준에서는 상향식 통합, 상위 수준에서는 하향식 통합을 사용하여 최적의 테스트를 지원하는 방식 | 샌드위치식 통합 테스트 방법이라고도 함 | . 5. 회귀 테스팅(Regression Testing) . 통합 테스트로 인해 변경된 모듈이나 컴포넌트에 새로운 오류가 있는지 확인하는 테스트 | 이미 테스트된 프로그램의 테스팅을 반복하는 것 | 회귀 테스트는 수정한 모듈이나 컴포넌트가 다른 부분에 영향을 미치는지, 오류가 생기지 않았는지 테스트하여 새로운 오류가 발생하지 않음을 보충하기 위해 반복 테스트함 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/06/20/theory110.html",
            "relUrl": "/theory/2021/06/20/theory110.html",
            "date": " • Jun 20, 2021"
        }
        
    
  
    
        ,"post109": {
            "title": "개발 단계에 따른 애플리케이션 테스트",
            "content": "1. 개발 단계에 따른 애플리케이션 테스트 . 소프트웨어의 개발 단계에 따라 단위 테스트, 통합 테스트, 시스템 테스트, 인수 테스트로 분류됨. 이렇게 분류된 것을 테스트 레벨이라고 함 | 애플리케이션 테스트와 소프트웨어 개발 단계를 연결하여 표현한 것을 V-모델이라고 함 | | . 2. 단위 테스트(Unit Test) . 코딩 직후 소프트웨어 설계의 최소 단위인 모듈이나 컴포넌트에 초점을 맞춰 테스트하는 것 | 인터페이스, 외부적 I/O, 자료 구조, 독립적 기초 경로, 오류 처리 경로, 경계 조건 등을 검사 | 사용자의 요구사항을 기반으로 한 기능성 테스트를 최우선으로 수행함 | 구조 기반 테스트와 명세 기반 테스트로 나뉘지만 주로 구조 기반 테스트를 시행함 | . 3. 통합 테스트(Integration Test) . 단위 테스트가 완료된 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트 | 모듈 간 또는 통합된 컴포넌트 간의 상호 작용 오류를 검사함 | . 4. 시스템 테스트(System Test) . 개발된 소프트웨어가 해당 컴퓨터 시스템에서 완벽하게 수행되는가를 점검하는 테스트 | 기능적 요구사항과 비기능적 요구사항으로 구분하여 각각을 만족하는지 테스트 | . 5. 인수 테스트(Acceptance Test) . 개발한 소프트웨어가 사용자의 요구사항을 충족하는지에 중점을 두고 테스트하는 방법 | 개발한 소프트웨어를 사용자가 직접 테스트 | 종류 사용자 인수 테스트 사용자가 시스템 사용의 적절성 여부를 확인 | . | 운영상의 인수 테스트 시스템 관리자가 시스템 인수 시 수행하는 테스트 기법 | 백업/복원 시스템, 재난 복구, 사용자 관리, 정기 점검 등을 확인 | . | 계약 인수 테스트 계약상의 인수/검수 조건을 준수하는지 여부 확인 | . | 규정 인수 테스트 소프트웨어가 정부 지침, 법규, 규정 등 규정에 맞게 개발되었는지 확인 | . | 알파 테스트 개발자의 장소에서 사용자가 개발자 앞에서 행하는 테스트 기법 | 통제된 환경에서 행해지며, 오류와 사용상의 문제점을 사용자와 개발자가 함께 확인하면서 기록 | . | 베타 테스트 선정된 최종 사용자가 여러 명의 사용자 앞에서 행하는 테스트 기법 | 실업무를 가지고 사용자가 직접 테스트 | . | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/06/19/theory109.html",
            "relUrl": "/theory/2021/06/19/theory109.html",
            "date": " • Jun 19, 2021"
        }
        
    
  
    
        ,"post110": {
            "title": "테스트 기법에 따른 애플리케이션 테스트",
            "content": "1. 화이트박스 테스트(White Box Test) . 모듈의 원시 코드를 오픈시킨 상태에서 원시 코드의 논리적인 모든 경로를 테스트하여 테스트 케이스를 설계하는 방법 | 모듈 안의 작동을 직접 관찰 | 원시 코드(모듈)의 모든 문장을 한 번 이상 실행함으로써 수행됨 | . 2. 화이트박스 테스트의 종류 . 기초 경로 검사 테스트 케이스 설계자가 절차적 설계의 논리적 복잡성을 측정할 수 있게 해주는 테스트 기법 | 대표적 화이트박스 테스트 기법 | . | 제어 구조 검사 조건 검사(Condition Testing): 프로그램 모듈 내에 있는 논리적 조건을 테스트하는 테스트 케이스 설계 기법 | 루프 검사: 프로그램의 반복 구조에 초점을 맞춰 실시하는 테스트 케이스 설계 기법 | 데이터 흐름 검사: 프로그램에서 변수의 정의와 변수 사용의 위치에 초점을 맞춰 실시하는 테스트 케이스 설계 기법 | . | . 3. 화이트박스 테스트의 검증 기준 . 문장 검증 기준 소스 코드의 모든 구문이 한 번 이상 수행되도록 테스트 케이스를 설계 | . | 분기 검증 기준 - 모든 조건문 소스 코드의 모든 조건문이 한 번 이상 수행되도록 테스트 케이스 설계 | . | 조건 검증 기준 -조건문 참, 거짓 한 번씩 소스 코드의 모든 조건문에 대해 조건문이 참인 경우와 거짓인 경우가 한 번 이상 수행되도록 테스트 케이스를 설계 | . | 분기/조건 기준 분기+조건 소스 코드의 모든 조건문과 각 조건문에 포함된 개별 조건식의 결과가 참인 경우와 거짓인 경우가 한 번 이상 수행되도록 테스트 케이스를 설계 | . | . 4. 블랙박스 테스트(Black Box Test) = 기능 테스트 . 소프트웨어가 수행할 특정 기능을 알기 위해 각 기능이 완전히 작동되는 것을 입증하는 테스트. 기능 테스트라고도 함 | 사용자의 요구사항 명세를 보면서 테스트 | 주로 구현된 기능을 테스트 | 소프트웨어 인터페이스를 통해 실시됨 | . 5. 블랙박스 테스트의 종류 . 동치 분할 검사(Equivalence Partitioning Testing, 동치 클래스 분해) 프로그램의 입력 조건에 타당한 입력 자료와 타당하지 않은 입력 자료의 개수를 균등하게 하여 테스트 케이스를 정하고, 해당 입력 자료에 맞는 결과가 출력되는지 확인하는 기법 | 동등 분할 기법이라고도 함 | . | 경계값 분석(Boundary Value Analysis) 입력 조건의 중간값보다 경계값에서 오류가 발생될 확률이 높다는 점을 이용하여 입력 조건의 경계값을 테스트 케이스로 선정하여 검사하는 기법 | . | 원인-효과 그래프 검사(Cause-Effect Graphing Testing) 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석한 다음 효용성이 높은 테스트 케이스를 선정하여 검사하는 기법 | . | 오류 예측 검사(Error Guessing) 과거의 경험이나 확인자의 감각으로 테스트하는 기법 | . | 비교 검사(Comparison Testing) 여러 버전의 프로그램에 동일한 테스트 자료를 제공하여 동일한 결과가 출력되는지 테스트하는 기법 | . | 예) A 애플리케이션에서 평가점수에 따른 성적부여 기준이 다음과 같을 때, 동치 분할 검사와 경계값 분석의 테스트 케이스를 확인하시오. | | 동치 분할 검사는 입력 자료에 초점을 맞춰 테스트 케이스를 만들어 검사하므로 평가점수를 입력한 후 점수에 맞는 성적이 출력되는지 확인함 | | 경계값 분석은 입력 조건의 경계값을 테스트 케이스로 선정하여 검사하므로 평가점수의 경계값에 해당하는 점수를 입력한 후 올바른 성적이 출력되는지 확인함 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/06/18/theory108.html",
            "relUrl": "/theory/2021/06/18/theory108.html",
            "date": " • Jun 18, 2021"
        }
        
    
  
    
        ,"post111": {
            "title": "애플리케이션 테스트의 분류",
            "content": "1. 프로그램 실행 여부에 따른 테스트 . 정적 테스트 프로그램을 실행하지 않고 명세서나 소스 코드를 대상으로 분석하는 테스트 | 소스 코드에 대한 코딩 표준, 코딩 스타일, 코드 복잡도, 남은 결함 등을 발견하기 위해 사용 | 종류: 워크스루, 인스펙션, 코드 검사 등 | . | 동적 테스트 프로그램을 실행하여 오류를 찾는 테스트 | 소프트웨어 개발의 모든 단계에서 테스트를 수행 | 종류: 블랙박스 테스트, 화이트박스 테스트 | . | . 2. 테스트 기반에 따른 테스트 . 명세 기반 테스트 사용자의 요구사항에 대한 명세를 빠짐없이 테스트 케이스로 만들어 구현하고 있는지 확인하는 테스트 | 종류: 동등 분할, 경계 값 분석 등 | . | 구조 기반 테스트 소프트웨어 내부의 논리 흐름에 따라 테스트 케이스를 작성하고 확인하는 테스트 | 종류: 구문 기반, 결정 기반, 조건 기반 등 | . | 경험 기반 테스트 유사 소프트웨어나 기술 등에 대한 테스터의 경험을 기반으로 수행하는 테스트 | 사용자의 요구사항에 대한 명세가 불충분하거나 테스트 시간에 제약이 있는 경우 수행하면 효과적임 | 종류: 에러 추정, 체크 리스트, 탐색적 테스팅 | . | . 3. 시각에 따른 테스트 . 검증 테스트 개발자의 시각에서 제품의 생산 과정을 테스트하는 것 | 제품이 명세서대로 완성됐는지를 테스트 | . | 확인 테스트 사용자의 시각에서 생산된 제품의 결과를 테스트하는 것 | 사용자가 요구한대로 제품이 완성됐는지, 제품이 정상적으로 동작하는지를 테스트 | . | . 4. 목적에 따른 테스트 . 회복 테스트 시스템에 여러 가지 결함을 주어 실패하도록 한 후 올바르게 복구되는지 확인 | . | 안전 테스트 시스템에 설치된 시스템 보호 도구가 불법적인 침입으로부터 시스템을 보호할 수 있는지 확인 | . | 강도 테스트 시스템에 과도한 정보량이나 빈도 등을 부과하여 과부하 시에도 소프트웨어가 정상적으로 실행되는지 확인 | . | 성능 테스트 소프트웨어의 실시간 성능이나 전체적인 효율성을 진단. 소프트웨어의 응답 시간, 처리량 등을 테스트 | . | 구조 테스트 소프트웨어 내부의 논리적인 경로, 소스 코드의 복잡도 등을 평가하는 테스트 | . | 회귀 테스트 소프트웨어의 변경 또는 수정된 코드에 새로운 결함이 없음을 확인 | . | 병행 테스트 변경된 소프트웨어와 기존 소프트웨어와 동일한 데이터를 입력하여 결과를 비교 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/06/17/theory107.html",
            "relUrl": "/theory/2021/06/17/theory107.html",
            "date": " • Jun 17, 2021"
        }
        
    
  
    
        ,"post112": {
            "title": "애플리케이션 테스트",
            "content": "1. 애플리케이션 테스트 . 애플리케이션에 잠재되어 있는 결함을 찾아내는 일련의 행위 또는 절차 | 개발된 소프트웨어가 고객의 요구사항을 만족시키는지 확인하고 소프트웨어가 기능을 정확히 수행하는지 검증함 | . 2. 애플리케이션 테스트의 기본 원리 . 완벽한 테스트 불가능 . 소프트웨어의 잠재적인 결함을 줄일 수 있지만 소프트웨어에 결함이 없다고 증명할 수는 없음 | . | 파레토 법칙 . 애플리케이션의 20%에 해당하는 코드에서 전체 결함의 80%가 발견된다는 법칙 | . | 살충제 패러독스 . 동일한 테스트 케이스로 동일한 테스트를 반복하면 더 이상 결함이 발견되지 않는 현상 | . | 테스팅은 정황 의존 . 소프트웨어의 특징, 테스트 환경, 테스터의 역량 등 정황에 따라 테스트 결과가 달라질 수 있으므로 정황에 따라 테스트를 다르게 수행해야 함 | . | 오류-부재의 궤변 . 소프트웨어의 결함을 모두 제거해도 사용자의 요구사항을 만족시키지 못하면 해당 소프트웨어는 품질이 높다고 말할 수 없는 것 | . | 테스트와 위험은 반비례 . 테스트를 많이 하면 할수록 미래에 발생할 위험을 줄일 수 있음 | . | 테스트의 점진적 확대 . 작은 부분에서 시작하여 점점 확대하며 진행해야 함 | . | 테스트의 별도 팀 수행 . 개발자와 관계없는 별도의 팀에서 수행해야 함 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/06/16/theory106.html",
            "relUrl": "/theory/2021/06/16/theory106.html",
            "date": " • Jun 16, 2021"
        }
        
    
  
    
        ,"post113": {
            "title": "HCI/UX/감성공학",
            "content": "1. HCI(Human Computer Interaction or Interface) . 사람이 시스템을 보다 편리하고 안전하게 사용할 수 있도록 연구하고 개발하는 학문 | 최종 목표: 시스템을 사용하는데 있어 최적의 사용자 경험(UX)을 만드는 것 | 어떤 제품이 좋은 제품인지, 어떻게 하면 좋은 제품을 만들 수 있는지 등을 연구 | . 2. UX(User Experience) . 사용자가 시스템이나 서비스를 이용하면서 느끼고 생각하게 되는 총체적인 경험 | UI가 사용성, 접근성, 편의성을 중시한다면 UX는 이러한 UI를 통해 사용자가 느끼는 만족이나 감정을 중시 | 기술을 효용성 측면에서만 보는 것이 아니라 사용자의 삶의 질을 향상시키는 하나의 방향으로 보는 새로운 개념 | 특징 주관성: 사람들의 개인적, 신체적, 인지적 특성에 따라 다르므로 주관적임 | 정황성: 경험이 일어나는 상황 또는 주변 환경에 영향을 받음 | 총체성: 개인이 느끼는 총체적인 심리적, 감성적인 결과 | . | . 3. 감성공학 . 제품이나 작업환경을 사용자의 감성에 알맞도록 설계 및 제작하는 기술 | 인문사회과학, 공학, 의학 등 여러 분야의 학문이 공존하는 종합과학임 | 목적: 인간의 삶을 편리하고 안전하며 쾌적하게 만드는 것 | 인간의 감성을 구체적으로 제품 설계에 적용하기 위해 공학적인 접근 방법을 사용 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/06/15/theory105.html",
            "relUrl": "/theory/2021/06/15/theory105.html",
            "date": " • Jun 15, 2021"
        }
        
    
  
    
        ,"post114": {
            "title": "UI 설계",
            "content": "1. UI 설계서 . 사용자의 요구사항을 바탕으로 UI 설계를 구체화하여 작성하는 문서 | UI 설계서는 기획자, 개발자, 디자이너 등과의 원활한 의사소통을 위해 작성 | 작성 순서 | . UI 설계서 표지 작성 다른 문서와 혼동되지 않도록 프로젝트명 또는 시스템명을 포함하여 작성 | | UI 설계서 개정 이력 작성 수정될 때마다 어떤 부분이 어떻게 수정되었는지를 정리 | | UI 요구사항 정의서 작성 사용자의 요구사항을 확인하고 정리 | | 시스템 구조 작성 UI 요구사항과 UI 프로토타입에 기초하여 전체 시스템의 구조를 설계함 | | 사이트 맵 작성 사이트에 표시할 콘텐츠를 메뉴별로 구분하여 설계 | | 프로세스 정의서 작성 사용자가 요구하는 프로세스들을 작업 진행 순서에 맞춰 정리 | | 화면 설계 필요한 화면을 페이지별로 설계함 | | 2. UI 흐름 설계 . 업무의 진행 과정이나 수행 절차에 따른 흐름을 파악하여 화면과 폼을 설계하는 단계 | 순서 | . 기능 작성 화면에 표현할 기능을 작성 | | 입력 요소 확인 화면에 표현되어야 할 기능을 확인한 후 화면에 입력할 요소를 확인 | | 유스케이스 설계 UI 요구사항을 기반으로 UI 유스케이스를 설계 | | 기능 및 양식 확인 텍스트 박스, 콤보 박스, 라디오 박스, 체크 박스 등을 확인하고 규칙을 정의 | | 3. UI 상세 설계 . UI 설계서를 바탕으로 실제 설계 및 구현을 위해 모든 화면에 대해 자세하게 설계를 진행하는 단계임 | 반드시 시나리오를 작성해야 함 . | 순서 | . 요구사항 확인 UI 상세 설계를 위한 요구사항을 최종적으로 확인 | | UI 설계서 표지 및 계정 이력 작성 표지: 다른 문서와 혼동되지 않도록 프로젝트명이나 시스템명을 포함함 | 개정 이력: UI 설계서의 수정사항을 정리함 | | UI 구조 설계 UI 요구사항과 UI 프로토타입에 기초하여 UI 구조를 설계하는 단계 | | 메뉴 구조 설계 사이트 맵 구조를 설계한 후 이를 바탕으로 사용자 기반 메뉴 구조를 설게 | | 화면 설계 UI 프로토타입과 UI 프로세스를 참고하여 필요한 화면을 페이지별로 설계함 | | 4. UI 시나리오 문서 . 사용자 인터페이스의 기능 구조, 대표 화면, 화면 간 인터랙션의 흐름, 다양한 상황에서의 예외 처리 등을 정리한 문서 | 사용자가 최종 목표를 달성하기 위한 방법이 순차적으로 묘사되어 있음 | UI 시나리오 문서의 요건 완전성: 누락되지 않도록 최대한 상세하게 기술 | 일관성: 서비스 목표, 시스템 및 사용자의 요구사항, UI Tㅡ타일 등이 모두 일관성을 유지해야 함 | 이해성: 누구나 쉽게 이해할 수 있도록 설명 | 가독성: 표준화된 템플릿 등을 활용하여 문서를 쉽게 읽을 수 있도록 해야 함 | 수정 용이성: 시나리오의 수정이나 개선이 쉬워야 함 | 추적 용이성: 변경 사항은 언제, 어떤 부분이, 왜 발생했는지 쉽게 추적할 수 있어야 함 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/06/14/theory104.html",
            "relUrl": "/theory/2021/06/14/theory104.html",
            "date": " • Jun 14, 2021"
        }
        
    
  
    
        ,"post115": {
            "title": "품질 요구사항",
            "content": "1. 품질 요구사항 . 소프트웨어 품질은 소프트웨어에 대한 요구사항이 사용자의 입장에서 얼마나 충족하는가를 나타내는 소프트웨어 특성의 총체임 | 사용자의 요구사항을 충족시킴으로써 확립됨 | 소프트웨어 품질 관련 표준 ISO/IEC 9126 소프트웨어의 품질 특성과 평가를 위한 국제 표준 | . | ISO/IEC 25010 ISO/IEC 9126에 호환성과 보안성을 강화하여 개정한 소프트웨어 제품에 대한 국제 표준 | . | ISO/IEC 12119 패키지 소프트웨어의 일반적인 제품 품질 요구사항 및 테스트를 위한 국제 표준 | . | ISO/IEC 14598 소프트웨어 품질의 측정과 평가에 필요 절차를 규정한 표준 | . | . | . 2. ISO/IEC 9126의 소프트웨어 품질 특성 . 기능성 소프트웨어가 사용자의 요구사항을 정확하게 만족하는 기능을 제공하는지 여부 | 하위 특성: 적절성/적합성, 정밀성/정확성, 상호 운용성, 보안성, 준수성 | . | 신뢰성 주어진 시간동안 주어진 기능을 오류 없이 수행할 수 있는 정도를 나타냄 | 하위 특성: 성숙성, 고장 허용성, 회복성 | . | 사용성 사용자와 컴퓨터 사이에 발생하는 어떠한 행위에 대하여 사용자가 정확하게 이해하고 사용하며 향후 다시 사용하고 싶은 정도를 나타냄 | 하위 특성: 이해성, 학습성, 운용성, 친밀성 | . | 효율성 사용자가 요구하는 기능을 얼마나 빠르게 처리할 수 있는지 정도 | 하위 특성: 시간 효율성, 자원 효율성 | . | 유지 보수성 환경의 변화 또는 새로운 요구사항이 발생했을 때 소프트웨어를 개선하거나 확장할 수 있는 정도를 나타냄 | 하위 특성: 분석성, 변경성, 안정성, 시험성 | . | 이식성 소프트웨어가 다른 환경에서도 얼마나 쉽게 적용할 수 있는지 정도 | 하위 특성: 적용성, 설치성, 대체성, 공존성 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/06/13/theory103.html",
            "relUrl": "/theory/2021/06/13/theory103.html",
            "date": " • Jun 13, 2021"
        }
        
    
  
    
        ,"post116": {
            "title": "UI 요구사항 확인",
            "content": "1. UI 요구사항 확인 . 새로 개발할 시스템에 적용할 UI 관련 요구사항을 조사해서 작성하는 단계 | 다양한 경로를 통해 사용자의 요구사항을 조사하고 분석한 후 작성해야 함 | 순서 목표 정의: 사용자들을 인터뷰한 후 사용자들의 의견이 수렴된 비즈니스 요구사항 정의 | 활동 사항 정의: 조사한 요구사항을 토대로 앞으로 해야 할 활동 사항 정의 | UI 요구사항 작성: UI 요구사항을 UI 개발 목적에 맞게 실사용자 중심으로 작성 | | . 2. UI 요구사항 작성 순서 . 요구사항 요소 확인: 파악된 요구사항 요소의 종류와 각각의 표현 방식 등을 검토 | 정황 시나리오 작성: 사용자가 목표를 달성하기 위해 수행하는 방법을 순차적으로 묘사 | 요구사항 작성: 정황 시나리오를 토대로 요구사항 작성 | 3. 요구사항 요소 . 데이터 요구 사용자가 요구하는 모델과 객체들의 주요 특성을 기반으로 하여 데이터 객체들을 정리 | . | 기능 요구 사용자의 목적 달성을 위해 무엇을 실행해야 하는지를 동사형으로 설명 | . | 제품/서비스의 품질 데이터 및 기능 요구 외에 제품의 품질, 서비스, 여기에 감성적인 품질 등을 고려하여 작성 | . | 제약 사항 제품 완료 데드라인, 전체 개발 및 제작에 필요한 비용, 시스템 준수에 필요한 규제가 포함됨 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/06/12/theory102.html",
            "relUrl": "/theory/2021/06/12/theory102.html",
            "date": " • Jun 12, 2021"
        }
        
    
  
    
        ,"post117": {
            "title": "UI 설계 도구",
            "content": "1, 와이어프레임(WireFrame) . 페이지에 대한 개략적인 레이아웃이나 UI 요소 등에 대한 뼈대를 설계하는 도구 | 기획 단계의 초기에 제작함 | 개발자나 디자이너 등이 레이아웃을 협의하거나 현재 진행 상태 등을 공유하기 위해 사용 | 페이지의 영역 구분, 콘텐츠, 텍스트 배치 등을 화면 단위로 설계 | 와이어프레임 툴: 손그림, 파워포인트, 키노트, 스케치, 일러스트, 포토샵 등 | . 2. 목업(Mockup) . 와이어프레임보다 좀 더 실제 화면과 유사하게 만든 정적인 형태와 모형 | 디자인, 사용 방법 설명, 평가 등을 위해 만듦 | 시각적으로만 구성 요소를 배치하는 것으로 실제로 구현 되지는 않음 | 목업 툴: 파워 목업, 발사믹 목업 등 | . 3. 스토리보드(Story Board) . 와이어프레임에 콘텐츠에 대한 설명, 페이지 간 이동 흐름 등을 추가한 문서 | 디자이너와 개발자가 최종적으로 참고하는 지침서 | 서비스 구축을 위한 모든 정보가 들어 있음 | 스토리보드 툴: 파워포인트, 키노트, 스케치, Axure 등 | . 4. 프로토타입(Prototype) . 와이어프레임이나 스토리보드 등에 인터랙션을 적용함으로써 실제 구현된 것처럼 테스트가 가능한 동적인 형태의 모형 | 사용자의 요구사항을 개발자가 맞게 해석했는지 검증하기 위한 것 | 일부 핵심적인 기능만을 제공 | 페이퍼 프로토타입 스케치, 그림, 글 등을 이용하여 손으로 직접 작성하는 아날로그적인 방법 | 제작 기간이 짧은 경우, 제작 비용이 적을 경우, 업무 협의가 빠를 경우 사용 | . | 디지털 프로토타입 파워포인트, 아크로뱃, 비지오, 옴니그래플 등과 같은 프로그램을 사용하여 작성하는 방법 | 재사용이 필요한 경우, 산출물과 비슷한 효과가 필요한 경우, 숙련된 전문가가 있을 경우 사용 | . | . 5. 유스케이스(Use Case) . 사용자의 요구사항을 기능 단위로 표현하는 것 | 사용자가 원하는 목표를 달성하기 위해 수행할 내용을 기술 | 사용자의 요구사항을 빠르게 파악함으로써 프로젝트의 초기에 시스템의 기능적인 요구를 결정하고 그 결과를 문서화할 수 있음 | 일반적으로 다이어그램 형식으로 묘사됨 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/06/11/theory101.html",
            "relUrl": "/theory/2021/06/11/theory101.html",
            "date": " • Jun 11, 2021"
        }
        
    
  
    
        ,"post118": {
            "title": "UI 표준 및 지침",
            "content": "1. UI 표준 및 지침 . UI 표준: 전체 시스템에 포함된 모든 UI에 공통적으로 적용될 내용으로, 화면 구성이나 화면 이동 등이 포함됨 | UI 지침: UI 요구사항, 구현 시 제약사항 등 UI 개발 과정에서 꼭 지켜야 할 공통의 조건 | . 2. UI 스타일 가이드 . 개발자나 디자이너들이 UI를 작성할 때 기준이 되는 규칙들 | 구동 환경, 레이아웃, 네비게이션 등을 정의 | . 3. UI 스타일 가이드 작성 순서 . 구동 환경 정의 . 컴퓨터 OS, 웹 브라우저, 모니터 해상도, 프레임 세트 등을 사용 환경에 적합하도록 규정함 | | 레이아웃 정의 . 화면 구조를 정의하고 각 영역의 메뉴를 구성 | | 네비게이션 정의 . 네비게이션의 메뉴 타입을 선택하여 적용 | | 기능 정의 . 시스템에 적용할 업무 과정에서 일어나는 모든 활동이나 필요한 데이터 간의 관계 등을 논리적인 모델로 상세화 | | 구성 요소 정의 . 화면에 표시할 그리드나 버튼 등을 정의 | |",
            "url": "https://eunkyung99.github.io/gang/theory/2021/06/10/theory100.html",
            "relUrl": "/theory/2021/06/10/theory100.html",
            "date": " • Jun 10, 2021"
        }
        
    
  
    
        ,"post119": {
            "title": "사용자 인터페이스",
            "content": "1. 사용자 인터페이스(UI, User Interface) . 사용자와 시스템 간의 상호작용이 원활하게 이뤄지도록 도와주는 장치나 소프트웨어 | 세 가지 분야 정보 제공과 전달을 위한 물리적 제어에 관한 분야 | 콘텐츠의 상세적인 표현과 전체적인 구성에 관한 분야 | 모든 사용자가 편리하고 간편하게 사용하도록 하는 기능에 관한 분야 | . | . 2. 사용자 인터페이스의 구분 . CLI(Command Line Interface) 명령과 출력이 텍스트 형태로 이뤄지는 인터페이스 | . | GUI(Graphical User Interface) 아이콘이나 메뉴를 마우스로 선택하여 작업을 수행하는 그래픽 환경의 인터페이스 | . | NUI(Natural User Interface) 사용자의 말이나 행동으로 기기를 조작하는 인터페이스 | . | . 3. 사용자 인터페이스의 기본 원리 . 직관성: 누구나 쉽게 이해하고 사용할 수 있어야 함 | 유효성: 사용자의 목적을 정확하고 완벽하게 달성해야 함 | 학습성: 누구나 쉽게 배우고 익힐 수 있어야 함 | 유연성: 사용자의 요구사항을 최대한 수용하고 실수를 최소화해야 함 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/06/09/theory99.html",
            "relUrl": "/theory/2021/06/09/theory99.html",
            "date": " • Jun 9, 2021"
        }
        
    
  
    
        ,"post120": {
            "title": "인터페이스 구현 검증",
            "content": "1. 인터페이스 구현 검증 . 인터페이스가 정상적으로 문제 없이 작동하는지 확인하는 것 | 인터페이스 구현 검증 도구와 감시 도구를 이용하여 인터페이스의 동작 상태를 확인 | . 2. 인터페이스 구현 검증 도구 . 인터페이스 단위 기능과 시나리오 등을 기반으로 하는 통합 테스트가 필요함 | 통합 테스트를 수행하기 위해 사용하는 테스트 자동화 도구 | xUnit Java(Junit), C++(Cppunit), .Net(Nunit) 등 다양한 언어를 지원하는 단위 테스트 프레임워크 | . | STAF 서비스 호출 및 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크 | 크로스 플랫폼이나 분산 소프트웨어에서 테스트 환경을 조성할 수 있도록 지원 | 분산 소프트웨어의 경우 각 분산 환경에 설치된 데몬이 프로그램 테스트에 대한 응답을 대신하며, 테스트가 완료되면 이를 통합하고 자동화하여 프로그램을 완성함 | . | FitNesse 웹 기반 테스트 케이스 설계, 실행, 결과 확인 등을 지원하는 테스트 프레임워크 | . | NTAF Fitnesse의 장점인 협업 기능과 STAF의 장점인 재사용 및 확장성을 통합한 NHN(Naver)의 테스트 자동화 프레임워크 | . | Selenium 다양한 브라우저 및 개발 언어를 지원하는 웹 애플리케이션 테스트 프레임워크 | . | watir Ruby를 사용하는 애플리케이션 테스트 프레임워크 | . | . 3. 인터페이스 구현 감시 도구 . 인터페이스 동작 상태는 APM(애플리케이션 성능 관리)을 사용하여 감시할 수 있음 | APM을 통해 데이터베이스와 웹 애플리케이션의 트랜잭션, 변수값, 호출 함수, 로그 및 시스템 부하 등 종합적인 정보를 조회하고 분석할 수 있음 | 스카우터(Scouter) 애플리케이션 및 OS 자원에 대한 모니터링 기능을 제공하는 오픈소스 APM 소프트웨어 | . | 제니퍼(Jennifer) 애플리케이션의 개발부터 테스트, 오픈, 운영, 안정화까지, 전 단계에 걸쳐 성능을 모니터링하고 분석해주는 소프트웨어 | . | . 4. APM(Application Performance Management/Monitoring) . APM은 애플리케이션의 성능 관리를 위해 접속자, 자원 현황, 트랜잭션 수행 내역, 장애 진단 등 다양한 모니터링 기능을 제공하는 도구임 | 리소스 방식 Nagios, Zabbix, Cacti 등 | . | 엔드투엔드 방식 VisualVM, 제니퍼, 스카우터 등 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/06/08/theory98.html",
            "relUrl": "/theory/2021/06/08/theory98.html",
            "date": " • Jun 8, 2021"
        }
        
    
  
    
        ,"post121": {
            "title": "인터페이스 보안",
            "content": "1. 인터페이스 보안 . 인터페이스의 보안성 향상을 위해 인터페이스의 보안 취약점을 분석한 후 적절한 보안 기능을 적용하는 것 | . 2. 인터페이스 보안 기능 적용 . 네트워크 영역 인터페이스 송.수신 간 스니핑 등을 이용한 데이터 탈취 및 변조 위협을 방지하기 위해 네트워크 트래픽에 대한 암호화를 설정 | 암호화는 인터페이스 아키텍처에 따라 IPSec, SSL, S-HTTP 등의 다양한 방식으로 적용 | . | 애플리케이션 영역 소프트웨어 개발 보안 가이드를 참조하여 애플리케이션 코드 상의 보안 취약점을 보완하는 방향으로 애플리케이션 보안 기능 적용 | . | 데이터베이스 영역 데이터베이스, 스키마, 엔티티의 접근 권한과 프로시저, 트리거 등 데이터베이스 동작 객체의 보안 취약점에 보안 기능을 적용 | 개인 정보나 업무상 민감한 데이터의 경우 암호화나 익명화 등 데이터 자체의 보안 방안도 고려 | . | . 3. 데이터 무결성 검사 도구 . 인터페이스 보안 취약점을 분석하는데 사용되는 도구 | 데이터 무결성 검사 도구는 시스템 파일의 변경 유무를 확인하고, 파일이 변경되었을 경우 이를 관리자에게 알려줌 | 종류: Tripwire, AIDE, Samhain, Claymore, Slipwire, Fcheck 등 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/06/07/theory97.html",
            "relUrl": "/theory/2021/06/07/theory97.html",
            "date": " • Jun 7, 2021"
        }
        
    
  
    
        ,"post122": {
            "title": "인터페이스 예외 처리",
            "content": "1. 인터페이스 예외 처리 . 구현된 인터페이스가 동작하는 과정에서 기능상 예외 상황이 발생했을 때 이를 처리하는 절차 | 방법 데이터 통신을 이용한 방법 | 인터페이스 엔티티를 이용한 방법 | . | . 2. 데이터 통신을 이용한 인터페이스 예외 처리 . 인터페이스 객체의 송.수신 시 발생할 수 있는 예외 케이스를 정의하고 각 예외 케이스마다 예외 처리 방법 기술 | JSON, XML 등 인터페이스 객체를 이용해 구현한 인터페이스 동작이 실패할 경우를 대비한 것임 | . 3. 인터페이스 엔티티를 이용한 인터페이스 예외 처리 . 인터페이스 동작이 실패할 경우를 대비하여 해당 엔티티에 인터페이스의 실패 상황과 원인 등을 기록하고, 이에 대한 조치를 취할 수 있도록 사용자 및 관리자에서 알려주는 방식으로 예외 처리 방법 정의 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/06/06/theory96.html",
            "relUrl": "/theory/2021/06/06/theory96.html",
            "date": " • Jun 6, 2021"
        }
        
    
  
    
        ,"post123": {
            "title": "인터페이스 구현",
            "content": "1. 인터페이스 구현 . 송.수신 시스템 간의 데이터 교환 및 처리를 실현해주는 작업 | 방법 데이터 통신을 이용한 인터페이스 구현 | 인터페이스 엔티티를 이용한 인터페이스 구현 | . | . 2. 데이터 통신을 이용한 인터페이스 구현 . 애플리케이션 영역에서 데이터 포맷을 인터페이스 대상으로 전송하면 이를 수신 측에서 파싱하여 해석하는 방식 | 주로 JSON이나 XML 형식의 데이터 포맷을 사용하여 인터페이스를 구현 | JSON을 이용한 인터페이스 구현 순서 송신 측에서 인터페이스 객체를 생성할 데이터를 각 시스템 환경에 맞게 선택 | JSON을 이용해 데이터를 인터페이스 객체로 만든다. | 인터페이스 객체를 AJAX 기술 등을 이용해 수신 측으로 보냄 | 수신 측에서 인터페이스 객체를 수신해 파싱한 후 처리 | 수신 측에서 송신 측으로 처리 결과 보냄 | | . 3. 인터페이스 엔티티를 이용한 인터페이스 구현 . 인터페이스가 필요한 시스템 사이에 별도의 인터페이스 엔티티를 두어 상호 연계하는 것 | 일반적으로 인터페이스 테이블을 엔티티로 활용 | 인터페이스 테이블을 이용한 인터페이스 구현 순서 송신 측에서 인터페이스 이벤트가 발생하면 인터페이스 테이블에 인터페이스 데이터를 기록(write) | 송신 측 인터페이스 테이블에서 정해진 주기에 따라 인터페이스 데이터를 전송 | 수신 측 인터페이스 테이블에 인터페이스 데이터가 입력되면 정해진 주기에 따라 인터페이스 데이터를 읽음(read) | 수신 측 인터페이스 테이블에서 인터페이스 데이터를 읽은 후 사전에 정의된 데이터 트랜잭션을 수행 | | . 4. JSON(JavaScript Object Notation) . JSON은 웹과 컴퓨터 프로그램에서 용량이 적은 데이터를 교환하기 위해 데이터 객체를 속성.값의 쌍(Attribute-Value Pairs) 형태로 표현하는 개방형 표준 포맷 | 비동기 처리에 사용되는 AJAX에서 XML을 대체하여 사용되고 있음 | . 5. AJAX(Asynchronous JavaScript and XML) . 자바 스크립트를 사용하여 클라이언트와 서버 간에 XML 데이터를 주고 받는 비동기 통신 기술 | 전체 페이지를 새로 고치지 않아도 웹 페이지 일부 영역만을 업데이트할 수 있음 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/06/05/theory95.html",
            "relUrl": "/theory/2021/06/05/theory95.html",
            "date": " • Jun 5, 2021"
        }
        
    
  
    
        ,"post124": {
            "title": "인터페이스 기능 구현 정의",
            "content": "1. 인터페이스 기능 구현의 정의 . 인터페이스를 실제로 구현하기 위해 인터페이스 기능에 대한 구현 방법을 기능별로 기술하는 것 | 인터페이스 기능 구현 정의 절차 | . 컴포넌트 명세서 확인 컴포넌트의 개요, 내부 클래스의 클래스명과 설명 등을 통해 컴포넌트가 가지고 있는 주요 기능 확인 | 인터페이스 클래스를 통해 인터페이스에 필요한 주요 기능 확인 | | 인터페이스 명세서 확인 컴포넌트 명세서의 인터페이스 클래스에 명시된 인터페이스의 세부 조건 및 기능을 확인 | | 일관된 인터페이스 구현 정의 인터페이스의 기능, 데이터 표준, 모듈 세부 설계서를 통해 인터페이스의 기능 구현을 정의 | 정의한 인터페이스 기능 구현에 대해 송.수신 측에서 진행해야 할 절차까지 다시 세부적으로 정의 | | 정의된 인터페이스 기능 구현 정형화 정의한 인터페이스 기능 구현을 특정 하드웨어나 소프트웨어에 의존적이지 않게 사람들이 보기 쉽고 표준화되도록 정형화 | | 2. 모듈 세부 설계서 . 모듈의 구성 요소와 세부적인 동작 등을 정의한 설계서 . | 종류 . 컴포넌트 명세서 . 컴포넌트의 개요 및 내부 클래스의 동작, 인터페이스를 통해 외부와 통신하는 명세 등을 정의한 것 | . | 인터페이스 명세서 . 컴포넌트 명세서의 항목 중 인터페이스 클래스의 세부 조건 및 기능 등을 정의한 것 | . | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/06/04/theory94.html",
            "relUrl": "/theory/2021/06/04/theory94.html",
            "date": " • Jun 4, 2021"
        }
        
    
  
    
        ,"post125": {
            "title": "모듈 간 인터페이스 데이터 표준 확인",
            "content": "1. 인터페이스 데이터 표준 . 모듈 간 인터페이스에 사용되는 데이터의 형식을 표준화하는 것 | 기존의 데이터 중에서 공통 영역을 추출하거나 어느 한쪽의 데이터를 변환하여 정의 | 확인된 인터페이스 데이터 표준은 인터페이스 기능 구현을 정의하는데 사용됨 | . 2. 인터페이스 데이터 표준 확인 . 데이터 인터페이스 확인 데이터 표준을 위해 식별된 데이터 인터페이스에서 입.출력값의 의미와 데이터의 특성 등을 구체적으로 확인 | | 인터페이스 기능 확인 데이터 표준을 위해 식별된 인터페이스 기능을 기반으로 인터페이스 기능 구현을 위해 필요한 데이터 항목 확인 | | 인터페이스 데이터 표준 확인 데이터 인터페이스에서 확인된 데이터 표준과 인터페이스 기능을 통해 확인된 데이터 항목들을 검토하여 최종적으로 데이터 표준을 확인 | |",
            "url": "https://eunkyung99.github.io/gang/theory/2021/06/03/theory93.html",
            "relUrl": "/theory/2021/06/03/theory93.html",
            "date": " • Jun 3, 2021"
        }
        
    
  
    
        ,"post126": {
            "title": "모듈 연계를 위한 인터페이스 기능 식별",
            "content": "1. 모듈 연계 . 내부 모듈과 외부 모듈 또는 내부 모듈 간 데이터의 교환을 위해 관계를 설정하는 것 . 대표적인 모듈 연계 방법 EAI(Enterprise Application Integration) | ESB(Enterprise Service Bus) | 웹 서비스(Web Service) | . | . 2. EAI(Enterprise Application Integration) . 기업 내 각종 애플리케이션 및 플랫폼 간의 정보 전달, 연계, 통합 등 상호 연동이 가능하게 해주는 솔루션임 | 구축 유형 | Point-to-Point 가장 기본적인 애플리케이션 통합 방식 | 애플리케이션을 1:1로 연결 | 변경 및 재사용이 어려움 | | . | Hub &amp; Spoke 단일 접점인 허브 시스템을 통해 데티어를 전송하는 중앙 집중형 방식 | 확장 및 유지 보수가 용이함 | 허브 장애 발생 시 시스템 전체에 영향을 미침 | | . | Message Bus(ESB 방식) 애플리케이션 사이에 미들웨어를 두어 처리하는 방식 | 확장성이 뛰어나며 대용량 처리가 가능함 | | . | Hybrid Hub &amp; Spoke와 Message Bus의 혼합 방식 | 그룹 내에서는 허브 앤 스포크 방식을, 그룹 간에는 메시지 버스 방식을 사용 | 필요한 경우 한 가지 방식으로 EAI 구현이 가능 | 데이터 병목 현상 최소화 가능 | | . | . 3. ESB(Enterprise Service Bus) . 애플리케이션 간 연계, 데이터 변환, 웹 서비스 지원 등 표준 기반의 인터페이스를 제공하는 솔루션 | 애플리케이션 통합 측면에서 EAI와 유사하지만 애플리케이션 보다는 서비스 중심의 통합을 지향함 | 특정 서비스에 국한되지 않고 범용적으로 사용하기 위하여 애플리케이션과의 결합도를 약하게 유지함 | 관리 및 보안 유지가 쉬움 | 높은 수준의 품질 지원이 가능함 | | . 4. 웹 서비스 . 네트워크의 정보를 표준화된 서비스 형태로 만들어 공유하는 기술 | 서비스 지향 아키텍처(SOA) 개념을 실현하는 대표적인 방법 | 웹 서비스의 구성 SOAP HTTP, HTTPS, SMTP 등을 활용하여 XML 기반의 메시지를 네트워크 상에서 교환하는 프로토콜 | . | UDDI WSDL을 등록하여 서비스와 서비스 제공자를 검색하고 접근하는데 사용 | . | WSDL 웹 서비스명, 서비스 제공 위치, 프로토콜 등 웹 서비스에 대한 상세 정보를 XML 형식으로 구현함 | . | . | . 5. 모듈 간 연계 기능 식별 . 모듈과 연계된 기능을 시나리오 형태로 구체화하여 식별함 | 식별된 연계 기능은 인터페이스 기능을 식별하는데 사용됨 | . 6. 모듈 간 인터페이스 기능 식별 . 식별된 모듈 간 관련 기능을 검토하여 인터페이스 동작에 필요한 기능을 식별 | 외부 및 인터페이스 모듈 간 동작하는 기능을 통해 인터페이스 기능을 식별 | 해당 업무에 대한 시나리오를 통해 내부 모듈과 관련된 인터페이스 기능을 식별 | 식별된 인터페이스 기능 중에서 실제적으로 필요한 인터페이스 기능을 최종적으로 선별 | 식별된 인터페이스 기능은 인터페이스 기능 구현을 정의하는데 사용됨 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/06/02/theory92.html",
            "relUrl": "/theory/2021/06/02/theory92.html",
            "date": " • Jun 2, 2021"
        }
        
    
  
    
        ,"post127": {
            "title": "모듈 간 공통 기능 및 데이터 인터페이스 확인",
            "content": "1. 모듈 간 공통 기능 및 데이터 인터페이스 . 공통 기능은 모듈의 기능 중에서 공통적으로 제공되는 기능을 의미 | 데이터 인터페이스는 모듈 간 교환되는 데이터가 저장될 파라미터를 의미 | 모듈 간 공통 기능 및 데이터 인터페이스 확인 절차 | . 인터페이스 설계서를 통해 모듈별 기능을 확인 | 외부 및 내부 모듈을 기반으로 공통으로 제공되는 기능과 각 데이터의 인터페이스를 확인함 | 2. 인터페이스 설계서 . 시스템 사이의 데이터 교환 및 처리를 위해 교환 데이터 및 관련 업무, 송.수신 시스템 등에 대한 내용을 정의한 문서 | 인터페이스 설계서 종류 일반적인 인터페이스 설계서 시스템의 인터페이스 목록, 각 인터페이스의 상세 데이터 명세, 각 기능의 세부 인터페이스 정보를 정의한 문서 | 종류: 시스템 인터페이스 설계서, 상세 기능별 인터페이스 명세서 | . | 정적.동적 모형을 통한 인터페이스 설계서 정적.동적 모형으로 각 시스템의 구성 요소를 표현한 다이어그램을 이용하여 만든 문서 | 시스템을 구성하는 주요 구성 요소 간의 트랜잭션을 통해 해당 인터페이스가 시스템의 어느 부분에 속하고, 해당 인터페이스를 통해 상호 교환되는 트랜잭션의 종류를 확인할 수 있음 | . | . | . 3. 인터페이스 설계서별 모듈 기능 확인 . 인터페이스 설계서에 정의한 모듈을 기반으로 각 모듈의 기능을 확인 | . 구분 외부 모듈 내부 모듈 . 시스템 인터페이스 목록 | 송신 및 전달 부분 | 수신 부분 | . 시스템 인터페이스 설계서 | 데이터 송신 시스템 부분 | 데이터 수신 시스템 부분 | . 상세 기능 인터페이스 명세서 | 오퍼레이션, 사전 조건 | 사후 조건 | . 정적.동적 모형을 통한 인터페이스 설계서 | 인터페이스 영역 | 인터페이스 영역을 제외한 나머지 부분 | . 4. 모듈 간 공통 기능 및 데이터 인터페이스 확인 . 공통 기능: 내.외부 모듈 기능을 통해 공통으로 제공되는 기능 확인 | 데이터 인터페이스: 내.외부 모듈 기능과 공통 기능을 기반으로 필요한 데이터 인터페이스 항목 확인 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/06/01/theory91.html",
            "relUrl": "/theory/2021/06/01/theory91.html",
            "date": " • Jun 1, 2021"
        }
        
    
  
    
        ,"post128": {
            "title": "미들웨어 솔루션",
            "content": "1. 미들웨어(Middleware) . 운영체제와 응용 프로그램, 또는 서버와 클라이언트 사이에서 다양한 서비스를 제공하는 소프트웨어 | 표준화된 인터페이스를 제공함으로써 시스템 간의 데이터 교환에 일관성을 보장 | 종류 DB(DataBase) | RPC(Remote Procedure Call) | MOM(Message Oriented Middleware) | TP-Monitor(Transaction Processing Monitor) | ORB(Object Request Broker) | WAS(Web Application Server) | . | . 2. DB . 데이터베이스 벤더에서 제공하는 클라이언트에서 원격의 데이터베이스와 연결하는 미들웨어 | DB를 사용하여 시스템을 구축하는 경우 보통 2-Tier 아키텍처라고 함 | . 3. RPC(원격 프로시저 호출) . 응용 프로그램의 프로시저를 사용하여 원격 프로시저를 마치 로컬 프로시저처럼 호출하는 미들웨어 | . 4. MOM(메시지 지향 미들웨어) . 메시지 기반의 비동기형 메시지를 전달하는 미들웨어 | 온라인 업무보다는 이기종 분산 데이터 시스템의 데이터 동기를 위해 많이 사용 | . 5. TP-Monitor(트랜잭션 처리 모니터) . 온라인 트랜잭션 업무에서 트랜잭션을 처리 및 감시하는 미들웨어 | 항공기나 철도 예약 업무 등 사용자 수가 증가해도 빠른 응답 속도를 유지해야 하는 업무에 주로 사용 | . 6. ORB(객체 요청 브로커) . 코바(CORBA) 표준 스펙을 구현한 객체 지향 미들웨어 | 최근에는 TP-Monitor의 장점인 트랜잭션 처리와 모니터링 등을 추가로 구현한 제품도 있음 | . 7. WAS(웹 애플리케이션 서버) . 사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리하기 위한 미들웨어 | 클라이언트/서버 환경보다는 웹 환경을 구현하기 위한 미들웨어 | HTTP 세션 처리를 위한 웹 서버 기능뿐만 아니라 미션-크리티컬한 기업 업무까지 JAVA, EJB 컴포넌트 기반으로 구현이 가능함 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/05/30/theory90.html",
            "relUrl": "/theory/2021/05/30/theory90.html",
            "date": " • May 30, 2021"
        }
        
    
  
    
        ,"post129": {
            "title": "인터페이스 방법 명세화",
            "content": "1. 인터페이스 방법 명세화 . 내.외부 시스템이 연계하여 작동할 때 인터페이스별 송.수신 방법, 송.수신 데이터, 오류 식별 및 처리 방안에 대한 내용을 문서로 정리하는 것 | 송.수신 방법 명세화: 내.외부 인터페이스 목록에 있는 각각의 인터페이스에 대해 연계 방식, 통신 및 처리 유형, 발생 주기 등의 송.수신 방법을 정의하고 명세를 작성하는 것 | 송.수신 데이터 명세화: 내.외부 인터페이스 목록에 있는 각각의 인터페이스에 대해 인터페이스 시 필요한 송.수신 데이터에 대한 명세를 작성하는 것 | 오류 식별 및 처리 방안 명세화: 내.외부 인터페이스 목록에 있는 각각의 인터페이스에 대해 인터페이스 시 발생할 수 있는 오류를 식별하고 오류 처리 방안에 대한 명세를 작성하는 것 | 인터페이스별로 송.수신 방법을 명세화하기 위해 필요한 정보 시스템 연계 기술 | 인터페이스 통신 유형 | 처리 유형 | 발생 주기 | . | . 2. 시스템 연계 기술 . DB Link: DB에서 제공하는 DB Link 객체를 이용하는 방식 | API/Open API: 송신 시스템의 데이터베이스에서 데이터를 읽어 와 제공하는 애플리케이션 프로그래밍 인터페이스 프로그램 | 연계 솔루션: EAI 서버와 송.수신 시스템에 설치되는 클라이언트를 이용하는 방식 | Socket: 서버가 통신을 위한 소켓을 생성하여 포트를 할당하고 클라이언트의 통신 요청 시 클라이언트와 연결하여 통신하는 네트워크 기술 | Web Service: 웹 서비스에서 WSDL, UDDI, SOAP 프로토콜을 이용하여 연계하는 서비스 | . 3. 인터페이스 통신 유형 . 단방향: 시스템에서 거래를 요청만 하고 응답이 없는 방식 | 동기: 시스템에서 거래를 요청하고 응답이 올 때까지 대기(Request-Reply)하는 방식 | 비동기: 시스템에서 거래를 요청하고 다른 작업을 수행하다 응답이 오면 처리하는 방식(Send-Recieve, Send-Receive-Acknowledge, Publish-Subscribe) | . 4. 인터페이스 처리 유형 . 실시간 방식: 사용자가 요청한 내용을 바로 처리해야 할 때 사용 | 지연 처리 방식: 데이터를 매건 단위로 처리할 경우 비용이 많이 발생할 때 사용 | 배치 방식: 대량의 데이터를 처리할 때 사용 | . 5. 인터페이스 발생 주기 . 개발할 시스템과 내.외부 시스템 간 송.수신 데이터가 전송되어 인터페이스가 사용되는 주기를 의미 | 업무의 성격과 송.수신 데이터 전송량을 고려하여 메일, 수시, 주 1회 등으로 구분 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/05/29/theory89.html",
            "relUrl": "/theory/2021/05/29/theory89.html",
            "date": " • May 29, 2021"
        }
        
    
  
    
        ,"post130": {
            "title": "송.수신 데이터 식별",
            "content": "1. 식별 대상 데이터 . 송.수신 시스템 사이에서 교환되는 데이터. 규격화된 표준 형식에 따라 전송됨 | 교환되는 데이터의 종류 인터페이스 표준 항목 | 송.수신 데이터 항목 | 공통 코드 | . | . 2. 인터페이스 표준 항목 . 송.수신 시스템을 연계하는데 표준적으로 필요한 데이터 | 시스템 공통부 시스템 간 연동 시 필요한 공통 정보 | 구성 정보: 인터페이스 ID, 전송 시스템 정보, 서비스 코드 정보, 응답 결과 정보, 장애 정보 등 | . | 거래 공통부 시스템들이 연동된 후 송.수신되는 데이터를 처리할 때 필요한 정보 | 구성 정보: 직원 정보, 승인자 정보, 기기 정보, 매체 정보 등 | . | . 3. 송.수신 데이터 항목 . 송.수신 시스템이 업무를 수행하는 데 사용하는 데이터 | 전송되는 데이터 항목과 순서는 인터페이스별로 다름 | . 4. 공통 코드 . 시스템들에서 공통으로 사용하는 코드 | 연계 시스템이나 연계 소프트웨어에서 사용하는 상태 및 오류 코드 등의 항목에 대해 코드값과 코드명, 코드 설명 등을 공통 코드로 관리함 | . 5. 정보 흐름 식별 . 개발할 시스템과 내.외부 시스템 사이에서 전송되는 정보들의 방향성을 식별함 | 개발할 시스템과 내.외부 시스템에 대한 각각의 인터페이스 목록을 확인하여 정보 흐름을 식별함 | 식별한 정보 흐름을 기반으로 송.수신 시스템 사이에서 교환되는 주요 데이터 항목이나 정보 그룹을 도출 | . 6. 송.수신 데이터 식별 . 개발할 시스템과 연계할 내.외부 시스템 사이의 정보 흐름과 데이터베이스 산출물을 기반으로 식별함 . | 송.수신 데이터의 종류에 따라 다음과 같이 식별함 . 인터페이스 표준 항목과 송.수신 데이터 항목 식별: 송.수신 시스템 사이의 교환 범위를 확인하고 인터페이스 표준 항목에 대해 송.수신 데이터 항목을 식별함 | 코드성 데이터 항목 식별: 코드성 데이터 항목에 대해 코드, 코드명, 코드 설명 등의 코드 정보를 식별함 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/05/28/theory88.html",
            "relUrl": "/theory/2021/05/28/theory88.html",
            "date": " • May 28, 2021"
        }
        
    
  
    
        ,"post131": {
            "title": "인터페이스 시스템 식별",
            "content": "1. 인터페이스 시스템 식별 . 인터페이스별로 인터페이스에 참여하는 시스템들을 송신 시스템과 수신 시스템으로 구분하여 작성하는 것 . 2. 인터페이스 시스템 식별을 위한 선행 작업 . 개발 시스템과 내.외부 시스템 식별: 개발할 시스템과 이와 연결할 내.외부 시스템의 상세 식별 정보를 정의하고 목록을 작성함 | 내.외부 시스템 환경 및 관리 주체 식별 실제 운용 환경과 하드웨어 관리 주체를 확인 | 내.외부 시스템 환경: 연계할 시스템 접속에 필요한 IP 또는 URL, Port 정보 등 시스템의 실제 운용 환경 | 내.외부 시스템 관리 주체: 하드웨어 관리 담당자 | . | 내.외부 시스템 네트워크 연결 정보 식별: 내.외부 시스템을 연계하는데 필요한 시스템 로그인 및 DB 정보 등의 네트워크 연결 정보를 확인함 | 인터페이스 식별: 개발할 시스템과 연계할 내.외부 시스템 사이의 인터페이스를 식별하고 인터페이스 목록을 작성함 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/05/27/theory87.html",
            "relUrl": "/theory/2021/05/27/theory87.html",
            "date": " • May 27, 2021"
        }
        
    
  
    
        ,"post132": {
            "title": "시스템 인터페이스 요구사항 분석",
            "content": "1. 인터페이스 요구사항 검증 . 사용자들의 요구사항이 요구사항 명세서에 정확하고 완전하게 기술되었는지 검토하고 개발 범위의 기준인 베이스라인을 설정하는 것 | 수행 순서 | . 요구사항 검토 계획 수립 검토 기준 및 방법, 참여자, 체크리스트, 관련 자료, 일정 등의 검토 계획 수립 | | 검토 및 오류 수정 인터페이스 요구사항 명세서 검토 및 오류 목록과 시정 조치서 작성 | | 베이스라인 설정 검증된 인터페이스 요구사항을 승인받은 후 요구사항 명세서의 베이스라인 설정 | | 2. 요구사항 검증 방법 . 요구사항 검토: 요구사항 명세서의 오류 확인 및 표준 준수 여부 등의 결함 여부를 검토 담당자들이 수작업으로 분석하는 방법 | 동료 검토 요구사항 명세서 작성자가 명세서 내용을 직접 설명하고 동료들이 이를 들으면서 결함을 발견하는 형태의 검토 방법 | . | 워크스루 검토 회의 전에 요구사항 명세서를 미리 배포하여 사전 검토한 후에 짧은 검토 회의를 통해 결함을 발견하는 형태의 검토 방법 | . | 인스펙션 요구사항 명세서 작성자를 제외한 다른 검토 전문가들이 요구사항 명세서를 확인하면서 결함을 발견하는 형태의 검토 방법 | . | 프로토타이핑: 사용자의 요구사항을 정확히 파악하기 위해 실제 개발될 소프트웨어에 대한 견본품을 만들어 최종 결과물을 예측 . | 테스트 설계: 요구사항은 테스트할 수 있도록 작성되어야 하며, 이를 위해 테스트 케이스를 생성하여 요구사항이 현실적으로 테스트 가능한지를 검토 | CASE 도구 활용: 일관성 분석을 통해 요구사항 변경사항의 추적, 분석, 관리, 표준 준수 여부를 확인함 | . 3. 인터페이스 요구사항 검증의 주요 항목 . 완전성: 사용자의 모든 요구사항이 누락되지 않고 완전하게 반영되어 있는가? | 일관성: 요구사항이 모순되거나 충돌되는 점 없이 일관성을 유지하고 있는가? | 명확성: 모든 참여자가 요구사항을 명확히 이해할 수 있는가? | 기능성: 요구사항이 ‘어떻게’ 보다 ‘무엇을’에 중점을 두고 있는가? | 검증 가능성: 요구사항이 사용자의 요구를 모두 만족하고, 개발된 소프트웨어가 사용자의 요구 내용과 일치하는지를 검증할 수 있는가? | 추적 가능성: 요구사항 명세서와 설계서를 추적할 수 있는가? | 변경 용이성: 요구사항 명세서의 변경이 쉽도록 작성되었는가? | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/05/26/theory86.html",
            "relUrl": "/theory/2021/05/26/theory86.html",
            "date": " • May 26, 2021"
        }
        
    
  
    
        ,"post133": {
            "title": "시스템 인터페이스 요구사항 분석",
            "content": "1. 시스템 인터페이스 요구사항 . 개발할 시스템과 외부 시스템을 연동하는데 필요한 시스템 인터페이스에 대한 요구사항을 기술한 것 | 시스템 인터페이스 요구사항 명세서의 구성 요소 인터페이스 이름 | 연계 대상 시스템 | 연계 범위 및 내용 | 연계 방식 | 송신 데이터 | 인터페이스 주기 | 기타 고려사항 | . | . 2. 시스템 인터페이스 요구사항 분석 . 요구사항을 분류하고 구체적으로 명세한 후 이를 이해관계자에게 전달하는 일련의 과정임 | 소프트웨어 요구사항 분석 기법을 적절히 이용함 | 요구사항의 분해가 필요한 경우 적절한 수준으로 세분화함 | 요구사항 분석 시 누락된 요구사항이나 제한 조건을 추가함 | 요구사항에 대한 상대적 중요도를 평가하여 우선순위을 부여함 | . 3. 시스템 인터페이스 요구사항 분석 절차 . 시스템 인터페이스 관련 요구사항을 선별하여 별도로 요구사항 목록을 만든다. | 요구사항과 관련된 자료를 준비한다. | 기능적인 요구사항과 비기능적인 요구사항으로 분류한다. | 요구사항을 분석하고 요구사항 명세서에 내용을 추가하거나 수정한다. | 추가-수정한 요구사항 명세서와 요구사항 목록을 관련 이해관계자에게 전달한다. |",
            "url": "https://eunkyung99.github.io/gang/theory/2021/05/25/theory85.html",
            "relUrl": "/theory/2021/05/25/theory85.html",
            "date": " • May 25, 2021"
        }
        
    
  
    
        ,"post134": {
            "title": "패키지 소프트웨어",
            "content": "1. 패키지 소프트웨어 . 기업에서 일반적으로 사용하는 여러 기능을 통합하여 제공하는 소프트웨어 | 기업에서는 패키지 소프트웨어를 구입하여 기업 환경에 적합하게 커스터마이징하여 사용 | 패키지 소프트웨어를 이용하여 시스템을 구축하는 방식을 패키지 개발 방식이라고 함 | 기능 요구사항을 70% 이상 충족시키는 패키지 소프트웨어가 있을 때만 사용하는 것이 적합함 | 업무 특성에 맞게 전용으로 개발되는 소프트웨어와 비교하여 안정성, 라이선스, 생산성 등에서 차이가 있음 | . 2. 패키지 소프트웨어와 전용 개발 소프트웨어의 비교 .   패키지 소프트웨어 전용 개발 소프트웨어 . 기능 요구사항 | 70% 이상 충족시키는 패키지 소프트웨어가 있는 경우 이용 | 모든 기능 요구사항 반영 가능 | . 안정성 | 품질이 검증되었고 업계 표준 준용 | 개발자의 역량에 따라 달라짐 | . 라이선스 | 판매자 | 회사 | . 생산성 | 개발을 위한 인력과 시간이 절약됨 | 개발을 위한 인력과 시간 필요 | . 호환성 | 보장이 안 됨 | 설계 단계부터 고려하여 개발 | . 유지보수 | 결함 발생 시 즉시 대응이 어려움 | 결함 발생 시 즉시 대응 가능 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/05/24/theory84.html",
            "relUrl": "/theory/2021/05/24/theory84.html",
            "date": " • May 24, 2021"
        }
        
    
  
    
        ,"post135": {
            "title": "배치 프로그램",
            "content": "1. 배치 프로그램 . 사용자와의 상호 작용 없이 여러 작업들을 미리 정해진 일련의 순서에 따라 일괄적으로 처리하도록 만든 프로그램 | 필수 요소 대용량 데이터 대량의 데이터를 가져오거나, 전달하거나, 계산하는 등의 처리가 가능해야 함 | . | 자동화 심각한 오류가 발생하는 상황을 제외하고는 사용자의 개입 없이 수행되어야 함 | . | 견고성 잘못된 데이터나 데이터 중복 등의 상황으로 중단되는 일 없이 수행되어야 함 | . | 안정성/신뢰성 오류가 발생하면 오류의 발생 위치, 시간 등을 추적할 수 있어야 함 | . | 성능 다른 응용 프로그램의 수행을 방해하지 않아야 함 | 지정된 시간 내에 처리가 완료되어야 함 | . | . | . 2. 배치 스케줄러 . 일괄 처리 작업이 설정된 주기에 맞춰 자동으로 수행되도록 지원해주는 도구 | 특정 업무(job)를 원하는 시간에 처리할 수 있도록 지원한다는 특성 때문에 잡 스케줄러(Job Scheduler)라고도 불림 | 종류 스프링 배치 Spring Source 사와 Accenture 사가 2007년 공동 개발한 오픈 소스 프레임워크 | 로그 관리, 추적, 트랜잭션 관리, 작업 처리 통계, 작업 재시작 등의 다양한 기능 제공 | . | Quartz 스프링 프레임워크로 개발되는 응용 프로그램들의 일괄 처리를 위한 다양한 기능을 제공하는 오픈 소스 라이브러리 | 수행할 작업과 수행 시간을 관리하는 요소들을 분리하여 일괄 처리 작업에 유연성을 제공 | . | Cron 리눅스의 기본 스케줄러 도구 | crontab 명령어를 통해 작업 예약 | . | . | . 3. crontab 명령어 작성 방법 . 작업 예약 형식 | | 분, 시, 일, 월, 요일에 ‘*‘를 입력하면 매 시기마다 수행함 ** * * * /root/com_1.sh -&gt; 매월 매일 매시 매분마다 com_1.sh 실행 | 30 1 * * * /root/com_2.sh -&gt; 매월 매일 1시 30분에 com_2.sh 실행 | . | 시기 우측에 ‘/[단위]’를 입력하면 시기를 단위로 나눈 나머지가 0일 때마다 명령어를 수행 30 */3 * * * /root/com_1.sh -&gt; 매월 매일 0:30부터 3시간 마다 com_1.sh를 실행함(0:30, 3:30, 6:30, …, 21:30) | . | ‘[시작 시기]-[종료 시기]’를 통해 특정 구간에만 반복하여 명령어 실행 가능 *18-23 20 * * /root/com_1.sh -&gt; 매월 20일 18시~23시 사이에 매분마다 com_1.sh를 실행 | . | 시기는 ‘[시기1], [시기2], [시기3] …‘를 통해 특정 시기에 명령어를 실행할 수 있음 30 23 25 4,9,11 * /root/com_1.sh -&gt; 4/9/11월의 25일 23시 30분에 com_1.sh를 실행 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/05/23/theory83.html",
            "relUrl": "/theory/2021/05/23/theory83.html",
            "date": " • May 23, 2021"
        }
        
    
  
    
        ,"post136": {
            "title": "보안 및 API",
            "content": "1. 소프트웨어 개발 보안 . 소프트웨어 개발 과정에서 발생할 수 있는 보안 취약점을 최소화하여 보안 위협으로부터 안전한 소프트웨어를 개발하기 위한 일련의 보안 활동 | 데이터의 기밀성, 무결성, 가용성 등의 보안 요소를 충족시키는 것을 목표로 함 | 정부에서 제공하는 소프트웨어 개발 보안 가이드를 참고하여 소프트웨어 개발 과정에서 점검해야 할 보안 항목들을 점검함 | . 2. 소프트웨어 개발 보안 점검 항목 . 세션 통제: 세션의 연결과 연결로 인해 발생하는 정보 관리 | 입력 데이터 검증 및 표현: 입력 데이터에 대한 유효성 검증체계를 갖추고, 검증 실패 시 이를 처리할 수 있도록 코딩 | 보안 기능: 인증, 접근제어, 기밀성, 암호화 등의 기능 | 시간 및 상태: 동시 수행을 지원하는 병렬 처리 시스템이나 다수의 프로세스가 동작하는 환경에서 시간과 실행 상태를 관리하여 시스템이 원활히 동작하도록 코딩 | 에러처리: 소프트웨어 실행 중 발생할 수 있는 오류들을 사전에 정의하여 에러로 인해 발생할 수 있는 문제들을 예방 | 코드 오류: 개발자들이 코딩 중 실수하기 쉬운 형 변환, 자원의 반환 등을 고려하며 코딩 | 캡슐화: 속성과 데이터를 처리하는 함수를 하나의 객체로 묶어 코딩 | API 오용: API를 잘못 사용하거나 보안에 취약한 API를 사용하지 않도록 고려하여 코딩 | . 3. API(Application Programming Interface) . API는 응용 프로그램 개발 시 운영체제나 프로그래밍 언어 등에 있는 라이브러리를 이용할 수 있도록 규칙 등을 정의해 놓은 인터페이스를 의미 | 라이브러리에 있는 다양한 기능들을 손쉽게 이용할 수 있도록 도와주므로 효율적인 개발이 가능함 | 누구나 무료로 사용할 수 있게 공개된 API를 Open API라고 함 | 종류 Windows API | 단일 유닉스 규격(SUS) | Java API | 웹 API | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/05/22/theory82.html",
            "relUrl": "/theory/2021/05/22/theory82.html",
            "date": " • May 22, 2021"
        }
        
    
  
    
        ,"post137": {
            "title": "서버 개발",
            "content": "1. 서버 개발 . 웹 애플리케이션의 로직을 구현할 서버 프로그램을 제작하여 웹 애플리케이션 서버(WAS)에 탑재하는 것을 의미 | 서버 개발에 사용되는 프로그래밍 언어에는 Java, JavaScript, Python, PHP, Ruby 등이 있음 | 각 프로그래밍 언어에는 해당 언어로 서버 프로그램을 개발할 수 있도록 지원하는 프레임워크가 있음 | . 2. 서버 개발 프레임워크 . 서버 프로그램 개발 시 다양한 네트워크 설정, 요청 및 응답 처리, 아키텍처 모델 구현 등을 손쉽게 처리할 수 있도록 클래스나 인터페이스를 제공하는 소프트웨어를 의미 | 서버 개발 프레임워크의 대부분은 모델-뷰-컨트롤러(MVC) 패턴을 기반으로 개발되었음 . | 종류 Spring JAVA를 기반으로 만든 프레임워크 | 전자정부 표준 프레임워크의 기반 기술로 사용되고 있음 | . | Node.js JavaScript를 기반으로 만든 프레임워크 | 비동기 입.출력 처리와 이벤트 위주의 높은 처리 성능을 갖고 있어 실시간으로 입.출력이 빈번한 애플리케이션에 적합 | . | Django Python을 기반으로 만든 프레임워크 | 컴포넌트의 재사용과 플러그인화를 강조하여 신속한 개발이 가능하도록 지원함 | . | Codeigniter PHP를 기반으로 만든 프레임워크 | 인터페이스가 간편하며 서버 자원을 적게 사용 | . | Ruby on Rails Ruby를 기반으로 만든 프레임워크 | 테스트를 위한 웹 서버를 지원하며 데이터베이스 작업을 단순화, 자동화시켜 개발 코드의 길이가 짧아지게 함으로써 신속한 개발이 가능함 | . | . | . 3. 서버 개발 과정 . DTO/VO, SQL, DAO, Service, Controller를 각각 구현하는 과정임 | 구현 순서는 개발자가 임의로 변경 가능 | 개발하려는 서버 프로그램의 목적, 개발 언어, 규모 등의 이유로 통합하거나 세분화할 수 있음 | 구현 과정 | DTO/VO 구현 데이터 교환을 위해 사용할 객체를 만드는 과정 | 송.수신할 데이터의 자료형에 맞는 변수 및 객체를 생성함 | . | SQL 구현 데이터의 삽입, 변경, 삭제 등의 작업을 수행할 SQL 문을 생성하는 과정 | SQL 문은 소스 코드 내에 직접 입력, 또는 별도의 XML 파일로 관리함 | . | DAO(데이터베이스에 접근하여 데이터 CRUD 작업 수행하는 객체)구현 데이터베이스에 접근하고, SQL을 활용하여 데이터를 실제로 조작하는 코드를 구현하는 과정 | . | Service 구현 사용자의 요청에 응답하기 위한 로직을 구현하는 과정 | . | Controller 구현 사용자의 요청에 적절한 서비스를 호출하여 그 결과를 사용자에게 반환하는 코드를 구현하는 과정 | . | 서버 개발 과정 도식화 | | . 웹 사이트로부터 사용자의 요청이 컨트롤러에 전달 | 컨트롤러는 해당 요청에 맞는 서비스 호출 | 서비스는 수행을 위한 데이터를 DAO에 요청 | ~ 6. DAO는 XML을 통해 Database로부터 서비스가 요청한 데이터를 가져옴 . | 가져온 데이터를 서비스에 반환 | 서비스의 수행 결과를 컨트롤러에 반환 | 컨트롤러의 수행 결과를 웹 사이트에 반환함 | DTO/VO는 1, 5, 9를 제외한 데이터 교환 전 과정에서 요청과 응답 시 사용 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/05/21/theory81.html",
            "relUrl": "/theory/2021/05/21/theory81.html",
            "date": " • May 21, 2021"
        }
        
    
  
    
        ,"post138": {
            "title": "개발 지원 도구",
            "content": "1. 통합 개발 환경(IDE) . 개발에 필요한 환경, 즉 편집기, 컴파일러, 디버거 등의 다양한 툴을 하나의 인터페이스로 통합하여 제공하는 환경 | 통합 개발 환경 도구는 통합 개발 환경을 제공하는 소프트웨어를 의미 | 코드를 실행하거나 테스트할 때 오류가 발생한 부분을 시각화하므로 수정이 용이 | . 2. 통합 개발 환경 도구의 종류 . 프로그램 개발사 플랫폼 운영체제 지원 언어 . 이클립스 | Eclipse Foundation, IBM | 크로스 플랫폼 | Windows, Linux, MacOS 등 | Java, C, C++, PHP, JSP 등 | . 비주얼 스튜디오 | Microsoft | Win32, Win64 | Windows | Basic, C, C++, C#, .NET 등 | . 엑스 코드 | Apple | Mac, iPhone | MacOS, iOS | C, C++, C#, Java, AppleScript 등 | . 안드로이드 스튜디오 | Google | Android | Windows, Linux, MacOS | Java, C, C++ | . IDEA | JetBrains | 크로스 플랫폼 | Windows, Linux, MacOS | Java, JSP, XML, Go, Kotlin, PHP 등 | . 3. 빌드 도구 . 빌드는 소스 코드 파일들을 컴퓨터에서 실행할 수 있는 제품 소프트웨어로 변환하는 과정 또는 결과물을 말함 | 빌드 도구는 전처리, 컴파일 등의 작업을 수행함 | 대표적인 빌드 도구 Ant(Another Neat Tool) 아파치 소프트웨어 재단에서 개발 | 자바 프로젝트의 공식적인 빌드 도구 | 정해진 규칙이나 표준이 없음 | . | Maven 아파치 소프트웨어 재단에서 Ant의 대안으로 개발 | 의존성을 설정하여 라이브러리를 관리함 | 규칙이나 표준이 존재하여 예외 사항만 기록 | . | Graddle 한스 도커가 Ant와 Maven을 보완하여 개발 | 안드로이드 스튜디오의 공식 빌드 도구 | 그루비 기반의 빌드 스크립트를 사용함 | . | . | . 4. 기타 협업 도구 . 협업 도구는 개발에 참여하는 사람들이 서로 다른 작업 환경에서 원활히 프로젝트를 수행할 수 있도록 도와주는 도구 | 협업 소프트웨어, 그룹웨어 등으로도 불림 | 일정 관리, 업무 흐름 관리, 정보 공유, 커뮤니케이션 등의 업무 보조 도구가 포함됨 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/05/20/theory80.html",
            "relUrl": "/theory/2021/05/20/theory80.html",
            "date": " • May 20, 2021"
        }
        
    
  
    
        ,"post139": {
            "title": "디자인 패턴",
            "content": "1. 디자인 패턴 . 모듈 간의 관계 및 인터페이스를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제 | 문제 및 배경, 실제 적용된 사례, 재사용이 가능한 샘플 코드 등으로 구성 | ‘바퀴를 다시 발명하지 마라’라는 말과 같이 개발 과정 중에 문제가 발생하면 새로 해결책을 구상하는 것보다 문제에 해당하는 디자인 패턴을 참고하여 적용하는 것이 더 효율적임 | GOF의 디자인 패턴은 생성 패턴, 구조 패턴, 행위 패턴으로 구분됨 | . 2. 생성 패턴 . 클래스나 객체의 생성과 참조 과정을 정의하는 패턴 | 추상 팩토리 구체적인 클래스에 의존하지 않고, 인터페이스를 통해 서로 연관.의존하는 객체들의 그룹으로 생성하여 추상적으로 표현 | 연관된 서브 클래스를 묶어 한 번에 교체하는 것이 가능함 | . | 빌더 작게 분리된 인스턴스를 건축하듯이 조합하여 객체를 생성 | 객체의 생성 과정과 표현 방법을 분리하고 있어, 동일한 객체 생성에서도 서로 다른 결과를 만들어 낼 수 있음 | . | 팩토리 메소드 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴 | 상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당함 | 가상 생성자 패턴이라고도 함 | . | 프로토타입 원본 객체를 복제하는 방법으로 객체를 생성하는 패턴 | 일반적인 방법으로 객체를 생성하며, 비용이 큰 경우 주로 이용함 | . | 싱글톤 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수는 없음 | 클래스 내에서 인스턴스가 하나뿐임을 보장하며, 불필요한 메모리 낭비를 최소화할 수 있음 | . | 추상 팩토리는 서로 다른 부품을 조립만 하는 조립 공장, 빌더는 건축가각 블록을 조립하는 모습, 팩토리 메소드는 부품부터 완성까지 통째로 찍어내는 공장, 프로토타입은 원형을 두고 복제품을 만드는 것, 싱글톤은 식당에서 누구나 사용할 수 있지만 하나뿐인 정수기이다. | . 3. 구조 패턴 . 구조가 복잡한 시스템을 개발하기 쉽도록 클래스나 객체들을 조합하여 더 큰 구조로 만드는 패턴 | 어댑터 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴 | 기존의 클래스를 이용하고 싶지만 인터페이스가 일치하지 않을 때 이용함 | . | 브리지 구현부에서 추상층을 분리하여 서로가 독립적으로 확장할 수 있도록 구성한 패턴 | 기능과 구현을 두 개의 별도 클래스로 구현 | . | 컴포지트 여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용하는 패턴 | 객체들을 트리 구조로 구성하여 디렉터리 안에 디렉터리가 있듯이 복합 객체 안에 복합 객체가 포함되는 구조 구현 가능 | . | 데코레이터 객체 간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴 | 임의의 객체에 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식으로 구현 | . | 퍼싸드 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴 | 서브 클래스들 사이의 통합 인터페이스를 제공하는 Wrapper 객체가 필요 | . | 플라이웨이트 인스턴스가 필요할 때마다 매번 생성하는 것이 아니고 가능한 한 공유해서 사용함으로써 메모리를 절약하는 패턴 | 다수의 유사 객체를 생성하거나 조작할 때 유용하게 사용할 수 있음 | . | 프록시 접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴 | 네트워크 연결, 메모리의 대용량 객체로의 접근 등에 주로 이용 | . | 어댑터는 전압을 맞춰주는 변압기, 브리지는 두 섬을 연결하는 다리, 컴포지트는 폴더와 파일을 합성한 것, 데코레이터는 온갖 것으로 장식된 눈사람, 퍼싸드는 외부의 리모컨 버튼만으로 복잡한 명령들을 간편하게 수행하는 것, 플라이웨이트는 부담을 가볍게 하기 위해 물품을 공유하는 것, 프록시는 내가 하기 어려운 법률업무를 대리해서 처리해주는 변호사이다. | . 4. 행위 패턴 . 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴 | 책임 연쇄 요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴 | 요청을 처리할 수 있는 각 객체들이 고리로 묶여 있어 요청이 해결될 때까지 고리를 따라 책임이 넘어감 | . | 커맨드 요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴 | 요청에 사용되는 각종 명령어들을 추상 클래스와 구체 클래스로 분리하여 단순화함 | . | 인터프리터 언어에 문법 표현을 정의하는 패턴 | SQL이나 통신 프로토콜과 같은 것을 개발할 때 사용 | . | 반복자 자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴 | 내부 표현 방법의 노출 없이 순차적인 접근이 가능 | . | 중재자 수많은 객체들 간의 복잡한 상호작용을 캡슐화하여 객체로 정의하는 패턴 | 객체 사이의 의존성을 줄여 결합도를 감소시킬 수 있음 | . | 메멘토 특정 시점에서의 객체 내부 상태를 객체화함으로써 이후 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 제공하는 패턴 | Ctrl+Z와 같은 되돌리기 기능을 개발할 때 주로 이용 | . | 옵서버 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴 | 일대다의 의존성을 정의함 | 주로 분산된 시스템 간에 이벤트를 생성.발행하고, 이를 수신해야 할 때 이용 | . | 상태 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴 | 객체 상태를 캡슐화하고 이를 참조하는 방식으로 처리 | . | 전략 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴 | 클라이언트는 독립적으로 원하는 알고리즘을 선택하여 사용할 수 있으며, 클라이언트에 영향 없이 알고리즘의 변경이 가능함 | . | 템플릿 메소드 상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화하는 구조의 패턴 | 유사한 서브 클래스를 묶어 공통된 내용을 상위 클래스에서 정의함으로써 코드의 양을 줄이고 유지보수를 용이하게 해줌 | . | 방문자 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴 | 분리된 처리 기능은 각 클래스를 방문하여 수행함 | . | 책임 연쇄는 위에서 쏟아지는 물을 여러 물받이가 연속해서 나눠 받는 물레방아, 커맨드는 각종 명령어를 하나로 합쳐둔 것, 인터프리터는 언어 번역기, 반복자는 음악 파일의 다음 곡 재생처럼 같은 명령어 반복, 중재자는 물품 예매를 중개해주는 인터넷 사이트, 메멘토는 기억 속의 그 때로 돌아가는 것, 옵서버는 변화를 지켜보고 알려주는 것, 상태는 환자의 상태에 따라 치료방법이 다른 것, 전략은 여러 전략들을 정하고 필요할 때 원하는 전략을 선택하여 쓰는 것, 템플릿 메소드는 세모, 네모, 동그라미를 그리는 방법들을 도형이라는 하나의 큰 틀로 묶는 것, 방문자는 책을 만들기 위해 저자, 편집자, 홍보팀을 번갈아가며 방문하는 것이다. | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/05/19/theory79.html",
            "relUrl": "/theory/2021/05/19/theory79.html",
            "date": " • May 19, 2021"
        }
        
    
  
    
        ,"post140": {
            "title": "코드",
            "content": "1. 코드 . 자료의 분류.조합.집계.추출을 용이하게 하기 위해 사용하는 기호 | 정보를 신속.정확.명료하게 전달할 수 있게 함 | 일정한 규칙에 따라 작성됨 | 정보 처리의 효율과 처리된 정보의 가치에 많은 영향을 미침 | . 2. 코드의 주요 기능 . 식별 기능: 데이터 간의 성격에 따라 구분 가능 | 분류 기능: 특정 기준이나 동일한 유형에 해당하는 데이터를 그룹화할 수 있음 | 배열 기능: 의미를 부여하여 나열할 수 있음 | 표준화 기능: 다양한 데이터를 기준에 맞추어 표현할 수 있음 | 간소화 기능: 복잡한 데이터를 간소화할 수 있음 | . 3. 코드의 종류 . 순차 코드: 자료의 발생 순서, 크기 순서 등 일정 기준에 따라서 최초의 자료부터 차례로 일련번호를 부여하는 방법. 순서 코드/일련번호 코드라고도 함 1, 2, 3, 4 | . | 블록 코드: 코드화 대상 항목 중에서 공통성이 있는 것끼리 블록으로 구분하고, 각 블록 내에서 일련번호를 부여하는 방법. 구분 코드라고도 함 1001~1100: 총무부, 1101~1200: 영업부 | . | 10진 코드: 코드화 대상 항목을 0~9까지 10진 분할하고, 다시 그 각각에 대하여 10진 분할하는 방법을 필요한 만큼 반복하는 방법. 도서 분류식 코드라고도 함 1000: 공학, 1100: 소프트웨어 공학, 1110: 소프트웨어 설계 | . | 그룹 분류 코드: 코드화 대상 항목을 일정 기준에 따라 대분류, 중분류, 소분류 등으로 구분하고, 각 그룹 안에서 일련번호를 부여하는 방법 1-01-001: 본사-총무부-인사계, 2-01-001: 지사-총무부-인사계 | . | 연상 코드: 코드화 대상 항목의 명칭이나 약호와 관계있는 숫자나 문자, 기호를 이용하여 코드를 부여하는 방법 TV-40: 40인치 TV, L-15-220: 15W 220V의 램프 | . | 표의 숫자 코드: 코드화 대상 항목의 성질, 즉 길이, 넓이, 부피, 지름, 높이 등을 물리적 수치를 그대로 코드에 적용시키는 방법으로, 유효 숫자 코드라고도 함 120-720-1500: 두께x폭x길이가 120x720x1500인 강판 | . | 합성 코드: 필요한 기능을 하나의 코드로 수행하기 어려운 경우 2개 이상의 코드를 조합하여 만드는 방법 연상 코드+순차 코드 | KE-711: 대한항공 711기, AC-254: 에어캐나다 254기 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/05/18/theory78.html",
            "relUrl": "/theory/2021/05/18/theory78.html",
            "date": " • May 18, 2021"
        }
        
    
  
    
        ,"post141": {
            "title": "공통 모듈",
            "content": "1. 공통 모듈 . 여러 프로그램에서 공통으로 사용할 수 있는 모듈 | 자주 사용되는 계산식이나 매번 필요한 사용자 인증과 같은 기능들이 공통 모듈로 구성될 수 있음 | 해당 기능을 명확히 이해할 수 있도록 명세 기법을 준수해야 함 | . 2. 공통 모듈 명세 기법의 종류 . 정확성 시스템 구현 시 해당 기능이 필요하다는 것을 알 수 있도록 정확히 작성 | . | 명확성 해당 기능을 이해할 때 중의적으로 해석되지 않도록 명확하게 작성 | . | 완전성 시스템 구현을 위해 필요한 모든 것을 기술 | . | 일관성 공통 기능들 간 상호 충돌이 발생하지 않도록 작성 | . | 추적성 기능에 대한 요구사항의 출처, 관련 시스템 등의 관계를 파악할 수 있도록 작성 | . | . 3. 재사용 . 이미 개발된 기능들을 새로운 시스템이나 기능 개발에 사용하기 적합하도록 최적화하는 작업 | 새로 개발하는데 필요한 비용과 시간 절약 | 누구나 이해할 수 있고 사용이 가능하도록 사용법을 공개해야 함 . | 재사용 규모에 따른 분류 함수와 객체 클래스나 메소드 단위의 소스 코드 재사용 | . | 컴포넌트 컴포넌트 자체에 대한 수정 없이 인터페이스를 통해 통신하는 방식으로 재사용 | . | 애플리케이션 공통된 기능들을 제공하는 애플리케이션을 공유하는 방식으로 재사용 | . | . | . 4. 효과적인 모듈 설계 방안 . 결합도는 줄이고 응집도는 높여서 모듈의 독립성과 재사용성을 높임 | 복잡도와 중복성을 줄이고 일관성 유지 | 모듈의 기능은 예측이 가능해야 하며 지나치게 제한적이어서는 안 됨 | 모듈 크기는 시스템의 전반적인 기능과 구조를 이해하기 쉬운 크기로 분해 | 효과적인 제어를 위해 모듈 간의 계층적 관계를 정의하는 자료가 제시되어야 함 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/05/17/theory77.html",
            "relUrl": "/theory/2021/05/17/theory77.html",
            "date": " • May 17, 2021"
        }
        
    
  
    
        ,"post142": {
            "title": "단위 모듈",
            "content": "1. 단위 모듈 . 소프트웨어 구현에 필요한 여러 동작 중 한 가지 동작을 수행하는 기능을 모듈로 구현한 것 | 단위 모듈로 구현되는 하나의 기능을 단위 기능이라고 부름 | 독립적인 컴파일이 가능하며, 다른 모듈에 호출되거나 삽입되기도 함 | 구현 과정 | . 단위 기능 명세서 작성: 기능 및 코드 명세서나 설계 지침과 같은 단위 기능을 명세화하는 단계 | 입.출력 기능 구현: 입.출력 기능을 위한 알고리즘 및 데이터를 구현하는 단계 | 알고리즘 구현: 단위 기능별로 모듈을 구현하는 단계 | 2. IPC(Inter-Process Communication) . 모듈 간 통신 방식을 구현하기 위해 사용되는 대표적인 프로그래밍 인터페이스 집합 | 복수의 프로세스를 수행하며 이뤄지는 프로세스 간 통신까지 구현이 가능함 | 대표 메소드 Shared Memory 공유 가능한 메모리를 구성하여 다수의 프로세스가 통신하는 방식 | . | Socket 네트워크 소켓을 이용하여 네트워크를 경유하는 프로세스 간에 통신하는 방식 | . | Semaphores 공유 자원에 대한 접근 제어를 통해 통신하는 방식 | . | Pipes&amp;named Pipes pipe라고 불리는 선입선출 형태로 구성된 메모리를 여러 프로세스가 공유하여 통신하는 방식 | pipe는 하나의 프로세스가 이용 중이라면 다른 프로세스는 접근할 수 없음 | . | Message Queueing 메시지가 발생하면 이를 전달하는 방식으로 통신하는 방식 | . | . | . 3. 단위 모듈 테스트 . 프로그램의 단위 기능으로 구현된 모듈이 정해진 기능을 정확히 수행하는지 검증하는 것 | 단위 테스트라고도 불림 | 단위 모듈 테스트의 기준은 단위 모듈에 대한 코드이므로 시스템 수준의 오류는 잡아낼 수 없음 | . 4. 테스트 케이스 . 구현된 소프트웨어가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위한 테스트 항목에 대한 명세서 . | 테스트 케이스를 이용하지 않은 테스트는 특정 요소에 대한 검증이 누락되거나 불필요한 검증의 반복으로 인해 인력과 시간을 낭비할 수 있음 . | ISO/IEC/IEEE 29119-3 표준에 따른 테스트 케이스의 구성 요소 . 식별자: 항목 식별자, 일련번호 . | 테스트 항목: 테스트 대상(모듈 또는 기능) . | 입력 명세: 입력 데이터 또는 테스트 조건 . | 출력 명세: 테스트 케이스 수행 시 예상되는 출력 결과 . | 환경 설정: 필요한 하드웨어나 소프트웨어의 환경 . | 특수 절차 요구: 테스트 케이스 수행 시 특별히 요구되는 절차 . | 의존성 기술: 테스트 케이스 간의 의존성 . | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/05/16/theory76.html",
            "relUrl": "/theory/2021/05/16/theory76.html",
            "date": " • May 16, 2021"
        }
        
    
  
    
        ,"post143": {
            "title": "모듈",
            "content": "1. 모듈 . 모듈화를 통해 분리된 시스템의 각 기능으로, 서브루틴, 서브시스템, 소프트웨어 내의 프로그램, 작업 단위 등을 의미함 | 모듈의 기능적 독립성은 소프트웨어를 구성하는 각 모듈의 기능이 서로 독립됨을 의미함 | 모듈의 독립성은 결합도와 응집도에 의해 측정됨 | . 2. 결합도(Coupling) 내공외제스자 . 모듈 간에 상호 의존하는 정도 또는 두 모듈 사이의 연관 관계 . | 결합도가 약할수록 품질이 높음 | 내용 결합도 (결합도 강함) | 공통 결합도 | 외부 결합도 | 제어 결합도 | 스탬프 결합도 | 자료 결합도 (결합도 약함!! 좋음) | . 3. 결합도의 종류 . 내용 결합도: 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때의 결합도 | 공통 결합도: 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도 | 외부 결합도: 어떤 모듈에서 선언한 데이터(변수)를 외부의 다른 모듈에서 참조할 때의 결합도 | 제어 결합도: 어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하기 위해 제어 신호나 제어 요소를 전달하는 결합도. 하위 모듈에서 상위 모듈로 제어 신호가 이동하여 하위 모듈이 상위 모듈에게 처리 명령을 내리는 권리 전도 현상이 발생하게 됨 | 스탬프 결합도: 모듈 간의 인터페이스로 배열이나 레코드 등의 자료 구조가 전달될 때의 결합도 | 자료 결합도: 모듈 간의 인터페이스가 자료 요소로만 구성될 때의 결합도 | . 4. 응집도(Cohesion) . 모듈의 내부 요소들이 서로 관련되어 있는 정도 | 응집도가 강할수록 품질이 높음 | 우연적 응집도(응집도 약함) | 논리적 응집도 | 시간적 응집도 | 절차적 응집도 | 통신적 응집도 | 순차적 응집도 | 기능적 응집도(응집도 강함!! 좋음) | . 5. 응집도의 종류 . 우연적 응집도: 모듈 내부의 각 구성 요소들이 서로 관련 없는 요소로만 구성된 경우의 응집도 | 논리적 응집도: 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우의 응집도 | 시간적 응집도: 특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우의 응집도 | 절차적 응집도: 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우의 응집도 | 통신적 응집도: 동일한 입력과 출력을 사용하여 서로 다른 기능을 수행하는 구성 요소들이 모였을 경우의 응집도 | 순차적 응집도: 모듈 내 하나의 활동으로부터 나온 출력 데이터를 그 다음 활동의 입력 데이터로 사용할 경우의 응집도 | 기능적 응집도: 모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우의 응집도 | . 6. 팬인/팬아웃 . 팬인(모듈에 들어오는 개수): 어떤 모듈을 제어하는 모듈의 수 | 팬아웃(모듈에서 나가는 것): 어떤 모듈에 의해 제어되는 모듈의 수 | 팬인이 높다는 것은 재사용 측면에서 설계가 잘 되어있다고 볼 수 있음 | 팬인이 높은 경우 단일 장애점이 발생할 수 있으므로 중점적인 관리 및 테스트가 필요함 | 다음의 시스템 구조도에서 각 모듈의 팬인과 팬아웃을 구하시오. | | 팬인 A: 0 B, C, D, E, G: 1 F, H, I: 2 | 팬아웃 H, I: 0 C, E, F, G: 1 B, D: 2 A: 3 | . 7. N-S 차트(Nassi-Schneiderman Chart) . 논리의 기술에 중점을 두고 도형을 이용해 표현하는 방법 | 박스 다이어그램, Chapin Chart라고도 함 | GOTO나 화살표를 사용하지 않음 | 연속, 선택 및 다중 선택, 반복의 3가지 제어 논리 구조로 표현함 | 조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하는 데 적합함 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/05/15/theory75.html",
            "relUrl": "/theory/2021/05/15/theory75.html",
            "date": " • May 15, 2021"
        }
        
    
  
    
        ,"post144": {
            "title": "객체지향 분석 및 설계",
            "content": "1. 객체지향 분석(OOA; Object Oriented Analysis) . 사용자의 요구사항과 관련된 객체, 속성, 연산, 관계 등을 정의하여 모델링하는 작업 | 개발을 위한 업무를 객체와 속성, 클래스와 멤버, 전체와 부분 등으로 나누어서 분석함 | 클래스를 식별하는 것이 객체지향 분석의 주요 목적 | . 2. 객체지향 분석의 방법론 . 럼바우 방법(Rumbaugh) 분석 활동을 객체 모델, 동적 모델, 기능 모델로 나누어 수행 | . | 부치 방법(Booch) 미시적 개발 프로세스와 거시적 개발 프로세스를 모두 사용 | 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의 | . | Jacobson 방법 유스케이스를 강조하여 사용함 | . | Coad와 Yourdon 방법 E-R 다이어그램을 사용하여 객체의 행위를 모델링 | 객체 식별, 구조 식별, 주제 정의, 속성과 인스턴스 연결 정의, 연산과 메시지 연결 정의 등의 과정으로 구성 | . | Wirls-Brock 방법 분석과 설계 간의 구분이 없고, 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행함 | . | . 3. 럼바우(Rumbaugh)의 분석 기법 . 모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링하는 기법 | 객체 모델링 기법이라고도 함 | . 객체 모델링 -&gt; 동적 모델링 -&gt; 기능 모델링 . 객체 모델링: 정보 모델링이라고도 하며, 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 객체 다이어그램으로 표시하는 것 | 동적 모델링: 상태 다이어그램을 이용하여 시간의 흐름에 따른 객체들 간의 제어 흐름, 상호 작용, 동작 순서 등의 동적인 행위를 표현하는 모델링 | 기능 모델링: 자료 흐름도(DFD)를 이용하여 다수의 프로세스들 간의 자료 흐름을 중심으로 처리 과정을 표현한 모델링 | . 4. 객체지향 설계 원칙 . 변경이나 확장에 유연한 시스템을 설계하기 위해 지켜져야 할 원칙임 . | SRP, OCP, LSP, ISP, DIP의 다섯 가지 원칙의 앞 글자를 따 SOLID 원칙이라고 부름 . | 단일 책임 원칙(SRP): 객체는 단 하나의 책임만 가져야 한다는 원칙 . | 개방-폐쇄 원칙(OCP): 기존의 코드를 변경하지 않고 기능을 추가할 수 있도록 설계해야 한다는 원칙 . | 리스코프 치환 원칙(LSP): 자식 클래스는 최소한 부모 클래스의 기능은 수행할 수 있어야 한다는 원칙 . | 인터페이스 분리 원칙(ISP): 자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야 한다는 원칙 . | 의존 역전 원칙(DIP): 의존 관계 성립 시 추상성이 높은 클래스와 의존 관계를 맺어야 한다는 원칙 . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/05/14/theory74.html",
            "relUrl": "/theory/2021/05/14/theory74.html",
            "date": " • May 14, 2021"
        }
        
    
  
    
        ,"post145": {
            "title": "객체지향",
            "content": "1. 객체지향 . 소프트웨어의 각 요소들을 객체로 만든 후, 객체들을 조립해서 소프트웨어를 개발하는 기법 | 구조적 기법의 문제점으로 인한 소프트웨어 위기의 해결책으로 채택되어 사용되고 있음 | 소프트웨어의 재사용 및 확장이 용이하여 고품질의 소프트웨어를 빠르게 발할 수 있고 유지보수가 쉬움 | 객체지향의 구성 요소 객체 | 클래스 | 메시지 | . | 특징 캡슐화 | 상속 | 다형성 | 연관성 | . | . 2. 객체 . 데이터와 이를 처리하기 위한 함수를 묶어 놓은 소프트웨어 모듈 | 데이터: 객체가 가지고 있는 정보(속성, 상태, 분류 등) | 함수: 객체가 수행하는 기능으로 객체가 갖는 데이터를 처리하는 알고리즘, 객체의 상태를 참조하거나 변경하는 수단 | . 3. 클래스 . 공통된 속성과 연산을 갖는 객체의 집합 | 각각의 객체들이 갖는 속성과 연산을 정의하고 있는 틀 | 클래스에 속한 각각의 객체를 인스턴스라고 함 | . 4. 메시지 . 객체들 간의 상호작용에 사용되는 수단으로 객체의 동작이나 연산을 일으키는 외부의 요구사항 | 메시지를 받은 객체는 대응하는 연산을 수행하여 예상된 결과를 반환 | . 5. 캡슐화 . 외부에서 접근을 제한하기 위해 인터페이스를 제외한 세부 내용을 은닉하는 것 | 캡슐화된 객체는 외부 모듈의 변경으로 인한 파급 효과가 적음 | 객체들 간에 메시지를 주고받을 때 상대 객체의 세부 내용은 알 필요가 없으므로 인터페이스가 단순해지고, 객체 간의 결합도가 낮아짐 | . 6. 상속 . 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것 | 하위 클래스는 물려받은 속성과 연산을 다시 정의하지 않아도 즉시 자신의 속성으로 사용할 수 있음 | 하위 클래스는 상속받은 속성과 연산 외에 새로운 속성과 연산을 첨가하여 사용할 수 있음 | . 7. 다형성 . 하나의 메시지에 대해 각각의 객체가 가지고 있는 고유한 방법으로 응답할 수 있는 능력 | 객체들은 동일한 메소드명을 사용하여 같은 의미의 응답을 함 | ’+’ 연산자의 경우 숫자 클래스에서는 덧셈, 문자 클래스에서는 문자열의 연결 기능으로 사용 | . 8. 연관성 . 두 개 이상의 객체들이 상호 참조하는 관계 | . 종류 의미 특징 . is member of | 연관화 | 2개 이상의 객체가 상호 관련되어 있음 | . is instance of | 분류화 | 동일한 형의 특성을 갖는 객체들을 모아 구성하는 것 | . is part of | 집단화 | 관련 있는 객체들을 묶어 하나의 상위 객체를 구성하는 것 | . is a | 일반화 | 공통적인 성질들로 추상화한 상위 객체를 구성하는 것 | .   | 특수화/상세화 | 상위 객체를 구체화하여 하위 객체를 구성하는 것 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/05/13/theory73.html",
            "relUrl": "/theory/2021/05/13/theory73.html",
            "date": " • May 13, 2021"
        }
        
    
  
    
        ,"post146": {
            "title": "아키텍처 패턴",
            "content": "1. 아키텍처 패턴 . 아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제 | 소프트웨어 시스템의 구조를 구성하기 위한 기본적인 윤곽을 제시 | 아키텍처 패턴에는 서브시스템들과 그 역할이 정의되어 있음 | 서브시스템 사이의 관계와 여러 규칙.지침 등이 포함 | 주요 아키텍처 패턴의 종류 레이어 패턴 | 클라이언트-서버 패턴 | 파이프-필터 패턴 | 모델-뷰-컨트롤러 패턴 | . | . 2. 레이어 패턴 . 시스템을 계층적으로 구분하여 구성하는 고전적인 방법의 패턴 | 상위 계층은 하위 계층에 대한 서비스 제공자가 되고 하위 계층은 상위 계층의 클라이언트가 됨 | 서로 마주보는 두 개의 계층 사이에서만 상호작용이 이루어짐 | 대표적으로 OSI 참조 모델이 있음 | . 3. 클라이언트-서버 패턴 . 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴 | 사용자가 클라이언트를 통해 서버에 요청하면 클라이언트가 응답을 받아 사용자에게 제공하는 방식 | . 4. 파이프-필터 패턴 . 데이터 스트림 절차의 각 단계를 필터로 캡슐화하여 파이프를 통해 전송하는 패턴 | 앞 시스템의 처리 결과물을 파이프를 통해 전달받아 처리한 후 그 결과물을 다시 파이프를 통해 다음 시스템으로 넘겨주는 패턴을 반복 | 데이터 변환, 버퍼링, 동기화 등에 주로 사용 | 대표적으로 UNIX의 쉘이 있음 | . 5. 모델-뷰-컨트롤러 패턴 . 서브시스템을 모델, 뷰, 컨트롤러로 구조화하는 패턴 | 컨트롤러가 사용자의 요청을 받으면 핵심 기능과 데이터를 보관하는 모델을 이용하여 뷰에 정보를 출력 | 여러 개의 뷰를 만들 수 있음 | 한 개의 모델에 대해 여러 개의 뷰를 필요로 하는 대화형 애플리케이션에 적합함 | . 6. 기타 패턴 . 마스터-슬레이브 패턴 슬레이브 컴포넌트에서 처리된 결과물을 다시 돌려받는 방식으로 작업을 수행하는 패턴 | 장애 허용 시스템, 병렬 컴퓨팅 시스템 | . | 브로커 패턴 사용자가 원하는 서비스와 특성을 브로커 컴포넌트에 요청하면 브로크 컴포넌트가 요청에 맞는 컴포넌트와 사용자를 연결해주는 패턴 | 분산 환경 시스템 | . | 피어-투-피어 패턴 피어라 불리는 하나의 컴포넌트가 클라이언트가 될 수도, 서버가 될 수도 있는 패턴 | 파일 공유 네트워크 | . | 이벤트-버스 패턴 소스가 특정 채널에 이벤트 메시지를 발행하면, 해당 채널을 구독한 리스너들이 메시지를 받아 이벤트를 처리하는 패턴 | 알림 서비스 | . | 블랙보드 패턴 모든 컴포넌트들이 공유 데이터 저장소와 블랙보드 컴포넌트에 접근이 가능한 패턴 | 음성 인식, 차량 식별, 신호 해석 | . | 인터프리터 패턴 프로그램 코드의 각 라인을 수행하는 방법을 지정하고, 기호마다 클래스를 갖도록 구성된 패턴 | 번역기, 컴파일러, 인터프리터 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/05/12/theory72.html",
            "relUrl": "/theory/2021/05/12/theory72.html",
            "date": " • May 12, 2021"
        }
        
    
  
    
        ,"post147": {
            "title": "소프트웨어 아키텍처",
            "content": "1. 소프트웨어 아키텍처 . 소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체임 | 애플리케이션의 분할 방법과 분할된 모듈에 할당될 기능, 모듈 간의 인터페이스 등을 결정함 | 소프트웨어 아키텍처 설계의 기본 원리에는 모듈화, 추상화, 단계적 분해, 정보은닉이 있음 | . 2. 모듈화 . 소프트웨어의 성능 향상, 시스템의 수정 및 재사용, 유지 관리 등이 용이하도록 시스템의 기능들을 모듈 단위로 나누는 것을 의미 | 모듈의 크기를 너무 작게 나누면 개수가 많아져 모듈 간의 통합 비용이 많이 든다. | 모듈의 크기를 너무 크게 나누면 개수가 적어 통합 비용은 적게 들지만 모듈 하나의 개발 비용이 많이 든다. | . 3. 추상화 . 문제의 전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화시켜 나가는 것 | 완전한 시스템을 구축하기 전에 그 시스템과 유사한 모델을 만들어서 여러 가지 요인들을 테스트할 수 있음 | 유형 과정 추상화 자세한 수행 과정을 정의하지 않고, 전반적인 흐름만 파악할 수 있게 설계하는 방법 | . | 데이터 추상화 데이터의 세부적인 속성이나 용도를 정의하지 앟고, 데이터 구조를 대표할 수 있는 표현으로 대체하는 방법 | . | 제어 추상화 이벤트 발생의 정확한 절차나 방법을 정의하지 않고, 대표할 수 있는 표현으로 대체하는 방법 | . | . | . 4. 단계적 분해 . 문제를 상위의 중요 개념으로부터 하위의 개념으로 구체화시키는 분할 기법 | Niklaus Wirth에 의해 제안된 하향식 설계 전략 | 소프트웨어의 포괄적인 기능에서부터 시작하여 점차적으로 구체화하고, 알고리즘, 자료 구조 등 상세한 내역은 가능한 한 뒤로 미루어 진행함 | . 5. 정보 은닉 . 한 모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법 | 정보 은닉을 통해 모듈을 독립적으로 수행할 수 있음 | 하나의 모듈이 변경되더라도 다른 모듈에 영향을 주지 않으므로 수정, 시험, 유지보수가 용이함 | . 6. 상위 설계와 하위 설계 .   상위 설계 하위 설계 . 별칭 | 아키텍처 설계, 예비 설계 | 모듈 설계, 상세 설계 | . 설계 대상 | 시스템의 전체적인 구조 | 시스템의 내부 구조 및 행위 | . 세부 목록 | 구조, DB, 인터페이스 | 컴포넌트, 자료 구조, 알고리즘 | . 7. 소프트웨어 아키텍처의 품질 속성 . 소프트웨어 아키텍처가 이해 관계들이 요구하는 수준의 품질을 유지 및 보장할 수 있게 설계되었는지 확인하기 위해 품질 평가 요소들을 구체화시켜 놓은 것 | 시스템 측면 성능, 보안, 가용성, 기능성, 사용성, 변경 용이성, 확장성 등 | . | 비즈니스 측면 시장 적시성, 비용과 혜택, 예상 시스템 수명, 목표 시장, 공개 일정 등 | . | 아키텍처 측면 개념적 무결성, 정확성, 완결성, 구축 가능성, 변경성, 시험성 등 | . | . 8. 소프트웨어 아키텍처의 설계 과정 . 설계 목표 설정 . 요구사항을 분석하여 전체 시스템의 설계 목표 설정 . | 시스템 타입 설정 . 시스템과 서브시스템의 타입을 결정하고, 아키텍처 패턴 선택 . | 아키텍처 패턴 적용 . 시스템의 표준 아키텍처 설계 . | 서브시스템 구체화 . 서브시스템의 기능 및 서브시스템 간의 상호작용을 위한 동작과 인터페이스 정의 . | 검토 . 설계 목표, 요구사항, 설계의 기본 원리 등을 만족하는지 아키텍처 검토 . | 9. 협약에 의한 설계 . 컴포넌트를 설계할 때 클래스에 대한 여러 가정을 공유할 수 있도록 명세한 것 | 컴포넌트에 대한 정확한 인터페이스를 명세함 | 조건 선행 조건: 오퍼레이션이 호출되기 전에 참이 되어야 할 조건 | 결과 조건: 오퍼레이션이 수행된 후 만족되어야 할 조건 | 불변 조건: 오퍼레이션이 실행되는 동안 항상 만족되어야 할 조건 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/05/11/theory71.html",
            "relUrl": "/theory/2021/05/11/theory71.html",
            "date": " • May 11, 2021"
        }
        
    
  
    
        ,"post148": {
            "title": "개발 환경 구축",
            "content": "1. 개발 환경 구축 . 응용 소프트웨어 개발을 위해 개발 프로젝트를 이해하고 소프트웨어 및 하드웨어 장비를 구축하는 것을 의미 | 개발 환경은 응용 소프트웨어가 운영될 환경과 유사한 구조로 구축 | 분석 단계의 산출물을 바탕으로 개발에 필요한 하드웨어와 소프트웨어를 선정함 | 하드웨어와 소프트웨어의 성능, 편의성, 라이선스 등의 비즈니스 환경에 적합한 제품들을 최종적으로 결정하여 구축함 | . 2. 하드웨어 환경 . 사용자와의 인터페이스 역할을 하는 클라이언트 그리고 클라이언트와 통신하여 서비스를 제공하는 서버로 구성 | 클라이언트의 종류: 개인용 컴퓨터(pc), 스마트폰 등 | 서버의 종류 웹 서버(Web Server) 클라이언트로부터 직접 요청을 받아 처리함 | 저용량의 정적 파일들을 제공함 | . | 웹 애플리케이션 서버(WAS; Web Application Server) 동적 서비스를 제공하거나, 웹 서버와 데이터베이스 서버 또는 웹 서버와 파일 서버 사이에서 인터페이스 역할을 수행함 | . | 데이터베이스 서버(DB Server) 데이터베이스와 이를 관리하는 DBMS를 운영함 | . | 파일 서버(File Server) 데이터베이스에 저장하기에는 비효율적이거나 서비스 제공을 목적으로 유지하는 파일들을 저장함 | . | . | . 3. 소프트웨어 환경 . 클라이언트와 서버 운영을 위한 시스템 소프트웨어와 개발에 사용되는 개발 소프트웨어로 구성 . | 시스템 소프트웨어의 종류: 운영체제(OS), 웹 서버 및 WAS 운용을 위한 서버 프로그램, DBMS 등 . | 개발 소프트웨어의 종류 . 요구사항 관리 도구 . 요구사항의 수집과 분석, 추적 등을 편리하게 도와주는 소프트웨어 . | 설계/모델링 도구 . UML(통합 모델링 언어)을 지원하며, 개발의 전 과정에서 설계 및 모델링을 도와주는 소프트웨어 | . | 구현 도구 . 개발 언어를 통해 애플리케이션의 실제 구현을 지원하는 소프트웨어 | . | 빌드 도구 . 구현 도구를 통해 작성된 소스의 빌드 및 배포, 라이브러리 관리를 지원하는 소프트웨어 | . | 테스트 도구 . 모듈들이 요구사항에 적합하게 구현되었는지 테스트하는 소프트웨어 | . | 형상 관리 도구 . 산출물들을 버전별로 관리하여 품질 향상을 지원하는 소프트웨어 | . | . | . 4. 웹 서버의 기능 . HTTP/HTTPS 지원 브라우저로부터 요청을 받아 응답할 때 사용되는 프로토콜 | . | 통신 기록 처리한 요청들을 로그 파일로 기록하는 기능 | . | 정적 파일 관리 HTML, CSS, 이미지 등의 정적 파일들을 저장하고 관리하는 기능 | . | 대역폭 제한 네트워크 트래픽의 포화를 방지하기 위해 응답 속도를 제한하는 기능 | . | 가상 호스팅 하나의 서버로 여러 개의 도메인 이름을 연결하는 기능 | . | 인증 사용자가 합법적인 사용자인지를 확인하는 기능 | . | . 5. 개발 언어의 선정 기준 . 적정성: 개발하려는 소프트웨어의 목적에 적합해야 함 | 효율성: 코드의 작성 및 구현이 효율적이어야 함 | 이식성: 다양한 시스템 및 환경에 적용이 가능해야 함 | 친밀성: 개발 언어에 대한 개발자들의 이해도와 활용도가 높아야 함 | 범용성: 다른 개발 사례가 존재하고 여러 분야에서 활용되고 있어야 함 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/05/10/theory70.html",
            "relUrl": "/theory/2021/05/10/theory70.html",
            "date": " • May 10, 2021"
        }
        
    
  
    
        ,"post149": {
            "title": "연계 테스트",
            "content": "1. 연계 테스트의 개요 . 구축된 연계 시스템과 연계 시스템의 구성 요소가 정상적으로 동작하는지 확인하는 활동 | 진행 순서 | . 연계 테스트 케이스 작성 . 연계 시스템 간의 데이터 및 프로세스의 흐름을 분석하여 필요한 테스트 항목을 도출함 | | 연계 테스트 환경 구축 . 테스트의 일정, 방법, 절차, 소요 시간 등을 송.수신 기관과의 협의를 통해 결정 | | 연계 테스트 수행 . 연계 응용 프로그램을 실행하여 연계 테스트 케이스의 시험 항목 및 처리 절차 등을 실제로 진행함 | | 연계 테스트 수행 결과 검증 . 연계 테스트 케이스의 시험 항목 및 처리 절차를 수행한 결과가 예상 결과와 동일한지 확인함 | |",
            "url": "https://eunkyung99.github.io/gang/theory/2021/05/09/theory69.html",
            "relUrl": "/theory/2021/05/09/theory69.html",
            "date": " • May 9, 2021"
        }
        
    
  
    
        ,"post150": {
            "title": "XML(eXtensible Markup Language)",
            "content": "1. XML . 특수한 목적을 갖는 마크업 언어를 만드는 데 사용되는 다목적 마크업 언어 | 웹브라우저 간 HTML 문법이 호환되지 않는 문제와 SGML의 복잡합을 해결하기 위하여 개발되었음 | 사용자가 직접 문서의 태그를 정의할 수 있으며, 다른 사용자가 정의한 태그를 사용할 수 있음 | 트리 구조로 구성되어 있어 상위 태그는 여러 개의 하위 태그를 가질 수 있음 | . 2. SOAP(Simple Object Access Protocol) . 컴퓨터 네트워크 상에서 HTTP/HTTPS, SMTP 등을 이용하여 XML을 교환하기 위한 통신 규약임 | 웹 서비스에서 사용되는 메시지의 형식과 처리 방법을 지정함 | 기본적으로 HTTP 기반에서 동작하기 때문에 프록시와 방화벽의 영향 없이 통신할 수 있음 | 최근에는 무거운 구조의 SOAP 대신 RESTful 프로토콜을 이용하기도 함 | . 3. WSDL(Web Services Description Language) . WSDL은 웹 서비스와 관련된 서식이나 프로토콜 등을 표준적인 방법으로 기술하고 게시하기 위한 언어 | XML로 작성되며, UDDI의 기초가 됨 | SOAP, XML 스키마와 결합하여 인터넷에서 웹 서비스를 제공하기 위해 사용됨 | 클라이언트는 WSDL 파일을 읽어 서버에서 어떠한 조작이 가능한지를 파악할 수 있음 | . 마크업 언어: 서식이나 문서 내.외의 다른 요소와의 연결 등을 표현하는 부호를 정의하여 다른 문서의 논리 구조나 체계를 정의하는 언어 .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/05/07/theory68.html",
            "relUrl": "/theory/2021/05/07/theory68.html",
            "date": " • May 7, 2021"
        }
        
    
  
    
        ,"post151": {
            "title": "연계 데이터 보안 적용",
            "content": "1. 연계 데이터 보안 . 송신 시스템에서 수신 시스템으로 전송되는 연계 데이터는 보안에 취약할 수 있으므로 데이터의 중요성을 고려하여 보안 적용해야 함 | 일반적인 연계 데이터의 보안 방식 전송 구간 보안 | 데이터 보안 | . | . 2. 전송 구간 보안 . 전송되는 데이터나 패킷을 쉽게 가로챌 수 없도록 암호화 기능이 포함된 프로토콜을 사용 | 데이터나 패킷을 가로채더라도 내용을 확인할 수 없게 데이터나 패킷을 암호화함 | . 3. 데이터 보안 . 송신 시스템에서 연계 데이터를 추출할 때와 수신 시스템에서 데이터를 운영 DB에 반영할 때 데이털를 암.복호화하는 것 . | 데이터의 암.복호화 처리 절차 . 송신 시스템 | . DB에서 연계 데이터 추출 | 보안 적용 대상 컬럼을 암호화 | 연계 데이터를 인터페이스 테이블 또는 파일에 등록 및 송신 | 수신 시스템 | . 수신된 데이터 중 암호화한 컬럼을 복호화 | 운영 DB에 반영 | | . 4. 암.복호화 적용 절차 . 암호화 적용 대상, 암호화 알고리즘, 암호화 키 선정 | 암호화 적용 대상 컬럼의 데이터 길이 변경 | 암호화 알고리즘 라이브러리 확보 및 설치 | 연계 응용 프로그램에서 암.복호화 처리 수행 |",
            "url": "https://eunkyung99.github.io/gang/theory/2021/05/07/theory67.html",
            "relUrl": "/theory/2021/05/07/theory67.html",
            "date": " • May 7, 2021"
        }
        
    
  
    
        ,"post152": {
            "title": "연계 장애 및 오류처리 구현",
            "content": "1. 연계 메커니즘 구간별 장애 및 오류 모니터링 현황 . 연계 메커니즘에서 오류 발생 시점, 오류 로그 기록 장소, 오류 로그 기록 주체는 크게 송.수신 시스템, 연계 서버 구간으로 구분됨 | 구간별 주요 오류 발생 시점 송신 시스템 데이터 생성 및 추출 시 | 코드 매핑 및 데이터 변환 시 | 인터페이스 테이블 또는 파일 등록 시 | . | 수신 시스템 연계 데이터 로드 시 | 코드 매핑 및 데이터 변환 시 | 운영 DB에 반영 시 | . | 연계 서버 연계 데이터 로드 및 전송 형식으로 변환 시 | 연계 데이터 송.수신 시 | 수신 시스템의 데이터 형식으로 변환 및 로드 시 | . | . | . 2. 장애 및 오류 유형과 처리방안 . 장애 및 오류 유형의 분류 송.수신 시스템의 연계 프로그램 오류 | 연계 서버의 오류 | 연계 데이터의 오류 | . | 송.수신 시스템의 연계 프로그램과 연계 서버에서 기록하는 로그를 통해 장애 및 오류 원인을 확인하고 분석하여 적절한 처리방안을 선택 | . 3. 장애 및 오류의 확인과 처리 절차 . 1차적으로 연계 서버에서 제공하는 장애 및 오류 현황 모니터링 화면을 통해 오류 원인 및 발생 현환을 확인함 | 1차에서 확인이 불가능한 경우 송.수신 시스템의 연계 프로그램과 연계 서버에서 기록한 오류 로그 테이블 또는 파일을 확인하여 오류 원인을 분석함 | 발생한 오류에 대한 원인이 확인되면 원인에 따른 적절한 조치를 취함 | . 4. 장애 및 오류의 정의와 설계 . 장애 및 오류 관리 대상 송.수신 시스템의 연계 프로그램에서 관리하는 장애 및 오류를 관리 대상으로 정의함 | . | 관리 대상의 장애 및 오류 코드와 메시지 관리 대상에서 식별한 오류 내용을 주제별로 분류한 후 각 오류 내용에 오류 코드를 부여하고 오류 메시지를 정의 | . | 장애 및 오류 코드와 메시지 관리 방식 관리 대상 오류 코드와 오류 메시지가 많은 경우에는 테이블 관리 방식을, 적은 경우에는 파일 관리 방식 선택함 | . | 장애 및 오류 기록 방식 오류 로그 테이블이나 파일은 기록 단위에 따라 인터페이스 테이블이나 파일에 대한 로그, 연계 데이터에 대한 로그로 설계 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/05/06/theory66.html",
            "relUrl": "/theory/2021/05/06/theory66.html",
            "date": " • May 6, 2021"
        }
        
    
  
    
        ,"post153": {
            "title": "연계 메커니즘",
            "content": "1. 연계 메커니즘 . 데이터의 생성 및 전송을 담당하는 송신 시스템과 데이터 수신 및 운영 DB 반영을 담당하는 수신 시스템으로 구성됨 | 송.수신 시스템 사이에는 데이터의 송.수신과 송.수신 시스템 현황을 모니터링하는 중계 시스템을 설치할 수 있음 | 연계 방식 직접 연계 방식 중간 매개체 없이 송.수신 시스템이 직접 연계하는 방식 | 종륨: DB Link, API/Open API, DB Connection, JDBC 등 | . | 간접 연계 방식 송.수신 시스템 사이에 중간 매개체를 두어 연계하는 방식 | 종류: 연계 솔루션, ESB, 소켓, 웹 서비스 등 | . | . | . 2. 연계 메커니즘의 과정 . . 3. 연계 메커니즘의 구성 . 연계 데이터 생성 및 추출 연계 솔루션과 관계없이 응용 시스템에서 연계 데이터를 생성하고 추출하는 과정 | . | 코드 매핑 및 데이터 변환 송신 시스템에서 사용하는 코드를 수신 시스템에서 사용하는 코드로 매핑 및 변환하는 과정 | . | 인터페이스 테이블 또는 파일 생성 연계 데이터를 인터페이스 테이블이나 파일 형식으로 생성하는 과정 | . | 로그 기록 송.수신 시스템에서 수행되는 모든 과정에 관한 결과 및 오류에 대한 정보를 로그 테이블이나 파일에 기록하는 과정 | . | 연계 서버 또는 송.수신 어댑터 연계 서버: 데이터를 전송 형식에 맞게 변환하고 송.수신을 수행하는 등 송.수신과 관련된 모든 처리 수행 | 송신 어댑터: 인터페이스 테이블 또는 파일의 데이터를 전송 형식에 맞도록 변환 및 송신 수행 | 수신 어댑터: 수신 데이터를 인터페이스 테이블이나 파일로 생성 | . | 전송 송신 시스템에서 생성된 연계 데이터를 네트워크 환경에 맞는 데이터로 변환한 후 수신 시스템으로 보내는 것 | . | 운영 DB에 연계 데이터 반영 수신된 인터페이스 테이블 또는 파일 구조의 데이터를 변환 프로그램을 이용하여 수신 시스템의 운영 DB에 반영하는 과정 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/05/05/theory65.html",
            "relUrl": "/theory/2021/05/05/theory65.html",
            "date": " • May 5, 2021"
        }
        
    
  
    
        ,"post154": {
            "title": "통합 구현",
            "content": "1. 통합 구현 . 사용자의 요구사항에 맞춰 송.수신 모듈과 중게 모듈 간의 연계를 구현하는 것을 의미함 | 송.수신 방식이나 시스템 아키텍처 구성, 송.수신 모듈 구현 방법 등에 따라 다르므로 사용자의 요구사항과 구축 환경에 적합한 방식을 설계해야 함 . | 일반적인 통합 구현은 송.수신 시스템과 모듈, 중계 시스템, 연계 데이터, 네트워크로 구성 | . 2. 통합 구현의 구성 요소 . 송신 시스템과 모듈 송신 시스템: 데이터를 생성 및 변환하여 전송하는 시스템. 송신 모듈과 모니터링 기능으로 구성 | 송신 모듈: 전송 데이터를 생성하고 필요에 따라 전송 데이터의 변환 등을 수행함 | . | 수신 시스템과 모듈 수신 시스템: 수신 받은 데이터를 정제 및 변환하는 시스템. 수신 모듈과 모니터링 기능으로 구성 | 수신 모듈: 수신 데이터를 정제하고 애플리케이션이나 데이터베이스 테이블에 적합한 데이터로 변환하는 작업 등을 수행함 | . | 중계 시스템 내.외부 시스템 간 또는 내부 시스템 간의 연계 시 사용되는 아키텍처 | . | 연계 데이터 송.수신 시스템 간 송.수신되는 데이터 | . | 네트워크 송신 시스템, 수신 시스템, 중계 시스템을 연결해주는 통신망 | . | . 3. 연계 요구사항 분석 . 통합 구현을 위해 사용자 요구사항을 분석하여 연계 데이터를 식별 및 표준화하여 연계 데이터를 정의하는 것 | 분석 절차 하드웨어 및 소프트웨어 구성, 네트워크 현황 확인 | 테이블 정의서, 코드 정의서 등의 문서 확인 | 체크리스트 작성 | 관련 문서 공유 및 인터뷰.설문 조사 실시 | 요구사항 정의서 작성 | | . 4. 연계 데이터 식별 및 표준화의 절차 . 연계 범위 및 항목 정의 시스템 간 연계할 정보를 상세화하여 정의 | . | 연계 코드 변환 및 매핑 연계 정보 중 코드로 관리되어야 할 항목을 찾아 코드로 변환 | . | 연계 데이터 식별자와 변경 구분 추가 연계 정보에 데이터 구분 식별자, 작업 구분 정보, 테이블/파일 관리 정보 등을 추가 | . | 연계 데이터 표현 방법 정의 연계 대상 범위, 대상 항목, 코드 변환 방식, 매핑 방식을 정의한 후 연계 데이터 구성 | . | 연계 정의서 및 명세서 작성 이전 과정에서 정의된 다양한 항목들과 파악된 현황들을 문서화함 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/05/04/theory64.html",
            "relUrl": "/theory/2021/05/04/theory64.html",
            "date": " • May 4, 2021"
        }
        
    
  
    
        ,"post155": {
            "title": "정렬",
            "content": "1. 삽입 정렬(Insertion Sort) . 가장 간단한 정렬 방식으로, 이미 순서화된 파일에 새로운 하나의 레코드를 순서에 맞게 삽입시켜 정렬하는 방식 | 평균과 최악 모두 수행 시간 복잡도는 O(N^2) | . . 2. 선택 정렬(Selection Sort) . n개의 레코드 중에서 최소값을 찾아 첫 번째 레코드 위치에 놓고 나머지 (n-1)개 중에서 다시 최소값을 찾아 두 번째 레코드 위치에 놓는 방식을 반복하여 정렬하는 방식 | 평균과 최악 모두 수행 시간 복잡도는 O(N^2) | . . 3. 버블 정렬(Bubble Sort) . 주어진 파일에서 인접한 두 개의 레코드 키 값을 비교하여 그 크기에 따라 레코드 위치를 서로 교환하는 정렬 방식 | 평균과 최악 모두 수행 시간 복잡도는 O(N^2) | . . 4. 쉘 정렬(Shell Sort) . 입력 파일을 어떤 매개변수의 값으로 서브파일을 구성하고, 각 서브파일을 Insertion 정렬 방식으로 순서 배열하는 과정을 반복하는 정렬 방식 | 삽입 정렬을 확장한 개념 | 평균 수행 시간 복잡도는 O(N^1.5)이고, 최악의 수행 시간 복잡도는 O(N^2) | . 5. 퀵 정렬(Quick Sort) . 키를 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽 서브 파일에 분해시키는 과정을 반복시키는 정렬 방식 | 레코드의 많은 자료 이동을 없애고 하나의 파일을 부분적으로 나누어 가면서 정렬 | 평균 수행 시간 복잡도는 O(nlogn)이고, 최악의 수행 시간 복잡도는 O(N^2) | . 6. 힙 정렬(Heap Sort) . 전이진 트리를 이용한 정렬 방식 | 구성된 전이진 트리를 Heap Tree로 변환하여 정렬 | 평균과 최악 모두 시간 복잡도는 O(nlogn) | . 7. 2-Way 합병 정렬(Merge Sort) . 이미 정렬되어 있는 두 개의 파일을 한 개의 파일로 합병하는 정렬 방식 | 평균과 최악 모두 시간 복잡도는 O(nlogn) | . 8. 기수 정렬(Radix Sort) = Bucket Sort . Queue를 이용하여 자릿수별로 정렬하는 방식 | 레코드의 키 값을 분석하여 같은 수 또는 같은 문자끼리 그 순서에 맞는 버킷에 분배하였다가 버킷의 순서대로 레코드를 꺼내어 정렬한다. | 평균과 최악 모두 시간 복잡도는 O(dn) | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/05/03/theory63.html",
            "relUrl": "/theory/2021/05/03/theory63.html",
            "date": " • May 3, 2021"
        }
        
    
  
    
        ,"post156": {
            "title": "이진 트리(Tree)",
            "content": "1. 이진 트리 . 차수가 2 이하인 노드들로 구성된 트리. 즉 자식이 둘 이하인 노드들로만 구성된 트리 | 이진 트리의 레벨 i에서 최대 노드의 수는 2^(i-1)임 | 이진 트리에서 단말 노드 수가 n0, 차수가 2인 노드 수가 n2라 할 때 n0=n2+1이 됨 | 레벨 3에서 최대 노드의 수는 2^(3-1)=4임 | 단말 노드의 개수가 4개이고, 디그리가 2인 노드가 3개이므로 4=3+1에 의해 n0=n2+1이 성립함 | . | . 2. 트리의 운행법 . 트리를 구성하는 각 노드들을 찾아가는 방법을 운행법이라고 함 | 이진 트리를 운행하는 방법은 산술식의 표기법과 연관성을 가짐 | Preorder 운행: Root -&gt; Left -&gt; Right 순으로 운행 | Inorder 운행: Left -&gt; Root -&gt; Right 순으로 운행 | Postorder 운행: Left -&gt; Right -&gt; Root 순으로 운행 | . 3. Preorder 운행법 . 이진 트리를 Root -&gt; Left -&gt; Right 순으로 운행하며 노드들을 찾아가는 방법 | | 서브트리를 하나의 노드로 생각할 수 있도록 그림과 같이 서브트리 단위로 묶음. 다른 운행법 모두 공통으로 사용함 | . Preorder는 Root -&gt; Left -&gt; Right 순이므로 A13이 된다. | 1은 B2E이므로 AB2E3이 된다. | 2는 DHI이므로 ABDHIE3이 된다. | 3은 CFG이므로 ABDHIECFG가 된다. | 방문 순서: ABDHIECFG | . 4. Inorder 운행법 . 이진 트리를 Left -&gt; Root -&gt; Right 순으로 운행하며 노드들을 찾아가는 방법 | . Inorder는 Left -&gt; Root -&gt; Right 순이므로 1A3이 된다. | 1은 2BE이므로 2BEA3이 된다. | 2는 HDI이므로 HDIBEA3이 된다. | 3은 FCG이므로 HDIBEAFCG가 된다. | 방문 순서: HDIBEAFCG | . 5. Postorder 운행 . 이진 트리를 Left -&gt; Right -&gt; Root 순으로 운행 | . Postorder는 Left -&gt; Right -&gt; Root 순이므로 13A가 된다. | 1은 2EB이므로 2EB3A가 된다. | 2는 HID이므로 HIDEB3A가 된다. | 3은 FGC이므로 HIDEBFGCA가 된다. | 방문 순서: HIDEBFGCA | . 6. 수식의 표기법 . 이진 트리로 만들어진 수식을 인오더, 프리오더, 포스트오더 순으로 운행하면 각각 중위(Infix), 전위(Prefix), 후위(Postfix) 표기법이 됨 | 전위 표기법: 연산자 -&gt; Left -&gt; Right +AB | 중위 표기법: Left -&gt; 연산자 -&gt; Right A+B | 후위 표기법: Left -&gt; Right -&gt; 연산자 AB+ | . Infix 표기를 Postfix나 Prefix로 바꾸기 . postfix나 prefix는 스택을 이용하여 처리하므로 infix는 postfix나 prefix로 바꾸어 처리함 . | X=A/B*(C+D)+E . | Prefix로 변환하기 . 연산 우선순위에 따라 괄호로 묶는다. . (X = ( ( (A/B) * (C+D) ) + E ) ) . | 연산자를 해당 괄호의 앞으로 옮긴다. . = (X + (* (/ (A B) + (C D)) E)) . | 필요 없는 괄호를 제거한다. . = X + * / A B + C D E . | | Postfix로 변환하기 . 연산 우선순위에 따라 괄호로 묶는다. . (X = ( ( (A/B) * (C+D) ) + E ) ) . | 연산자를 해당 괄호의 뒤로 옮긴다. . (X ((A B) / (C D) + * E) +)= . | 필요 없는 괄호를 제거한다. . X A B / C D + * E + = . | | . Postfix나 Prefix로 표기된 수식을 Infix로 바꾸기 . Postfix는 Infix 표기법에서 연산자를 해당 피연산자 두 개의 뒤로 이동한 것이므로 연산자를 다시 해당 피연산자 두 개의 가운데로 옮기면 된다. | . 먼저 인접한 피연산자 두 개와 오른쪽의 연산자를 괄호로 묶는다. | 연산자를 해당 피연산자의 가운데로 이동시킨다. | 필요 없는 괄호를 제거한다. | Prefix는 Infix 표기법에서 연산자를 해당 피연산자 두 개의 앞으로 이동한 것이므로 연산자를 다시 해당 피연산자 두 개의 가운데로 옮기면 된다. | . 먼저 인접한 피연산자 두 개와 왼쪽의 연산자를 괄호로 묶는다. | 연산자를 해당 피연산자의 가운데로 이동시킨다. | 필요 없는 괄호를 제거한다. |",
            "url": "https://eunkyung99.github.io/gang/theory/2021/05/02/theory62.html",
            "relUrl": "/theory/2021/05/02/theory62.html",
            "date": " • May 2, 2021"
        }
        
    
  
    
        ,"post157": {
            "title": "트리(Tree)",
            "content": "1. 트리 . 정점(Node, 노드)과 선분(Branch, 가지)을 이용하여 사이클을 이루지 않도록 구성한 그래프의 특수한 형태 | 하나의 기억 공간을 노드라고 하며, 노드와 노드를 연결하는 선을 링크(Link)라고 함 | . 2. 트리 관련 용어 . . 노드: 트리의 기본 요소로서 자료 항목과 다른 항목에 대한 가지를 합친 것 A, B, C, D, E, F, G, H, I, J, K, L, M | . | 근 노드: 트리의 맨 위에 있는 노드 A | . | 디그리(차수): 각 노드에서 뻗어나온 가지의 수 A=3, B=2, C=1, D=3 | . | 단말 노드=잎 노드: 자식이 하나도 없는 노드, 즉 Degree가 0인 노드 K, L, F, G, M, I, J | . | 비단말 노드: 자식이 하나라도 있는 노드, 즉 Degree가 0이 아닌 노드 A, B, C, D, E, H | . | 조상 노드: 임의의 노드에서 근 노드에 이르는 경로상에 있는 느도들 M의 조상 노드는 H, D, A | . | 자식 노드: 어떤 노드에 연결된 다음 레벨의 노드들 D의 자식 노드: H, I, J | . | 부모 노드: 어떤 노드에 연결된 이전 레벨의 노드들 E, F의 부모 노드는 B | . | 형제 노드: 동일한 부모를 갖는 노드들 H의 형제 노드는 I, J | . | Level: 근 노드의 레벨을 1로 가정한 후 어떤 레벨이 L이면 자식 노드는 L+1 H의 레벨은 3 | . | 깊이: Tree에서 노드가 가질 수 있는 최대의 레벨 위 트리의 깊이는 4 | . | 숲: 여러 개의 트리가 모여 있는 것 위 트리에서 근 노드 A를 제거하면 B, C, D를 근 노드로 하는 세 개의 트리가 있는 숲이 생김 | . | 트리의 디그리: 노드들의 디그리 중에서 가장 많은 수 노드 A나 D가 세 개의 디그리를 가지므로 위 트리의 디그리는 3임 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/05/01/theory61.html",
            "relUrl": "/theory/2021/05/01/theory61.html",
            "date": " • May 1, 2021"
        }
        
    
  
    
        ,"post158": {
            "title": "자료 구조",
            "content": "1. 자료 구조 . 자료를 기억장치의 공간 내에 저장하는 방법과 자료 간의 관계, 처리 방법 등을 연구 분석하는 것 | 저장 공간의 효율성과 실행시간의 단축을 위해 사용 | 자료 구조의 분류 선형 구조(Linear Structre) 배열 | 선형 리스트 연속 리스트 | 연결 리스트 | . | 스택 | 큐 | 데크 | . | 비선형 구조(Non-Linear Structure) 트리 | 그래프 | . | . | . 2. 배열 . 크기와 형이 동일한 자료들이 순서대로 나열된 자료의 집합 | 반복적인 데이터 처리 작업에 적합한 구조 | 정적인 자료구조로, 기억장소의 추가가 어려움 | 데이터 삭제 시 기억장소가 빈 공간으로 남아있어 메모리의 낭비가 발생 | . 3. 연속 리스트 . 배열과 같이 연속되는 기억장소에 저장되는 자료구조 | 중간에 데이터를 삽입하기 위해서는 연속된 빈 공간이 있어야 함 | 삽입.삭제 시 자료의 이동이 필요 | . 4. 연결 리스트 . 자료들을 임의의 기억공간에 기억시키되, 자료 항목의 순서에 따라 노드의 포인터 부분을 이용하여 서로 연결시킨 자료 구조 | 연결을 위한 링크(포인터) 부분이 필요해 기억 공간의 이용 효율이 좋지 않음 | 접근 속도가 느리고 연결이 끊어지면 다음 노드를 찾기 어려움 | . 5. 스택 . 리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어지는 자료 구조 | 후입선출(LIFO, Last In First Out) 방식으로 자료를 처리 | 저장할 기억 공간이 없는 상태에서 데이터가 삽입되면 오버플로가 발생 | 삭제할 데이터가 없는 상태에서 데이터를 삭제하면 언더플로 발생 | . . 6. 큐 . 리스트의 한쪽에서는 삽입 작업이 이루어지고 다른 한쪽에서는 삭제 작업이 이루어지는 자료 구조 | 선입선출(FIFO, First In First Out) 방식으로 자료를 처리 | 시작을 표시하는 프런트(Front) 포인터와 끝을 표시하는 리어(Rear) 포인터가 있음 | . . 7. 그래프 . 정점(Vertex)와 간선(Edge)의 두 집합으로 이루어지는 자료 구조 | 사이클이 없는 그래프를 트리라 함 | 간선의 방향성 유무에 따라 방향 그래프와 무방향 그래프로 구분됨 | . 8. 방향/무방향 그래프의 최대 간선 수 . 방향 그래프의 최대 간선 수: n(n-1) | 무방향 그래프에서의 최대 간선 수: n(n-1)/2 . | *n은 정점의 개수 . 정점이 4개인 경우 무방향 그래프와 방향 그래프의 최대 간선 수를 구하라 | | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/04/30/theory60.html",
            "relUrl": "/theory/2021/04/30/theory60.html",
            "date": " • Apr 30, 2021"
        }
        
    
  
    
        ,"post159": {
            "title": "물리 데이터 모델 품질 검토",
            "content": "1. 물리 데이터 모델 품질 검토 . 물리 데이터 모델을 설계하고 데이터베이스 객체를 생성한 후 개발 단계로 넘어가기 전에 모델러와 이해관계자들이 모여 수행함 | 목절: 데이터베이스의 성능 향상과 오류 예방 | 모든 이해관계자가 동의하는 검토 기준이 필요 | . 2. 물리 데이터 모델 품질 기준 . 정확성: 데이터 모델이 요구사항이나 업무 규칙, 표기법에 따라 정확하게 표현되었음 | 완전성: 데이터 모델이 데이터 모델의 구성 요소를 누락 없이 정의하고 요구사항이나 업무 영역을 누락 없이 반영하였음 | 준거성: 데이터 모델이 데이터 표준, 표준화 규칙, 법적 요건 등을 정확하게 준수하였음 | 최신성: 데이터 모델이 최근의 이슈나 현행 시스템을 반영하고 있음 | 일관성: 데이터 모델이 표현상의 일관성을 유지하고 있음 | 활용성: 작성된 모델과 설명을 사용자가 충분히 이해할 수 있고 업무 변화에 따른 데이터 구조의 변경이 최소화될 수 있도록 설계되었음 | . 3. 물리 데이터 모델 품질 검토 항목 . 물리 데이터 모델의 특성을 반영한 품질 기준을 작성한 후 이를 기반으로 작성 | 물리 데이터 모델에 정의된 테이블, 컬럼, 무결성 제약 조건 등 물리 데이터 모델의 주요 구성 요소와 반정규화, 인덱스, 스토리지 등 물리 데이터 모델의 전반적인 것을 검토 항목으로 작성 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/04/29/theory59.html",
            "relUrl": "/theory/2021/04/29/theory59.html",
            "date": " • Apr 29, 2021"
        }
        
    
  
    
        ,"post160": {
            "title": "논리 데이터 모델의 변환",
            "content": "1. 엔티티(Entity)를 테이블로 변환 . 논리 데이터 모델에서 정의된 엔티티를 물리 데이터 모델의 테이블로 변환하는 것 . | 변환 규칙 | 논리적 설계(데이터 모델링) 물리적 설계 . 엔티티 | 테이블 | . 속성 | 컬럼 | . 주 식별자 | 기본키 | . 외부 식별자 | 외래키 | . 관계 | 관계 | . | . 2. 슈퍼타입/서브타입을 테이블로 변환 . 슈퍼타입/서브타입은 논리 데이터 모델에서 이용되는 형태이므로 물리 데이터 모델을 설계할 대는 슈퍼타입/서브타입을 테이블로 변환해야 함 | 방법: 슈퍼타입 기준 테이블 변환, 서브타입 기준 테이블 변환, 개별타입 기준 테이블 변환 | . 3. 슈퍼타입 기준 테이블 변환 . 슈퍼타입 기준의 테이블 변환은 서브타입을 슈퍼타입에 통합하여 하나의 테이블로 만드는 것 | 서브타입에 속성이나 관계가 적을 경우에 적용하는 방법 | 하나로 통합된 테이블에는 서브타입의 모든 속성이 포함되어야 함 | | 서브타입의 개체에 있는 &#39;지점코드&#39;, &#39;담당부서&#39;와 개체에 있는 &#39;ID&#39;, &#39;수수료납부방법&#39;이 슈퍼타입인 개체에 통합되어 테이블로 변환됨 | . 4. 서브타입 기준 테이블 변환 . 서브타입 기준의 테이블 변환은 슈퍼타입 속성들을 각각의 서브타입에 추가하여 서브타입들을 개별적인 테이블로 만드는 것 | 서브타입에 속성이나 관계가 많이 포함된 경우 적용 . | | 슈퍼타입인 개체에 있는 &#39;신청자이름&#39;, &#39;접수일&#39;, &#39;수수료&#39;가 서브타입인 개체와 개체에 각각 추가되어 와 테이블로 변환됨 | . 5. 개별타입 기준 테이블 변환 . 슈퍼타입과 서브타입들을 각각의 개별적인 테이블로 변환하는 것 | 슈퍼타입과 서브타입 테이블들 사이에는 각각 1:1 관계가 형성됨 | | 슈퍼타입의 개체와 서브타입의 , 개체가 각각 , , 테이블로 변환됨 | . 6. 속성을 컬럼으로 변환 . 논리 데이터 모델에서 정의한 속성을 물리 데이터 모델의 컬럼으로 변환함 | 일반 속성 변환 속성과 컬럼은 명칭이 반드시 일치할 필요는 없으나, 개발자와 사용자 간 의사소통을 위하여 가능한 한 표준화된 약어를 사용하여 일치시키는 것이 좋음 | . | Primary UID를 기본키로 변환 논리 데이터 모델에서의 Primary UID는 물리 데이터 모델의 기본키로 만듦 | . | Primary UID(관계의 UID Bar)를 기본키로 변환 다른 엔티티와의 관계로 인해 생성된 Primary UID는 물리 데이터 모델의 기본키로 만듦 | . | Secondary(Alternate) UID를 유니크키로 변환 논리 모델링에서 정의된 Secondary UID 및 Alternate Key는 물리 모델에서 유니크키로 만듦 | . | | 엔티티의 &#39;부서번호&#39;, &#39;이름&#39;, &#39;주소&#39;, &#39;전화번호&#39;, &#39;이메일&#39; 속성이 테이블의 각각의 컬럼으로 변환되었으며, 예시를 위한 데이터가 들어있음 | . 7. 관계를 외래키로 변환 . 논리 데이터 모델에서 정의된 관계는 기본키와 이를 참조하는 외래키로 변환함 .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/04/28/theory58.html",
            "relUrl": "/theory/2021/04/28/theory58.html",
            "date": " • Apr 28, 2021"
        }
        
    
  
    
        ,"post161": {
            "title": "스토리지",
            "content": "1. 스토리지(Storage) . 단일 디스크로 처리할 수 없는 대용량의 데이터를 저장하기 위해 서버와 저장장치를 연결하는 기술 | 종류에는 DAS, NAS, SAN이 있음 | . 2. DAS(Direct Attached Storage) . 서버와 저장장치를 전용 케이블로 직접 연결하는 방식 | 일반 가정에서 컴퓨터에 외장하드를 연결하는 것 | 저장장치를 직접 연결하므로 속도가 빠르고 설치 및 운영이 쉬움 | 초기 구축 비용 및 유지보수 비용이 저렴함 | 직접 연결 방식이므로 다른 서버에 접근할 수 없고 파일을 공유할 수 없음 | 확장성 및 유연성이 떨어짐 | . 3. NAS(Network Attached Storage) . 서버와 저장장치를 네트워크를 통해 연결하는 방식 | 별도의 파일 관리 기능이 있는 NAS Storage가 내장된 저장장치를 직접 관리함 | Ethernet 스위치를 통해 다른 서버에서도 스토리지에 접근할 수 있어 파일 공유가 가능함 | 장소에 구애받지 않고 저장장치에 쉽게 접근할 수 있음 | DAS에 비해 확장성 및 유연성이 우수함 | . 4. SAN(Storage Area Network) . SAN은 DAS의 빠른 처리와 NAS의 파일 공유 장점을 혼합한 방식으로, 서버와 저장장치를 연결하는 전용 네트워크를 별도로 구성하는 방식임 . | 파이버 채널(FC) 스위치를 이용하여 네트워크를 구성함 . | 파이버 채널 스위치는 서버와 저장장치를 광케이블로 연결하므로 처리 속도가 빠름 . | 서버들이 저장장치 및 파일을 공유할 수 있음 . | 확장성, 유연성, 가용성이 뛰어남 . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/04/27/theory57.html",
            "relUrl": "/theory/2021/04/27/theory57.html",
            "date": " • Apr 27, 2021"
        }
        
    
  
    
        ,"post162": {
            "title": "데이터베이스 백업",
            "content": "1. 데이터베이스 백업 . 전산 장비의 장애에 대비하여 데이터베이스에 저장된 데이터를 보호하고 복구하기 위한 작업 | 치명적인 데이터 손실을 막기 위해서는 데이터베이스를 정기적으로 백업해야 함 | . 2. 로그 파일 . 데이터베이스의 처리 내용이나 이용 상황 등 상태 변화를 시간의 흐름에 따라 모두 기록한 파일 | 데이터베이스의 복구를 위해 필요한 가장 기본적인 자료임 | 로그 파일을 기반으로 데이터베이스를 과거 상태로 복구(UNDO)시키거나 현재 상태로 재생(REDO)시켜 데이터베이스 상태를 일관성 있게 유지할 수 있음 | 로그 파일은 트랜잭션 시작 시점, Rollback 시점, 데이터 입력, 수정 삭제 시점 등에서 기록됨 | . 3. 데이터베이스 복구 알고리즘 . NO-UNDO/REDO 데이터베이스 버퍼의 내용을 비동기적으로 갱신한 경우의 복구 알고리즘 | NO-UNDO: 트랜잭션 완료 전에는 변경 내용이 데이터베이스에 기록되지 않으므로 취소할 필요가 없음 | REDO: 트랜잭션 완료 후 데이터베이스 버퍼에는 기록되어 있고, 저장매체에는 기록되지 않았으므로 트랜잭션 내용을 다시 실행해야 함 | . | UNDO/NO-REDO 데이터베이스 버퍼의 내용을 동기적으로 갱신한 경우의 복구 알고리즘 | UNDO: 트랜잭션 완료 전에 시스템이 파손되었다면 변경된 내용을 취소함 | NO-REDO: 트랜잭션 완료 전에 데이터베이스 버퍼 내용을 이미 저장 매체에 기록했으므로 트랜잭션 내용을 다시 실행할 필요가 없음 | . | UNDO/REDO 데이터베이스 버퍼의 내용을 동기/비동기적으로 갱신한 경우의 복구 알고리즘 | 데이터베이스 기록 전에 트랜잭션이 완료될 수 있으므로 완료된 트랜잭션이 데이터베이스에 기록되지 못했다면 다시 실행해야 함 | . | NO-UNDO/NO-REDO 데이터베이스 버퍼의 내용을 동기적으로 저장 매체에 기록하지만 데이터베이스와는 다른 영역에 기록한 경우의 복구 알고리즘 | NO-UNDO: 변경 내용은 데이터베이스와 다른 영역에 기록되어 있으므로 취소할 필요가 없음 | NO-REDO: 다른 영역에 이미 기록되어 있으므로 트랜잭션을 다시 실행할 필요가 없음 | . | . 4. 백업 종류 . 복구 수준에 따라서 운영체제를 이용하는 물리 백업과 DBMS 유틸리티를 이용하는 논리 백업으로 나뉨 | 물리 백업 데이터베이스 파일을 백업하는 방법 | 백업 속도가 빠르고 작업이 단순하지만 문제 발생 시 원인 파악 및 문제 해결이 어려움 | . | 논리 백업 DB 내의 논리적 객체들을 백업하는 방법 | 복원 시 데이터 손상을 막고 문제 발생 시 원인 파악 및 해결이 수월하지만 백업/복원 시 시간이 많이 소요됨 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/04/26/theory56.html",
            "relUrl": "/theory/2021/04/26/theory56.html",
            "date": " • Apr 26, 2021"
        }
        
    
  
    
        ,"post163": {
            "title": "데이터베이스 보안",
            "content": "1. 데이터베이스 보안 . 데이터베이스의 일부 또는 전체에 대해서 권한이 없는 사용자가 액세스하는 것을 금지하기 위해 사용되는 기술 | 보안을 위한 데이터 단위는 테이블 전체로부터 특정 테이블의 특정 행과 열에 있는 데이터 값에 이르기까지 다양함 | . 2. 암호화(Encryption) . 데이터를 보낼 때 송신자가 지정한 수신자 이외에는 그 내용을 알 수 없도록 평문을 암호문으로 변환하는 것임 | 암호화(Encryption) 과정: 암호화되지 않은 평문을 암호문으로 바꾸는 과정 | 복호화(Decryption) 과정: 암호문을 원래의 평문으로 바꾸는 과정 | 암호화 기법 개인키 암호 방식(Private Key Encryption) | 공개키 암호 방식(Public Key Encryption) | . | . 3. 접근통제 . 데이터가 저장된 객체와 이를 사용하려는 주체 사이의 정보 흐름을 제한하는 것 | 접근통제 3요소 접근통제 정책 | 접근통제 매커니즘 | 접근통제 보안모델 | . | 접근통제 기술 임의 접근통제(DAC, Discretionary Access Control) 데이터에 접근하는 사용자의 신원에 따라 접근 권한 부여하는 방식 | 데이터 소유자가 접근통제 권한을 지정하고 제어함 | 객체를 생성한 사용자가 생성된 객체에 대한 모든 권한을 부여받고, 부여된 권한을 다른 사용자에게 허가할 수도 있음 | . | 강제 접근통제(MAC, Mandatory Access Control) 주체와 객체의 등급을 비교하여 접근 권한을 부여하는 방식 | 시스템이 접근통제 권한을 지정함 | 데이터베이스 객체별로 보안 등급을 부여할 수 있음 | 사용자별로 인가 등급을 부여할 수 있음 | . | 역할기반 접근통제(RBAC, Role Based Access Control) 사용자의 역할에 따라 접근 권한을 부여하는 방식 | 중앙관리자가 접근통제 권한 지정 | 임의 접근통제와 강제 접근통제의 단점을 보완 | 다중 프로그래밍 환경에 최적화된 방식 | . | . | . 4. 접근통제 정책 . 어떤 주체(who)가 언제(when), 어디서(where), 어떤 객체(what)에게, 어떤 행위(how)에 대한 허용 여부를 정의하는 것임 | 접근통제 정책의 종류 신분 기반 정책 주체나 그룹의 신분에 근거하여 객체의 접근을 제한하는 방법으로, IBP와 GBP가 있음 | IBP(Individual-Based Policy): 최소 권한 정책으로, 단일 주체에게 하나의 객체에 대한 허가 부여 | GBP(Group-Based Policy): 복수 주체에 하나의 객체에 대한 허가를 부여함 | . | 규칙 기반 정책 주체가 갖는 권한에 근거하여 객체의 접근을 제한하는 방법으로, MLP와 CBP가 있음 | MLP(Multi-Level Policy): 사용자나 객체별로 지정된 기밀 분류에 따른 정책 | CBP(Compartment-Based Policy): 집단별로 지정된 기밀 허가에 따른 정책 | . | 역할 기반 정책 GBP의 변형된 정책으로, 주체의 신분이 아니라 주체가 맡은 역할에 근거하여 객체의 접근을 제한하는 방법 | . | . | . 5. 접근통제 매커니즘 . 정의된 접근통제 정책을 구현하는 기술적인 방법 | 접근통제 목록, 능력 리스트, 보안 등급, 패스워드, 암호화 등이 있음 | . 6. 접근통제 보안 모델 . 보안 정책을 구현하기 위한 정형화된 모델임 | 종류 기밀성 모델 군사적인 목적으로 개발된 최초의 수학적 모델 | 기밀성 보장이 최우선임 | 군대 시스템 등 특수 환경에서 주로 사용됨 | . | 무결성 모델 기밀성 모델에서 발생하는 불법적인 정보 변경을 방지하기 위해 무결성을 기반으로 개발된 모델 | . | 접근통제 모델 접근통제 매커니즘을 보안 모델로 발전시킨 것 | 대표적으로 접근통제 행렬이 있음 | 접근통제 행렬: 임의적인 접근통제를 관리하기 위한 보안 모델로, 행은 주체, 열은 객체 즉, 행과 열로 주체와 객체의 권한 유형을 나타냄 | . | . | . 7. 접근통제 조건 . 접근통제 매커니즘의 취약점을 보완하기 위해 접근통제 정책에 부가하여 적용할 수 있는 조건임 | 값 종속 통제(Value-Dependent Control): 일반적으로는 객체에 저장된 값에 상관없이 접근통제를 동일하게 허용하지만, 값 종속 통제는 객체에 저장된 값에 따라 다르게 접근통제를 허용해야 하는 경우에 사용함 | 다중 사용자 통제(Multi-User Control): 지정된 객체에 다수의 사용자가 동시에 접근을 요구하는 경우에사용됨 | 컨텍스트 기반 통제(Context-Based Control): 특정 시간, 네트워크 주소, 접근 경로, 인증 수준 등에 근거하여 접근을 제어하는 방법. 다른 보안 정책과 결합하여 보안 시스템의 취약점을 보완할 때 사용함 | . 8. 감사 추적 . 사용자나 애플리케이션이 데이터베이스에 접근하여 수행한 모든 활동을 기록하는 기능임 | 오류가 발생한 데이터베이스를 복구하거나 부적절한 데이터 조작을 파악하기 위해 사용됨 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/04/25/theory55.html",
            "relUrl": "/theory/2021/04/25/theory55.html",
            "date": " • Apr 25, 2021"
        }
        
    
  
    
        ,"post164": {
            "title": "데이터베이스 이중화/서버 클러스터링",
            "content": "1. 데이터베이스 이중화(Database Replication) . 시스템 오류로 인한 데이터베이스 서비스 중단이나 물리적 손상 발생 시 이를 복구하기 위해 동일한 데이터베이스를 복제하여 관리하는 것 | 하나 이상의 데이터베이스가 항상 같은 상태를 유지하므로 데이터베이스에 문제가 발생하면 복제된 데이터베이스를 이용하여 즉시 문제 해결 가능 | 여러 개의 데이터베이스를 동시에 관리하므로 사용자가 수행하는 작업은 데이터베이스 이중화 시스템에 연결된 다른 데이터베이스에도 동일하게 적용함 | 애플리케이션을 여러 개의 데이터베이스에서 분산 처리하므로 데이터베이스의 부하를 줄일 수 있음 | 데이터베이스 이중화를 이용하면 손쉽게 백업 서버를 운영할 수 있음 | . 2. 데이터베이스 이중화의 분류 . Eager 기법 트랜잭션 수행 중 데이터 변경이 발생하면 이중화된 모든 데이터베이스에 즉시 전달하여 변경 내용이 즉시 적용되도록 하는 기법 | . | Lazy 기법 트랜잭션의 수행이 종료되면 변경 사실을 새로운 트랜잭션에 작성하여 각 데이터베이스에 전달되는 기법 | 데이터베이스마다 새로운 트랜잭션이 수행되는 것으로 간주됨 | . | . 3. 데이터베이스 이중화 구성 방법 . 활동-대기 방법 한 DB가 활성 상태로 서비스하고 있으면 다른 DB는 대기하고 있다가 활성 DB에 장애가 발생하면 대기 상태에 있던 DB가 자동으로 모든 서비스를 대신 수행 | 구성 방법과 관리가 쉬워 많은 기업에서 이용됨 | . | 활동-활동 방법 두 개의 DB가 서로 다른 서비스를 제공하다가 둘 중 한쪽 DB에 문제가 발생하면 나머지 다른 DB가 서비스를 제공 | 두 DB가 모두 처리를 하기 때문에 처리율이 높지만 구성 방법 및 설정이 복잡함 | . | . 4. 클러스터링(Clustering) . 두 대 이상의 서버를 하나의 서버처럼 운영하는 기술 | 서버 이중화 및 공유 스토리지를 사용하여 서버의 고가용성을 제공 | 종류 고가용성 클러스터링 하나의 서버에 장애가 발생하면 다른 노드(서버)가 받아 처리하여 서비스 중단을 방지하는 방식 | 일반적으로 언급되는 클러스터링 | . | 병렬 처리 클러스터링 전체 처리율을 높이기 위해 하나의 작업을 여러 개의 서버에서 분산하여 처리하는 방식 | . | . | . 5. RTO/RPO . RTO(Recovery Time Objective, 목표 복구 시간) 비상사태 또는 업무 중단 시점으로부터 복구되어 가동될 때까지의 소요 시간을 의미 | 장애 발생 후 6시간 내 복구 가능 | . | RPO(Recovery Point Objective, 목표 복구 시점) 비상사태 또는 업무 중단 시점으로부터 데이터를 복구할 수 있는 기준점을 읨 | 장애 발생 전인 지난 주 금요일에 백업시켜 둔 복원 시점으로 복구 가능 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/04/24/theory54.html",
            "relUrl": "/theory/2021/04/24/theory54.html",
            "date": " • Apr 24, 2021"
        }
        
    
  
    
        ,"post165": {
            "title": "분산 데이터베이스 설계",
            "content": "1. 데이터베이스 용량 설계 . 데이터가 저장될 공간을 정의하는 것 | 데이터베이스 용량을 설계할 때는 테이블에 저장될 데이터양과 인덱스, 클러스터 등이 차지하는 공간 등을 예측하여 반영해야 함 | 목적 용량을 정확히 산정하여 디스크의 저장 공간을 효과적으로 사용하고 확장성 및 가용성을 높임 | 디스크의 특성을 고려하여 설계함으로써 디스크의 입.출력 부하를 분산시키고 채널의 병목 현상을 최소화 | . | . 2. 분산 데이터베이스 설계 . 논리적으로는 하나의 시스템에 속하지만 물리적으로는 네트워크를 통해 연결된 여러 개의 사이트에 분산된 데이터베이스를 말함 | 분산 데이터베이스는 데이터의 처리나 이용이 많은 지역에 데이터베이스를 위치시킴으로써 데이터의 처리가 가능한 해당 지역에서 해결될 수 있도록 함 | 분산 데이터베이스 설계는 애플리케이션이나 사용자가 분산되어 저장된 데이터에 접근하게 하는 것을 목적으로 함 | . 3. 분산 데이터베이스의 목표 . 위치 투명성(Location Transparency) 액세스하려는 데이터베이스의 실제 위치를 알 필요 없이 단지 데이터베이스의 논리적인 명칭만으로 액세스할 수 있음 | . | 중복 투명성(Replication Transparency) 동일 데이터가 여러 곳에 중복되어 있더라도 사용자는 마치 하나의 데이터만 존재하는 것처럼 사용하고, 시스템은 자동으로 여러 자료에 대한 작업을 수행함 | . | 병행 투명성(Concurrency Transparency) 분산 데이터베이스와 관련된 다수의 트랜잭션들이 동시에 실현되더라도 그 트랜잭션의 결과는 영향을 받지 않음 | . | 장애 투명성(Failure Transparency) 트랜잭션, DBMS, 네트워크, 컴퓨터 장애에도 불구하고 트랜잭션을 정확하게 처리함 | . | . 4. 분산 설계 방법 . 테이블 위치 분산 데이터베이스의 테이블을 각기 다른 서버에 분산시켜 배치 | . | 분할(Fragmentation) 테이블의 데이터를 분할하여 분산시키는 것 | 분할 규칙: 완전성, 재구성, 상호 중첩 배제 | 주요 분할 방법 수평 분할: 특정 속성의 값을 기준으로 행 단위로 분할 | 수직 분할: 데이터 칼럼(속성) 단위로 분할 | . | . | 할당(Allocation) 동일한 분할을 여러 개의 서버에 생성하는 분산 방법 | 중복이 없는 할당과 중복이 있는 할당으로 나뉨 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/04/23/theory53.html",
            "relUrl": "/theory/2021/04/23/theory53.html",
            "date": " • Apr 23, 2021"
        }
        
    
  
    
        ,"post166": {
            "title": "파티션",
            "content": "1. 파티션 . 대용량의 테이블이나 인덱스를 작은 논리적 단위인 파티션으로 나누는 것을 말함 | 대용량 DB의 경우 몇 개의 중요한 테이블에만 집중되어 데이터가 증가되므로, 이런 테이블들을 작은 단위로 나눠 분산시키면 성능 저하를 방지할 뿐만 아니라 데이터 관리도 쉬워짐 | 데이터 처리는 테이블 단위로 이뤄지고, 데이터 저장은 파티션별로 수행됨 | . 2. 파티션의 장.단점 . 장점 데이터 접근 시 액세스 범위를 줄여 쿼리 성능이 향상됨 | 파티션별로 데이터가 분산되어 저장되므로 디스크의 성능이 향상됨 | 파티션별로 백업 및 복구를 수행하므로 속도가 빠름 | 시스템 장애 시 데이터 손상 정도를 최소화할 수 있음 | 데이터 가용성이 향상됨 | 파티션 단위로 입.출력을 분산시킬 수 있음 | . | 단점 하나의 테이블을 세분화하여 관리하므로 세심한 관리가 요구됨 | 테이블간 조인에 대한 비용이 증가함 | 용량이 작은 테이블에 파티셔닝을 수행하면 오히려 성능이 저하됨 | . | . 3. 파티션의 종류 . 범위 분할(Range Partitioning) 지정한 열의 값을 기준으로 분할 (일별, 월별, 분기별 등) | . | 해시 분할(Hash Partitioning) 해시 함수를 적용한 결과 값에 따라 데이터를 분할함 | 특정 파티션에 데이터가 집중되는 범위 분할의 단점을 보완한 것으로, 데이터를 고르게 분산할 때 유용함 | 특정 데이터가 어디에 있는지 판단할 수 없음 | 고객번호, 주민번호 등과 같이 데이터가 고른 컬럼에 효과적임 | . | 조합 분할(Composite Partitioning) 범위 분할로 분할한 다음 해시 함수를 적용하여 다시 분할하는 방식 | 범위 분할한 파티션이 너무 커서 관리가 어려울 때 유용함 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/04/22/theory52.html",
            "relUrl": "/theory/2021/04/22/theory52.html",
            "date": " • Apr 22, 2021"
        }
        
    
  
    
        ,"post167": {
            "title": "뷰/클러스터",
            "content": "1. 뷰(View) . 사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된, 이름을 가지는 가상 테이블 | 저장장치 내에 물리적으로 존재하지 않지만, 사용자에게는 있는 것처럼 간주됨 | 뷰를 통해서만 데이터에 접근하게 하면 뷰에 나타나지 않는 데이터를 안전하게 보호하는 효율적인 기법으로 사용할 수 있음 | 뷰가 정의된 기본 테이블이나 뷰를 삭제하면 그 테이블이나 뷰를 기초로 정의된 다른 뷰도 자동으로 삭제됨 | 뷰를 정의할 때는 CREATE 문, 제거할 때는 DROP 문을 사용함 | . 2. 뷰의 장.단점 . 장점 논리적 데이터 독립성을 제공함 | 동일 데이터에 대해 동시에 여러 사용자의 상이한 응용이나 요구를 지원 | 사용자의 데이터 관리를 간단하게 해줌 | 접근 제어를 통한 자동 보안이 제공됨 | . | 단점 독립적인 인덱스를 가질 수 없음 | 뷰의 정의를 변경할 수 없음 | 뷰로 구성된 내용에 대한 삽입, 삭제, 갱신 연산에 제약이 따름 | . | . 3. 클러스터 . 데이터 저장 시 데이터 액세스 효율을 향상시키기 위해 동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 저장 방법임 | 클러스터링 된 테이블은 데이터 조회 속도를 향상시키지만 입력, 수정, 삭제에 대한 작업 성능을 저하시킴 | 클러스터는 데이터의 분포도가 넓을수록 유리함 | 데이터 분포도가 넓은 테이블을 클러스터링 하면 저장 공간을 절약할 수 있음 | 처리 범위가 넓은 경우에는 단일 테이블 클러스터링을, 조인이 많이 발생하는 경우에는 다중 테이블 클러스터링을 사용함 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/04/21/theory51.html",
            "relUrl": "/theory/2021/04/21/theory51.html",
            "date": " • Apr 21, 2021"
        }
        
    
  
    
        ,"post168": {
            "title": "인덱스",
            "content": "1. 인덱스 . 데이터 레코드를 빠르게 접근하기 위해 &lt;키 값, 포인터&gt; 쌍으로 구성되는 데이터 구조 | 인덱스는 레코드가 저장된 물리적 구조에 접근하는 방법을 제공함 | 인덱스를 통해서 파일의 레코드에 빠르게 액세스 할 수 있음 | 레코드의 삽입과 삭제가 수시로 일어나는 경우에는 인덱스의 개수를 최소로 하는 것이 효율적임 | . 2. 인덱스의 종류 . 트리 기반 인덱스 인덱스를 저장하는 블록들이 트리 구조를 이루고 있는 것 | . | 비트맵 인덱스 인덱스 컬럼의 데이터를 Bit 값인 0 또는 1로 변환하여 인덱스 키로 사용하는 방법 | . | 함수 기반 인덱스 컬럼의 값 대신 컬럼에 특정 함수나 수식을 적용하여 산출된 값을 사용하는 것 | . | 비트맵 조인 인덱스 다수의 조인된 객체로 구성된 인덱스 | . | 도메인 인덱스 개발자가 필요한 인덱스를 직접 만들어 사용하는 것 | . | . 3. 클러스터드/넌클러스터드 인덱스 . 클러스터드 인덱스(Clustered Index) . 인덱스 키의 순서에 따라 데이터가 정렬되어 저장되는 방식 | 실제 데이터가 순서대로 저장되어 있어 인덱스를 검색하지 않아도 원하는 데이터를 빠르게 찾을 수 있음 | . | 넌클러스터드 인덱스(Non-Clustered Index) . 인덱스의 키 값만 정렬되어 있고 실제 데이터는 정렬되지 않는 방식 | 데이터 삽입, 삭제 발생 시 순서를 유지하기 위해 데이터를 재정렬해야 함 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/04/20/theory50.html",
            "relUrl": "/theory/2021/04/20/theory50.html",
            "date": " • Apr 20, 2021"
        }
        
    
  
    
        ,"post169": {
            "title": "트랜잭션 분석/CRUD 분석",
            "content": "1. 트랜잭션 . 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미함 | 데이터베이스 시스템에서 병행 제어 및 회복 작업 시 처리되는 작업의 논리적 단위로 사용됨 | 사용자가 시스템에 대한 서비스 요구 시 시스템이 응답하기 위한 상태 변환 과정의 작업 단위로 사용됨 | . 2. 트랜잭션의 특징 ACID . 원자성(Atomicity) 트랜잭션의 연산은 데이터베이스에 모두 반영되도록 완료(commit)되든지 아니면 전혀 반영되지 않도록 복구(rollback)되어야 함 | . | 일관성(Consistency) 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환함 | . | 독립성.격리성.순차성(Isolation) 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행 중에 다른 트랜잭션의 연산이 끼어들 수 없음 | . | 영속성.지속성(Durability) 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 함 | . | . 3. CRUD 분석 . 프로세스와 테이블 간에 CRUD 매트릭스를 만들어서 트랜잭션을 분석하는 것임 . | CRUD 분석을 통해 많은 트랜잭션이 몰리는 테이블을 파악할 수 있으므로 디스크 구성 시 유용한 자료로 활용 가능 . | CRUD 매트릭스 . 2차원 형태의 표로서, 행에는 프로세스를, 열에는 테이블을, 행과 열이 만나는 위치에는 프로세스가 테이블에 발생시키는 변화를 표시하여 프로세스와 데이터 간의 관계를 분석하는 분석표 . | CRUD 매트릭스를 통해 트랜잭션이 테이블에 수행하는 작업을 검증 . | CRUD 매트릭스의 각 셀에는 Create, Read, Update, Delete의 앞 글자가 들어가며, 복수의 변화를 줄 때는 기본적으로 ‘C&gt;D&gt;U&gt;R’의 우선순위를 적용하여 한 가지만 적지만 활용 목적에 따라 모두 기록 가능 . ‘주문 변경’ 프로세스를 실행하려면 테이블의 데이터를 읽은(Read) 다음 수정(Update)해야 하므로 R(Read)과 U(Update)가 필요하지만 CRUD 매트릭스에는 우선순위가 높은 U만 표시 | . | CRUD 매트릭스가 완성되었다면 C, R, U, D 중 어느 것도 적히지 않은 행이나 열, C나 R이 없는 열을 확인하여 불필요하거나 누락된 테이블 또는 프로세스를 찾음 . 온라인 쇼핑몰의 CRUD 매트릭스 예시 . | 프로세스 테이블 회원 상품 주문 주문목록 제조사 . 신규 회원 등록 | C |   |   |   |   | . 회원정보 변경 | R, U |   |   |   |   | . 주문 요청 | R | R | C | C |   | . 주문 변경 |   |   | R | R, U |   | . 주문 취소 |   |   | R, D | R, D |   | . 상품 등록 |   | C |   |   | C, R | . 상품정보 변경 |   | R, U |   |   | R, U | . | . | . | . 4. 트랜잭션 분석 . CRUD 매트릭스를 기반으로 테이블에 발생하는 트랜잭션 양을 분석하여 테이블에 저장되는 데이터의 양을 유추하고 이를 근거로 DB의 용량 산정 및 구조의 최적화를 목적으로 함 . | 트랜잭션 분석은 업무 개발 담당자가 수행함 . | 트랜잭션 분석을 통해 프로세스가 과도하게 접근하는 테이블을 확인할 수 있으며, 이러한 집중 접근 테이블을 여러 디스크에 분산 배치함으로써 디스크 입.출력 향상을 통한 성능 향상을 가져올 수 있음 . | 트랜잭션 분석서 . 단위 프로세스와 CRUD 매트릭스를 이용하여 작성함 . | 구성 요소: 단위 프로세스, CRUD 연산, 테이블명, 컬럼명, 테이블 참조 횟수, 트랜잭션 수, 발생 주기 등 . | ‘주문 요청’ 프로세스에 대한 트랜잭션 분석서 예시 . | 프로세스 crud 테이블명 컬럼명 참조 횟수 트랜잭션 수 주기 . 주문 요청 | R | 회원 | 회원번호, 회원명, 주소 | 1 | 150 | 일 | .   | R | 상품 | 상품번호, 상품명, 재고량 | 1 | 150 |   | .   | C | 주문 | 주문번호, 일자, 회원번호 | 3 | 450 |   | .   | C | 주문목록 | 주문번호, 상품번호, 수량, 가격 | 5 | 750 |   | .   |   |   |   |   |   |   | . | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/04/19/theory49.html",
            "relUrl": "/theory/2021/04/19/theory49.html",
            "date": " • Apr 19, 2021"
        }
        
    
  
    
        ,"post170": {
            "title": "데이터베이스 저장 공간 설계",
            "content": "1. 데이터베이스 저장 공간 설계 . 데이터베이스에 데이터를 저장하려면 테이블이나 컬럼 등 실제 데이터가 저장되는 공간을 정의해야 함 . 객체 내용 . 테이블 | - 데이터베이스의 가장 기본적인 객체- 로우(행)와 컬럼(열)으로 구성- 데이터베이스의 모든 데이터는 테이블에 저장 | . 컬럼 | - 테이블의 열을 구성하는 요소- 데이터 타입, 길이 등으로 정의 | . 테이블스페이스 | - 테이블이 저장되는 논리적인 영역-한 개의 테이블스페이스에 한 개 이상의 테이블을 저장할 수 있음 | . 2. 테이블 종류 . 종류 내용 . 일반 테이블 | 대부분의 DBMS에서 표준 테이블로 사용되는 테이블의 형태 | . 클러스터드 인덱스 테이블 | - 기본키나 인덱스키의 순서에 따라 데이터가 저장되는 테이블- 일반적인 인덱스를 사용하는 테이블에 비해 접근 경로가 단축됨 | . 파티셔닝 테이블 | 대용량의 테이블을 작은 논리적 단위인 파티션으로 나눈 테이블 | . 외부 테이블 | - 데이터베이스에서 일반 테이블처럼 이용할 수 있는 외부 파일- 데이터베이스 내에 객체로 존재함 | . 임시 테이블 | - 트랜잭션이나 세션별로 데이터를 저장하고 처리할 수 있는 테이블- 임시 테이블에 저장된 데이터는 트랜잭션이 종료되면 삭제됨 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/04/18/theory48.html",
            "relUrl": "/theory/2021/04/18/theory48.html",
            "date": " • Apr 18, 2021"
        }
        
    
  
    
        ,"post171": {
            "title": "시스템 카탈로그",
            "content": "1. 시스템 카탈로그 . 시스템 그 자체에 관련이 있는 다양한 객체에 관한 정보를 포함하는 시스템 데이터베이스임 | 시스템 카탈로그 내의 각 테이블은 사용자를 포함하여 DBMS에서 지원하는 모든 데이터 객체에 대한 정의나 명세에 관한 정보를 유지 관리하는 시스템 테이블임 | 카탈로그들이 생성되면 데이터 사전에 저장되기 때문에 좁은 의미로는 카탈로그를 데이터 사전이라고도 함 | . 2. 메타 데이터 . 시스템 카탈로그에 저장된 정보를 의미 | 유형 데이터베이스 객체 정보: 테이블, 인덱스, 뷰 등의 구조 및 통계 정보 | 사용자 정보: 아이디, 패스워드, 접근 권한 등 | 테이블의 무결성 제약 조건 정보: 기본키, 외래키, NULL 값 허용 여부 등 | 함수, 프로시저, 트리거 등에 대한 정보 | . | . 3. 데이터 디렉터리 . 데이터 사전에 수록된 데이터에 접근하는 데 필요한 정보를 관리 유지하는 시스템 | 시스템 카탈로그는 사용자와 시스템 모두 접근할 수 있지만 데이터 디렉터리는 시스템만 접근할 수 있음 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/04/17/theory47.html",
            "relUrl": "/theory/2021/04/17/theory47.html",
            "date": " • Apr 17, 2021"
        }
        
    
  
    
        ,"post172": {
            "title": "반정규화",
            "content": "1. 반정규화 . 시스템의 성능을 향상하고 개발 및 운영의 편의성 등을 높이기 위해 정규화된 데이터 모델을 의도적으로 통합, 중복, 분리하여 정규화 원칙을 위배하는 행위임 | 반정규화를 수행하면 시스템의 성능이 향상되고 관리 효율성은 증가하지만 데이터의 일관성 및 정합성이 저하될 수 있음 | 과도한 반정규화는 오히려 성능을 저하시킬 수 있음 | 방법 테이블 통합 | 테이블 분할 | 중복 테이블 추가 | 중복 속성 추가 | . | . 2. 테이블 통합 . 두 개의 테이블이 조인되어 사용되는 경우가 많을 경우 성능 향상을 위해 아예 하나의 테이블로 만들어 사용하는 것 | 테이블 통합을 고려하는 경우 두 개의 테이블에서 발생하는 프로세스가 동일하게 자주 처리되는 경우 | 항상 두 개의 테이블을 이용하여 조회를 수행하는 경우 | . | 테이블 통합의 종류 1:1 관계 테이블 통합 | 1:N 관계 테이블 통합 | 슈퍼타입/서브타입 테이블 통합 | . | . 3. 테이블 분할 . 테이블을 수직 또는 수평으로 분할하는 것 . 수평 분할 레코드를 기준으로 테이블을 분할하는 것 | 레코들별로 사용 빈도의 차이가 큰 경우 사용 빈도에 따라 테이블을 분할 | . | 수직 분할 하나의 테이블에 속성이 너무 많을 경우 속성을 기준으로 테이블을 분할하는 것 | 종류: 갱신 위주의 속성 분할, 자주 조회되는 속성 분할, 크기가 큰 속성 분할, 보안을 적용해야 하는 속성 분할 | . | . 4. 중복 테이블 추가 . 작업의 효율성을 향상시키기 위해 테이블을 추가하는 것 | 중복 테이블을 추가하는 경우 여러 테이블에서 데이터를 추출해서 사용해야 할 경우 | 다른 서버에 저장된 테이블을 이용해야 하는 경우 | . | 방법 집게 테이블의 추가 집계 데이터를 위한 테이블을 생성하고, 각 원본 테이블에 트리거를 설정하여 사용하는 것 | . | 진행 테이블의 추가 이력 관리 등의 목적으로 추가하는 테이블 | . | 특정 부분만을 포함하는 테이블의 추가 데이터가 많은 테이블의 특정 부분만을 사용하는 경우 해당 부분만으로 새로운 테이블을 생성 | . | . | . 5. 중복 속성 추가 . 조인해서 데이터를 처리할 때 데이터를 조회하는 경로를 단축하기 위해 자주 사용하는 속성을 하나 더 추가하는 것임 . | 데이터의 무결성 확보가 어렵고, 디스크 공간이 추가로 필요함 . | 중복 속성을 추가하는 경우 . 조인이 자주 발생하는 속성인 경우 | 접근 경로가 복잡한 속성인 경우 | 액세스의 조건으로 자주 사용되는 속성인 경우 | 기본키의 형태가 적절하지 않거나 여러 개의 속성으로 구성된 경우 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/04/16/theory46.html",
            "relUrl": "/theory/2021/04/16/theory46.html",
            "date": " • Apr 16, 2021"
        }
        
    
  
    
        ,"post173": {
            "title": "정규화",
            "content": "1. 정규화(Normalization) . 테이블의 속성들이 상호 종속적인 관계를 갖는 특성을 이용하여 테이블을 무손실 분해하는 과정 | 목적은 가능한 한 중복을 제거하여 삽입, 삭제, 갱신 이상의 발생 가능성을 줄이는 것 | 제 1정규형(1NF), 제 2정규형(2NF), 제 3정규형(3NF), BCNF, 제 4정규형(4NF), 제 5정규형(5NF)이 있으며, 순서대로 정규화의 정도가 높아짐 | . 2. 정규화 과정 . 아래의 테이블을 가지고 정규화 과정을 살펴보자. 테이블의 기본키는 제품번호임 . . 제 1정규형 . 테이블 R에 속한 모든 속성의 도메인이 원자 값만으로 되어 있는 정규형임. 즉 테이블의 모든 속성 값이 원자 값으로만 되어 있는 정규형임 | 테이블에서는 하나의 제품에 대해 여러 개의 주문 관련 정보 (주문번호, 고객번호, 주소, 주문수량)가 발생하고 있음. 따라서 테이블은 제 1정규형이 아님 | . 테이블에서 반복되는 주문 관련 정보를 분리하여 제 1정규형으로 만드시오. . 테이블에서 반복되는 주문 관련 정보인 주문번호, 고객번호, 주소, 주문수량을 분리하면 위와 같이 제 1정규형인 테이블과 테이블이 만들어짐 - 1차 정규화 과정으로 생성된 테이블의 기본키는 (주문번호, 제품번호)이고, 다음과 같은 함수적 종속이 존재함 - 주문번호, 제품번호 -&gt;고객번호, 주소, 주문수량 - 주문번호-&gt;고객번호, 주소 - 고객번호-&gt;주소 | 2차 정규형 . 테이블 R이 제 1정규형이고, 기본키가 아닌 모든 속성이 기본키에 대하여 완전 함수적 종속을 만족하는 정규형임 | 테이블이 테이블과 테이블로 무손실 분해되면서 모두 제 1정규형이 되었지만 그 중 테이블에는 기본키인 (주문번호, 제품번호)에 완전 함수적 종속이 되지 않는 속성이 존재함. 즉 주문수량은 기본키에 대해 완전 함수적 종속이지만 고객번호와 주소는 주문번호에 의해서도 결정될 수 있으므로, 기본키에 대해 완전 함수적 종속이 아님. 따라서 테이블은 제 2정규형이 아님 | . 테이블에서 주문번호에 함수적 종속이 되는 속성들을 분리하여 제 2정규형을 만드시오. . 테이블에서 주문번호에 함수적 종속이 되는 속성인 고객번호와 주소를 분리(즉 부분 함수적 종속성을 제거)해 내면 위와 같이 제 2정규형인 테이블과 테이블로 무손실 분해됨. - 제 2정규화 과정을 거쳐 생성된 테이블의 기본키는 주문번호임. 그리고 테이블에는 아직도 다음과 같은 함수적 종속들이 존재함 - 주문번호-&gt;고객번호, 주소 - 고객번호-&gt;주소 | 제 3정규형 . 테이블 R이 제 2정규형이고 기본키가 아닌 모든 속성이 기본키에 대해 이행적 함수적 종속을 만족하지 않는 정규형임 | 테이블이 테이블과 테이블로 무손실 분해되면서 모두 제 2정규형이 되었음. 그러나 테이블에서 고객번호가 주문번호에 함수적 종속이고, 주소가 고객번호에 함수적 종속이므로 주소는 기본키인 주문번호에 대해 이행적 함수적 종속을 만족함. 즉 주문번호-&gt;고객번호이고, 고객번호-&gt;주소이므로 주문번호-&gt;주소는 이행적 함수적 종속이 됨. 따라서 테이블은 제 3정규형이 아님 | . 테이블에서 이행적 함수적 종속을 제거하여 제 3정규형을 만드시오. . 테이블에서 이행적 함수적 종속(즉 주문번호-&gt;주소)을 제거하여 무손실 분해함으로써 위와 같이 제 3정규형인 테이블과 테이블이 생성됨 | BCNF . BCNF는 테이블 R에서 모든 결정자가 후보키인 정규형임 . | 일반적으로 제 3정규형에 후보키가 여러 개 존재하고, 이러한 후보키들이 서로 중첩되어 나타나는 경우에 적용 가능함 . | 아래의 테이블(제 3정규형)은 함수적 종속{(학번, 과목명)-&gt; 담당교수, (학번, 담당교수)-&gt;과목명, 담당교수-&gt;과목명}을 만족하고 있음. 테이블의 후보키는 (학번, 과목명)과 (학번, 담당교수)임 . | . | 테이블에서 결정자 중 후보키가 아닌 속성이 존재함. 즉 함수적 종속 담당교수-&gt;과목명이 존재하는데, 담당교수가 테이블에서 후보키가 아니기 때문에 테이블은 BCNF가 아님 &gt; 테이블에서 결정자가 후보키가 아닌 속성을 분리하여 BCNF를 만드시오. ![스크린샷 2021-07-04 오후 3.54.16](https://tva1.sinaimg.cn/large/008i3skNgy1gs4x8ox25ej30ng0cywxl.jpg) &gt; 테이블에서 BCNF를 만족하지 못하게 하는 속성(즉 담당교수-&gt;과목명)을 분리해내면 위와 같이 BCNF인 테이블과 테이블로 무손실 분해됨 | 제 4정규형 . 테이블 R에 다중 값 종속(MVD) A-&gt;-&gt;B가 존재할 경우 R의 모든 속성이 A에 함수적 종속 관계를 만족하는 정규형임 | . | 제 5정규형 . 테이블 R의 모든 조인 종속(JD)이 R의 후보키를 통해서만 성립되는 정규형임 | . | . | . [정규화 과정 정리] . 비정규 릴레이션 –도메인이 원자값–&gt; . 1NF –부분적 함수 종속 제거–&gt; . 2NF –이행적 함수 종속 제거–&gt; . 3NF –결정자이면서 후보키가 아닌 것 제거–&gt; . BCNF –다치 종속 제거–&gt; . 4NF –조인 종속성 이용–&gt; . 5NF . *암기 요령: 두부이걸다줘? (도부이결다조) . 이행적 함수적 종속 . A-&gt;B이고 B-&gt;C일 때 A-&gt;C를 만족하는 관계를 이행적 함수적 종속이라고 함 .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/04/15/theory45.html",
            "relUrl": "/theory/2021/04/15/theory45.html",
            "date": " • Apr 15, 2021"
        }
        
    
  
    
        ,"post174": {
            "title": "이상/함수적 종속",
            "content": "1. 이상(Anomaly) . 테이블에서 일부 속성들의 종속으로 인해 데이터의 중복이 발생하고, 이 중복으로 인해 테이블 조작 시 문제가 발생하는 현상을 의미함 | 이상의 종류에는 테이블 조작 중에 발생하는 삽입 이상, 삭제 이상, 갱신 이상이 있음 | . . 삽입 이상(Insertion Anomaly): 테이블에 데이터를 삽입할 때 의도와는 상관 없이 원하지 않은 값들로 인해 삽입할 수 없게 되는 상황 . 테이블에서 학번이 &quot;600&quot;인 학생의 학년이 &quot;2&quot;라는 사실만을 삽입하고자 하는 경우, 삽입 이상이 발생한다. -&gt; 수강 테이블의 기본키는 학번과 과목번호이기 때문에 삽입할 때 반드시 과목번호가 있어야 한다. 즉, 데이터가 발생되는 시점에는 과목번호가 필요 없지만 테이블에 기록하고자 할 때 과목번호가 없어 등록할 수 없는 경우가 발생한다. | 삭제 이상(Deletion Anomaly): 테이블에서 한 튜플을 삭제할 때 의도하는 상관없는 값들도 함께 삭제되는, 즉 연쇄 삭제가 발생하는 현상임 . 테이블에서 학번이 &quot;200&quot;인 학생이 과목번호 &quot;C123&quot;의 등록을 취소하고자 하는 경우 삭제 이상이 발생한다. 학번이 &quot;200&quot;인 학생의 과목번호가 &quot;C123&quot;인 과목을 취소하고자 그 학생의 튜플을 삭제하면 학년 정보까지 같이 삭제된다. 과목만을 취소하고자 했지만 유지되어야 할 학년 정보까지 삭제되기 때문에 정보 손실이 발생한다. | 갱신 이상(Update Anomaly): 테이블에서 튜플에 있는 속성의 값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 불일치성이 생기는 현상임 . 테이블에서 학번이 &quot;400&quot;인 학생의 학년을 &quot;4&quot;에서 &quot;3&quot;으로 변경하고자 하는 경우 갱신 이상이 발생할 수 있다. 학번이 &quot;400&quot;인 모든 튜플의 학년 값을 갱신해야 하는데 실수로 일부 튜플만 갱신하면, 학번이 &quot;400&quot;인 학생의 학년은 &quot;3&quot;과 &quot;4&quot; 즉 2가지 값을 가지게 되어 정보에 불일치성이 생기게 됨 | . 2. 함수적 종속(Functional Dependency) . 어떤 테이블 R에서 X와 Y를 각각 R의 속성 집합의 부분 집합이라 하자. 속성 X의 값 각각에 대해 시간에 관계없이 항상 속성 Y의 값이 오직 하나만 연관되어 있을 때 Y는 X에 함수적 종속 또는 X가 Y를 함수적으로 결정한다고 하고, X-&gt;Y로 표기한다. | 함수적 종속은 데이터의 의미를 표현하는 것으로, 현실 세계를 표현하는 제약 조건이 되는 동시에 데이터베이스에서 항상 유지되어야 할 조건이다. | . 다음의 테이블에서 함수적 종속을 살펴보자. . . 테이블에서 이름, 학년, 학과는 각각 학번 속성에 함수적 종속임. 이것을 기호로 표시하면 다음과 같음 - 학번-&gt;이름, 학년, 학과 - X-&gt;Y의 관계를 갖는 속성 X와 Y에서 X를 결정자라 하고, Y를 종속자라고 함. 예를 들어 학번-&gt;이름에서는 학번이 결정자이고, 이름이 종속자임 다음의 테이블에서 함수적 종속을 기호로 표시해 보자. - 학번, 과목번호-&gt;성적 - 학번-&gt;학년 - 테이블의 속성 중 성적은 (학번, 과목번호)에 완전 함수적 종속이라고 함 - 반면에 테이블의 속성 중 학년은 (학번, 과목번호)에 완전 함수적 종속이 아니므로 부분 함수적 종속이라고 함 *완전 함수적 종속 . 어떤 테이블 R에서 속성 Y가 다른 속성 집합 X 전체에 대해 함수적 종속이면서 속성 집합 X의 어떠한 진부분 집합 Z에도 함수적 종속이 아닐 때 속성 Y는 속성 집합 X에 완전 함수적 종속이라고 함 . *부분 함수적 종속 . 어떤 테이블 R에서 속성 Y가 다른 속성 집합 X 전체에 대해 함수적 종속이면서 속성 집합 X의 임의의 진부분 집합에 대해 함수적 종속일 때, 속성 Y는 속성 집합 X에 부분 함수적 종속이라고 함 . *완전/부분적 함수 종속의 이해 . 완전 함수적 종속이라는 말은 어떤 속성이 기본키에 대해 완전히 종속적일 때를 말함. 예를 들어 테이블은 (학번, 과목번호)가 기본키인데, 성적은 학번과 과목번호가 같을 경우에는 항상 같은 성적이 오므로, 즉 성적은 학번과 과목번호에 의해서만 결정되므로 성적은 기본키(학번, 과목번호)에 완전 함수적 종속이 되는 것임. 반면에 학년은 과목번호에 관계없이 학번이 같으면 항상 같은 학년이 오므로, 즉 기본키의 일부인 학번에 의해서 학년이 결정되므로 학년은 부분 함수적 종속이라고 함. .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/04/14/theory44.html",
            "relUrl": "/theory/2021/04/14/theory44.html",
            "date": " • Apr 14, 2021"
        }
        
    
  
    
        ,"post175": {
            "title": "관계대수 및 관계해석",
            "content": "1. 관계대수 . 관계형 데이터베이스에서 원하는 정보와 그 정보를 검색하기 위해서 어떻게 유도하는가를 기술하는 절차적인 언어임 | 릴레이션을 처리하기 위해 연산자와 연산규칙을 제공하며, 피연산자와 연산 결과가 모두 릴레이션임 | 질의에 대한 해를 구하기 위해 수행해야 할 연산의 순서를 명시함 | 관계 데이터베이스에 적용하기 위해 특별히 개발한 순수 관계 연산자와 수학적 집합 이론에서 사용하는 일반 집합 연산자가 있음 | . 2. 순수 관계 연산자 . Select 릴레이션에 존재하는 튜플 중에서 선택 조건을 만족하는 튜플의 부분집합을 구하여 새로운 릴레이션을 만드는 연산 | 릴레이션의 행에 해당하는 튜플(Tuple)을 구하는 것이므로 수평 연산이라고도 함 | . | Project 주어진 릴레이션에서 속성 리스트(Attribute List)에 제시된 속성 값만을 추출하여 새로운 릴레이션을 만드는 연산 | 연산 결과에 중복이 발생하면 중복이 제거됨 | 릴레이션의 열에 해당하는 속성을 추출하는 것이므로 수직 연산자라고도 함 | . | Join 공통 속성을 중심으로 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산 | 조인의 결과는 Cartesian Product(교차곱)를 수행한 다음 Select를 수행한 것과 같음 | . | Division 부분 집합 관계에 속하는 두 릴레이션 R(X)와 S(Y)가 있을 때, R의 속성이 S의 속성값을 모두 가진 튜플에서 S가 가진 속성을 제외한 속성만을 구하는 연산 | . | . 3. 일반 집합 연산자 . 수학적 집합 이론에서 사용하는 연산자임 | 합집합(UNION), 교집합(INTERSECTION), 차집합(DIFFERENCE)을 처리하기 위해서는 합병 조건을 만족해야 함 | 합병 가능한 두 릴레이션 R과 S가 있을 때 각 연산의 특징을 요약하면 다음과 같음 | . 연산자 기능 및 수학적 표현 카디널리티 . 합집합 UNION | - 두 릴레이션에 존재하는 튜플의 합집합을 구하되, 결과로 생성된 릴레이션에서 중복되는 튜플은 제거- R ∪ S = { t | t ∈ R or t ∈ S }*t는 릴레이션 R 또는 S에 존재하는 튜플 | - |R ∪ S| ≤|R|+|S|-합집합의 카디널리티는 두 릴레이션 카디널리티의 합보다 크지 않음 | . 교집합 INTERSECTION | - 두 릴레이션에 존재하는 튜플의 교집합을 구하는 연산-R ∩ S = { t | t ∈ R and t ∈ S }*t는 릴레이션 R 그리고 S에 동시에 존재하는 튜플 | -|R ∩ S | ≤ MIN{|R|, |S|}-교집합의 카디널리티는 두 릴레이션 중 카디널리티가 적은 릴레이션의 카디널리티보다 크지 않음 | . 차집합 DIFFERENCE | - 두 릴레이션에 존재하는 튜플의 차집합을 구하는 연산- R - S ={ t | t ∈ R and t ∉ S }*t는 릴레이션 R에는 존재하고 S에 없는 튜플 | -|R - S| ≤ |R|-차집합의 카디널리티는 릴레이션 R의 카디널리티 보다 크지 않음 | . 교차곱 CARTESIAN PRODUCT | -두 릴레이션에 있는 튜플들의 순서쌍을 구하는 연산-R x S = { r·s | r ∈ R and s ∈ S }*r은 R에 존재하는 튜플이고, s는 S에 존재하는 튜플 | -| R X S | = |R| X |S|-교차곱은 두 릴레이션의 카디널리티를 곱한 것과 같음 | . 4. 관계 해석(Relational Calculus) . 관계 데이터의 연산을 표현하는 방법임 | 관계 데이터 모델의 제안자인 코드가 수학의 Predicate Calculus(술어 해석)에 기반을 두고 관계 데이터베이스를 위해 제안했음 | 관계해석은 원하는 정보가 무엇이라는 것만 정의하는 비절차적 특성을 지님 | 원하는 정보를 정의할 때는 계산 수식을 사용함 | . 합병 조건 . 합병하려는 두 릴레이션 간에 속성의 수가 같고, 대응되는 속성별로 도메인이 같아야 함 즉, 릴레이션 R과 S가 합병이 가능하다면, 릴레이션 R의 i번째 속성과 릴레이션 S의 i번째 속성의 도메인이 서로 같아야 함. 그러나 속성의 이름이 같아야 하는 것은 아님 .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/04/13/theory43.html",
            "relUrl": "/theory/2021/04/13/theory43.html",
            "date": " • Apr 13, 2021"
        }
        
    
  
    
        ,"post176": {
            "title": "관계형 데이터베이스의 제약 조건-무결성(Integrity)",
            "content": "1. 무결성(Integrity) . 데이터베이스에 저장된 데이터 값과 그것이 표현하는 현실 세계의 실제값이 일치하는 정확성을 의미 | 무결성 제약 조건은 데이터베이스에 들어 있는 데이터의 정확성을 보장하기 위해 부정확한 자료가 데이터베이스 내에 저장되는 것을 방지하기 위한 제약 조건을 말함 | . 2. 무결성의 종류 . 개체 무결성 기본 테이블의 기본키를 구성하는 어떤 속성도 Null 값이나 중복값을 가질 수 없다는 규정 | . | 참조 무결성 외래키 값은 Null이거나 참조 릴레이션의 기본키 값과 동일해야 함. 즉 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다는 규정 | . | 도메인 무결성 주어진 속성 값이 정의된 도메인에 속한 값이어야 한다는 규정 | . | 사용자 정의 무결성 속성 값들이 사용자가 정의한 제약조건에 만족되어야 한다는 규정 | . | NULL 무결성 릴레이션의 특정 속성 값이 NULL이 될 수 없도록 하는 규정 | . | 고유 무결성 릴레이션의 특정 속성에 대해 각 튜플이 갖는 속성값들이 서로 달라야 한다는 규정 | . | 키 무결성 하나의 릴레이션에는 적어도 하나의 키가 존재해야 한다는 규정 | . | 관계 무결성 릴레이션에 어느 한 튜플의 삽입 가능 여부 또는 한 릴레이션과 다른 릴레이션의 튜플들 사이의 관계에 대한 적절성 여부를 지정한 규정 | . | . 3. 데이터 무결성 강화 . 데이터 무결성은 데이터 품질에 직접적인 영향을 미치므로 데이터 특성에 맞는 적절한 무결성을 정의하고 강화해야 함 | 데이터 무결성은 애플리케이션, 데이터베이스 트리거, 제약 조건을 이용하여 강화할 수 있음 | 애플리케이션: 데이터 생성, 수정, 삭제 시 무결성 조건을 검증하는 코드를 프로그램 내에 추가함 | 데이터베이스 트리거: 트리거 이벤트에 무결성 조건을 실행하는 절차형 SQL을 추가함 | 제약 조건: 데이터베이스에 제약 조건을 설정하여 무결성을 유지함 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/04/12/theory42.html",
            "relUrl": "/theory/2021/04/12/theory42.html",
            "date": " • Apr 12, 2021"
        }
        
    
  
    
        ,"post177": {
            "title": "관계형 데이터베이스의 제약 조건-키(Key)",
            "content": "1. 키(Key) . 데이터베이스에서 조건에 만족하는 튜플을 찾거나 순서대로 정립할 때 기준이 되는 속성 | 종류 후보키(Candidate Key) | 기본키(Primary Key) | 대체키(Alternate Key) | 슈퍼키(Super Key) | 외래키(Foreign Key) | . | . 2. 후보키(Candidate Key) . 릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별하기 위해 사용되는 속성들의 부분집합 | 기본키로 사용할 수 있는 속성들을 말함 | 후보키는 유일성(Unique)과 최소성(Minimality)을 모두 만족시켜야 함 | . 유일성: 하나의 키 값으로 하나의 튜플만을 유일하게 식별할 수 있어야 함 . 최소성: 키를 구성하는 속성 하나를 제거하면 유일하게 식별할 수 없도록 꼭 필요한 최소의 속성으로 구성해야 함 . 3. 기본키(Primary Key) . 후보키 중에서 특별히 선정된 주키임 | 중복된 값을 가질 수 없음 | 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성 | 기본키는 NULL 값을 가질 수 없음. 즉 튜플에서 기본키로 설정된 속성에는 NULL 값이 있어서는 안 됨 | . 4. 대체키(Alternate Key) . 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키 | 보조키라고도 함 | . 5. 슈퍼키(Super Key) . 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키 | 릴레이션을 구성하는 모든 튜플 중 슈퍼키로 구성된 속성의 집합과 동일한 값은 나타나지 않음 | 릴레이션을 구성하는 모든 튜플에 대해 유일성을 만족하지만, 최소성은 만족하지 못함 | . 6. 외래키(Foreign Key) . 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합을 의미 | 한 릴레이션에 속한 속성 A와 참조 릴레이션의 기본키인 B가 동일한 도메인 상에서 정의되었을 때의 속성 A를 외래키라고 함 | 외래키로 지정되면 참조 릴레이션의 기본키에 없는 값은 입력할 수 없음 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/04/11/theory41.html",
            "relUrl": "/theory/2021/04/11/theory41.html",
            "date": " • Apr 11, 2021"
        }
        
    
  
    
        ,"post178": {
            "title": "관계형 데이터베이스의 구조/관계형 데이터 모델",
            "content": "1. 관계형 데이터베이스 . 2차원적인 표(Table)를 이용해서 데이터 상호 관계를 정의하는 데이터베이스 | 1970년 IBM에 근무하던 코드(E. F. Codd)에 의해 처음 제안되었음 | 개체(Entity)와 관계(Relationship)를 모두 릴레이션(Relation)이라는 표로 표현하기 때문에 개체 릴레이션과 관계 릴레이션이 존재함 | 장점: 간결하고 보기 편리하며, 다른 데이터베이스로의 변환이 용이 | 단점: 성능이 다소 떨어짐 | . 2. 관계형 데이터베이스의 릴레이션 구조 . 릴레이션은 데이터들을 표의 형태로 표현한 것으로, 구조를 나타내는 릴레이션 스키마와 실제 값들인 릴레이션 인스턴스로 구성됨 . 릴레이션 인스턴스: 데이터 개체를 구성하고 있는 속성들에 데이터 타입에 정의되어 구체적인 데이터 값을 가진 것을 말함 . 3. 튜플(Tuple) . 릴레이션을 구성하는 각각의 행을 말함 | 속성의 모임으로 구성됨 | 파일 구조에서 레코드와 같은 의미 | 튜플의 수를 카디너리티 또는 기수, 대응수라고 함 | . 4. 속성(Attribute) . 데이터베이스를 구성하는 가장 작은 논리적 단위 | 파일 구조상의 데이터 항목 또는 데이터 필드에 해당됨 | 속성은 개체 특성을 기술함 | 속성의 수를 디그리 또는 차수라고 함 | . 5. 도메인(Domain) . 하나의 애트리뷰트가 취할 수 있는 같은 타입의 원자(Atomic)값들의 집합임 | 실제 애트리뷰트 값이 나타날 때 그 값의 합법 여부를 시스템이 검사하는데에도 이용됨 성별 애트리뷰트의 도메인은 “남”과 “여”로, 그 외의 값은 입력될 수 없다. | . | . 6. 릴레이션의 특징 . 한 릴레이션에는 똑같은 튜플이 포함될 수 없으므로 릴레이션에 포함된 튜플들은 모두 상이함 | 한 릴레이션에 포함된 튜플 사이에는 순서가 없음 | 튜플들의 삽입, 삭제 등의 작업으로 인해 릴레이션은 시간에 따라 변함 | 릴레이션 스키마를 구성하는 속성들 간의 순서는 중요하지 않음 | 속성의 유일한 식별을 위해 속성의 명칭은 유일해야 하지만, 속성을 구성하는 값은 동일한 값이 있을 수 있음 | 릴레이션을 구성하는 튜플을 유일하게 식별하기 위해 속성들의 부분집합을 키로 설정함 | 속성의 값은 논리적으로 더 이상 쪼갤 수 없는 원자값만을 저장함 | . 7. 관계형 데이터 모델(Relational Data Model) . 2차원적인 표(Table)를 이용해서 데이터 상호 관계를 정의하는 DB 구조를 말함 . | 가장 널리 사용되는 데이터 모델 . | 파일 구조처럼 구성한 테이블들을 하나의 DB로 묶어서 테이블 내에 있는 속성들 간의 관계를 설정하거나 테이블 간의 관계를 설정하여 이용함 . | 기본키(Primary Key)와 이를 참조하는 외래키(Foreign Key)로 데이터 간의 관계를 표현함 . | 계층 모델과 망 모델의 복잡한 구조를 단순화시킨 모델 . | 관계형 모델의 대표적인 언어는 SQL임 . | 1:1, 1:N, N:M 관계를 자유롭게 표현할 수 있음 . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/04/10/theory40.html",
            "relUrl": "/theory/2021/04/10/theory40.html",
            "date": " • Apr 10, 2021"
        }
        
    
  
    
        ,"post179": {
            "title": "E-R(개체-관계) 모델",
            "content": "1. E-R(Entity-Relationship, 개체-관계) 모델 . E-R 모델은 개체와 개체 간의 관계를 기본 요소로 이용하여 현실 세계의 무질서한 데이터를 개념적인 논리 데이터로 표현하기 위한 방법임 | 1976년 피터 첸에 의해 제안되고 기본적인 구성 요소가 정립되었음 | 개념적 데이터 모델의 가장 대표적인 것임 | 개체 타입(Entity Type)과 이들 간의 관계 타입(Relationship Type)을 이용해 현실 세계를 개념적으로 표현 | 데이터를 개체(Entity), 관계(Relationship), 속성(Attribute)으로 묘사 | 1:1, 1:N, N:M 등의 관계 유형을 제한 없이 나타낼 수 있음 | . 2. E-R 다이어그램 . 사각형: 개체(Entity) 타입 . | 마름모: 관계(Relationship) 타입 . | 타원: 속성(Attribute) . | 이중 타원: 다중값 속성(복합 속성) . | 밑줄 타원: 기본키 속성 . | 복수 타원: 복합 속성 ex) 성명은 성과 이름으로 구성 . | 관계: 1:1, 1:N, N:M 등 개체 간 관계에 대한 대응수를 선 위에 기술함 . | 선, 링크: 개체 타입과 속성을 연결 . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/04/09/theory39.html",
            "relUrl": "/theory/2021/04/09/theory39.html",
            "date": " • Apr 9, 2021"
        }
        
    
  
    
        ,"post180": {
            "title": "식별자(Identifier)",
            "content": "1. 식별자 . 하나의 개체 내에서 각각의 인스턴스를 유일하게 구분할 수 있는 구분자 | 모든 개체는 한 개 이상의 식별자를 반드시 가져야 함 | . 2. 식별자의 분류 . 대표성 여부 주 식별자(Primary Identifier): 개체를 대표하는 유일한 식별자 | 보조 식별자(Alternate Identifier): 주 식별자를 대신하여 개체를 식별할 수 있는 속성 | . | 스스로 생성 여부 내부 식별자(Internal Identifier): 개체 내에서 스스로 만들어지는 식별자 | 외부 식별자(Foreign Identifier): 다른 개체와의 관계에 의해 외부 개체의 식별자를 가져와 사용하는 식별자 | . | 단일 속성 여부 단일 식별자(Single Identifier): 주 식별자가 한 가지 속성으로만 구성된 식별자 | 복합 식별자(Composit Identifier): 주 식별자가 두 개 이상의 속성으로 구성된 식별자 | . | 대체 여부 원조 식별자(Original Identifier): 업무에 의해 만들어지는 가공되지 않은 원래의 식별자로 본질 식별자라고도 함 | 대리 식별자(Surrogate Identifier): 주 식별자의 속성이 두 개 이상인 경우 속성들을 하나의 속성으로 묶어 사용하는 식별자로 인조 식별자라고도 함 | . | . 3. 후보 식별자 . 개체에서 각 인스턴스를 유일하게 식별할 수 있는 속성 또는 속성 집합 | 하나의 개체에는 한 개 이상의 후보 식별자가 존재할 수 있으며 이 중 개체의 대표성을 나타내는 식별자를 주 식별자로, 나머지는 보조 식별자로 지정 | . 4. 주 식별자의 특징 . 유일성: 개체 내의 모든 인스턴스들은 주 식별자에 의해 유일하게 구분되어야 함 | 최소성: 유일성을 만족시키기에 필요한 최소한의 속성으로만 구성되어야 함 | 불변성: 주 식별자가 특정 개체에 한 번 지정되면 그 식별자는 변하지 않아야 함 | 존재성: 주 식별자가 지정되면 식별자 속성에 반드시 데이터 값이 존재해야 함 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/04/08/theory38.html",
            "relUrl": "/theory/2021/04/08/theory38.html",
            "date": " • Apr 8, 2021"
        }
        
    
  
    
        ,"post181": {
            "title": "데이터 모델의 구성 요소",
            "content": "1. 개체(Entity) . 데이터베이스에 표현하려는 것. 개념이나 정보 단위 같은 현실 세계의 대상체 | 실세계에 독립적으로 존재하는 유형, 무형의 정보. 서로 연관된 몇 개의 속성으로 구성됨 | 독립적으로 존재하거나 그 자체로서도 구별이 가능. 유일한 식별자에 의해 식별 | 다른 개체와 하나 이상의 관계가 있음 | . 속성: 개체가 가지고 있는 특성 . 개체 타입: 속성으로만 기술된 개체의 정의 . 개체 인스턴스: 개체를 구성하고 있는 각 속성들이 값을 가져 하나의 개체를 나타내는 것으로 개체 어커런스라고도 함 . 개체 세트: 개체 인스턴스의 집합 . 2. 속성(Attribute) . 데이터베이스를 구성하는 가장 작은 논리적 단위 | 파일 구조상의 데이터 항목 또는 데이터 필드에 해당 | 개체를 구성하는 항목으로 개체의 특성을 기술 | 속성의 수: 디그리 또는 차수라고 함 | 속성의 특성과 개체 구성 방식에 따라 분류함 | . 3. 속성의 특성에 따른 분류 . 기본 속성(Basic Attribute) 업무 분석을 통해 정의한 속성 | 속성 중 가장 많고 일반적임 | 업무상 코드로 정의한 속성은 기본 속성에서 제외 | . | 설계 속성(Designed Attribute) 원래 업무상 존재하지 않고 설계 과정에서 도출해내는 속성 | 업무에 필요한 데이터 외에 데이터 모델링을 위해 업무를 규칙화하려고 속성을 새로 만들거나 변형하여 정의하는 속성 | . | 파생 속성(Derived Attribute) 다른 속성으로부터 계산이나 변형 등의 영향을 받아 발생하는 속성 | 되도록 적은 수를 정의 | . | . 기본 속성인 ‘자동차명’, ‘제조일’, ‘연비’는 업무 분석을 통해 정의한 가장 일반적인 속성이고, 설계 속성인 ‘자동차코드’는 판매되는 자동차를 종류별로 구분하기 위해 업무에는 없지만 새롭게 정의한 속성이며, 파생 속성인 ‘총판매수량’과 ‘총판매금액’은 특정 기간동안 판매된 자동차의 수량과 금액의 합계 계산을 위해 정의한 속성임. . 4. 속성의 개체 구성 방식에 따른 분류 . 기본키 속성(Primary Key Attribute) 개체를 유일하게 식별할 수 있는 속성 | . | 외래키 속성(Foreign Key Attribute) 다른 개체와의 관계에서 포함된 속성 | . | 일반 속성 개체에 포함되어 있고 기본키, 외래키에 포함되지 않은 속성 | . | . 5. 관계(Relationship) . 개체와 개체 사이의 논리적인 연결을 의미 | 개체 간의 관계와 속성 간의 관계가 있음 | . 6. 관계의 형태 . 일 대 일(1:1): 개체 집합 A의 각 원소가 개체 집합 B의 원소 한 개와 대응하는 관계 | 일 대 다(1:N): 개체 집합 A의 각 원소는 개체 집합 B의 원소 여러 개와 대응하고 있지만, 개체 집합 B의 각 원소는 개체 집합 A의 원소 한 개와 대응하는 관계 | 다 대 다(N:M): 개체 집합 A의 각 원소는 개체 집합 B의 원소 여러 개와 대응하고, 개체 집합 B의 각 원소도 개체 집합 A의 원소 여러 개와 대응하는 관계 | . 7. 관계의 종류 . 종속 관계(Dependent Relationship) . 두 개체 사이의 주.종 관계를 표현한 것 | 식별 관계와 비식별 관계가 있음 | . | 중복 관계(Redundant Relationship) . 두 개체 사이에 2번 이상의 종속 관계가 발생하는 관계 | . | 재귀 관계(Recursive Relationship) . 개체가 자기 자신과 관계를 갖는 것으로, 순환 관계라고도 함 | . | 배타 관계(Exclusive Relationship) . 개체의 속성이나 구분자를 기준으로 개체의 특성을 분할하는 관계로, 배타 AND 관계와 배타 OR 관계로 구분 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/04/07/theory37.html",
            "relUrl": "/theory/2021/04/07/theory37.html",
            "date": " • Apr 7, 2021"
        }
        
    
  
    
        ,"post182": {
            "title": "데이터 모델의 개념",
            "content": "1. 데이터 모델 . 현실 세계의 정보들을 컴퓨터에 표현하기 위해 단순화, 추상화하여 체계적으로 표현한 개념적 모형 | 데이터, 데이터의 관계, 데이터의 의미 및 일관성, 제약 조건 등을 기술하기 위한 개념적 도구들로 구성 | 데이터베이스 설계 과정에서 데이터의 구조(Schema)를 논리적으로 표현하기 위해 지능적 도구로 사용 | 구성 요소: 개체, 속성, 관계 | 종류: 개념적 데이터 모델, 논리적 데이터 모델, 물리적 데이터 모델 | 표시할 요소: 구조, 연산, 제약 조건 | . 2. 개념적 데이터 모델 . 현실 세계에 대한 인간의 이해를 돕기 위해 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정 | 속성들로 기술된 개체 타입 + 개체 타입 간 관계 | 정보 모델이라고도 함 | 대표적 개념적 데이터 모델: ER 모델 | . 3. 논리적 데이터 모델 . 개념적 구조를 컴퓨터가 이해하고 처리할 수 있는 컴퓨터 세계의 환경에 맞도록 변환하는 과정 | 필드로 기술된 데이터 타입 + 데이터 타입 간 관계 | 단순히 데이터 모델이라고 하면 논리적 데이터 모델 의미 | 특정 DBMS는 특정 논리적 데이터 모델 하나만 선정하여 사용 | 데이터 간의 관계를 어떻게 표현하느냐에 따라 관계 모델, 계층 모델, 네트워크 모델로 구분 | . 4. 데이터 모델에 표시할 요소 . 구조(Structure) : 논리적으로 표현된 개체 타입들 간의 관계로서 데이터 구조 및 정적 성질 표현 | 연산(Operation) : 실제 데이터를 처리하는 작업에 대한 명세. 데이터베이스를 조작하는 기본 도구 | 제약 조건(Constraint) : 데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약 조건 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/04/06/theory36.html",
            "relUrl": "/theory/2021/04/06/theory36.html",
            "date": " • Apr 6, 2021"
        }
        
    
  
    
        ,"post183": {
            "title": "데이터베이스 설계",
            "content": "1. 데이터베이스 설계 . 사용자의 요구를 분석하여 그것들을 컴퓨터에 저장할 수 있는 데이터베이스의 구조에 맞게 변경한 후 DBMS로 데이터베이스를 구현하여 일반 사용자들이 사용하게 하는 것 | . 2. 데이터베이스 설계 시 고려사항 . 무결성 연산 후에도 저장된 데이터가 정해진 제약조건을 항상 만족 | . | 일관성 저장된 데이터들 사이나 특정 질의에 대한 응답이 처음부터 끝까지 변함 없이 일정해야 함 | . | 회복 시스템에 장애가 발생했을 때 장애 발생 직전의 상태로 복구할 수 있어야 함 | . | 보안 불법적인 데이터의 노출 또는 변경이나 손실로부터 보호 | . | 효율성 응답시간의 단축, 시스템의 생산성, 저장 공간의 최적화 등이 가능해야 함 | . | 데이터베이스 확장 데이터베이스 운영에 영향을 주지 않으면서 지속적으로 데이터를 추가할 수 있어야 함 | . | . 3. 데이터베이스 설계 순서 . 요구 조건 분석 . 요구 조건 명세서 작성 . | 개념적 설계 . 개념 스키마, 트랜잭션 모델링, E-R 모델 . | 논리적 설계 . 목표 DBMS에 맞는 논리 스키마 설계, 트랜잭션 인터페이스 설계 . | 물리적 설계 . 목표 DBMS에 맞는 물리적 구조의 데이터로 변환 . | 구현 . 목표 DBMS의 DDL(데이터 정의어)로 데이터베이스 생성, 트랜잭션 작성 . | 4. 요구 조건 분석 . 데이터베이스를 사용할 사람들로부터 필요한 용도 파악 | 데이터베이스 사용자에 따른 수행 업무와 필요한 데이터의 종류, 용도, 처리 형태, 흐름, 제약 조건 등을 수집 | 수집된 정보를 바탕으로 요구 조건 명세 작성 | . 5. 개념적 설계(정보 모델링, 개념화) . 정보의 구조를 얻기 위해 현실 세계의 무한성과 계속성을 이해하고 다른 사람과 통신하기 위하여 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정 | 개념 스키마 모델링+트랜잭션 모델링(병행 수행) | 요구 조건 명세를 DBMS에 독립적인 E-R 다이어그램으로 작성 | DBMS에 독립적인 개념 스키마 설계 | . 6. 논리적 설계(데이터 모델링) . 현실 세계에서 발생하는 자료를 컴퓨터가 이해하고 처리할 수 있는 물리적 저장장치에 저장할 수 있도록 변환하기 위해 특정 DBMS가 지원하는 논리적 자료 구조로 변환시키는 과정 . | 개념 세계의 데이터를 필드로 기술된 데이터 타입과 이 데이터 타입들 간의 관계로 표현되는 논리적 구조의 데이터로 모델화 | 개념 스키마를 평가 및 정제하고 DBMS에 따라 서로 다른 논리적 스키마를 설계 | 트랜잭션의 인터페이스 설계 | . 7. 물리적 설계(데이터 구조화) . 논리적 구조로 표현된 데이터를 디스크 등의 물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터로 변환하는 과정 | 다양한 데이터베이스 응용에 대해 처리 성능을 얻기 위해 데이터베이스 파일의 저장 구조 및 액세스 경로를 결정 | 저장 레코드의 형식, 순서, 접근 경로, 조회 집중 레코드 등의 정보를 사용하여 데이터가 컴퓨터에 저장되는 방법 묘사 | . 8. 데이터베이스 구현 . 논리적 설계와 물리적 설계에서 도출된 데이터베이스 스키마를 파일로 생성하는 과정 | 사용하려는 특정 DBMS의 DDL(데이터 정의어)을 이용하여 데이터베이스 스키마를 기술한 후 컴파일하여 빈 데이터베이스 파일을 생성 | 응용 프로그램을 위한 트랜잭션 작성 | 데이터베이스 접근을 위한 응용 프로그램을 작성 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/04/05/theory35.html",
            "relUrl": "/theory/2021/04/05/theory35.html",
            "date": " • Apr 5, 2021"
        }
        
    
  
    
        ,"post184": {
            "title": "데이터베이스 개요",
            "content": "1. 데이터저장소 . 데이터들을 논리적인 구조로 조직화하거나 물리적인 공간에 구축한 것 | . 논리 데이터저장소: 데이터 및 데이터 간의 연관성, 제약조건을 식별하여 논리적인 구조로 조직화한 것 . 물리 데이터저장소: 논리 데이터저장소를 실제 저장장치에 저장한 것 . 2. 데이터베이스(Database) . 공동으로 사용될 데이터의 중복을 배제하여 통합하고, 쉽게 접근하여 처리할 수 있도록 저장장치에 저장하여 항상 사용할 수 있도록 운영하는 운영 데이터 | . 통합된 데이터(Integrated Data) : 자료의 중복을 배제한 데이터의 모임 | 저장된 데이터(Stored Data) : 컴퓨터가 접근할 수 있는 저장 매체에 저장된 자료 | 운영 데이터(Operated Data) : 조직의 고유한 업무를 수행하는 데 반드시 필요한 자료 | 공용 데이터(Shared Data) : 여러 응용 시스템들이 공동으로 소유하고 유지하는 자료 | 3. DBMS(DataBase Management System; 데이터베이스 관리 시스템) . 사용자의 요구에 따라 정보를 생성해주고, 데이터베이스를 관리해주는 소프트웨어 | 기존의 파일 시스템이 갖는 데이터의 종속성과 중복성의 문제 해결 가능 . | 필수 기능 . 정의(Definition) 기능 . 데이터의 형과 구조에 대한 정의, 이용 방식, 제약 조건 등 명시 . | 조작(Manipulation) 기능 . 데이터 검색, 갱신, 삽입, 삭제 인터페이스 제공 . | 제어(Control) 기능 . 데이터의 무결성, 보안, 권한 검사, 병행 제어 제공 . | | . 4. 데이터의 독립성 . 논리적 독립성 응용 프로그램과 데이터베이스 독립시킴 | 데이터의 논리적 구조를 변경해도 응용 프로그램은 영향 받지 않음 | . | 물리적 독립성 응용 프로그램과 물리적 장치 독립시킴 | 디스크를 추가/변경하더라도 응용 프로그램은 영향 받지 않음 | . | . 5. 스키마(Schema) . 데이터베이스의 구조와 제약조건에 관한 전반적인 명세를 기술한 것 | . 외부 스키마 . 사용자나 응용 프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조 정의한 것 | | 개념 스키마 . 데이터베이스의 전체적인 논리적인 구조 | 모든 응용 프로그램이나 사용자들이 필요로 하는 데이터를 종합한 조직 전체의 데이터베이스로 하나만 존재 | | 내부 스키마 . 물리적 저장장치의 입장에서 본 데이터베이스 구조 . | 실제로 저장될 레코드의 형식, 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등 나타냄 . | |",
            "url": "https://eunkyung99.github.io/gang/theory/2021/04/04/theory34.html",
            "relUrl": "/theory/2021/04/04/theory34.html",
            "date": " • Apr 4, 2021"
        }
        
    
  
    
        ,"post185": {
            "title": "오류 데이터 측정 및 정제",
            "content": "1. 오류 데이터 측정 및 정제 . 고품질의 데이터를 운영 및 관리하기 위해 수행 | 진행 과정 데이터 품질 분석 오류 데이터 찾기 위해 원천 및 목적 시스템 데이터의 정합성 여부 확인 | . | 오류 데이터 측정 정상 데이터와 오류 데이터의 수를 측정하여 오류 관리 목록 작성 | . | 오류 데이터 정제 오류 관리 목록의 각 항목 분석하여 원천 데이터 정제/전환 프로그램 수정 | . | . | . 2. 오류 상태 . Open : 오류가 보고만 되고 분석되지 않은 상태 | Assigned : 개발자에게 오류 전달한 상태 | Fixed : 개발자가 오류 수정한 상태 | Closed : 수정된 오류를 다시 테스트했을 때 오류가 발견되지 않은 상태 | Deferred : 오류 수정 연기한 상태 | Classified : 보고된 오류를 관리자들이 오류가 아니라고 확인한 상태 | . 3. 데이터 정제요청서 . 데이터의 정제와 전환 프로그램 수정 위해 요청사항 및 조치사항 등 데이터 정제와 관련된 전반적인 내용을 문서로 작성한 것 | 오류 관리 목록을 기반으로 데이터 정제 요건 목록을 작성하고 이 목록의 항목별로 데이터 정제요청서 작성 | . 4. 데이터 정제보고서 . 정제된 원천 데이터가 정상적으로 정제되었는지 확인한 결과를 문서로 작성한 것 | 정제 요청 데이터와 정제된 데이터 항목을 눈으로 직접 비교하여 확인 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/04/03/theory33.html",
            "relUrl": "/theory/2021/04/03/theory33.html",
            "date": " • Apr 3, 2021"
        }
        
    
  
    
        ,"post186": {
            "title": "데이터 검증",
            "content": "1. 데이터 검증 . 원천 시스템의 데이터를 목적 시스템의 데이터로 전환하는 과정이 정상적으로 수행되었는지 여부를 확인하는 과정 | . 2. 검증 방법에 따른 분류 . 로그 검증: 데이터 전환 과정에서 작성하는 추출, 전환, 적재 로그 검증 . | 기본 항목 검증: 로그 검증 외에 별도 요청된 검증 항목에 대해 검증 . | 응용 프로그램 검증: 응용 프로그램을 통한 데이터 전환의 정합성 검증 . | 응용 데이터 검증: 사전에 정의된 업무 규칙을 기준으로 데이터 전환의 정합성 검증 . | 값 검증: 숫자 항목의 합계 검증, 코드 데이터의 범위 검증, 속성 변경에 따른 값 검증 수행 . | . 3. 검증 단계에 따른 분류 . 추출: 원천 시스템 데이터에 대한 정합성 확인(로그 검증) | 전환: 매핑 정의서에 정의된 내용 정확히 반영되었는지, 오류 여부 확인(로그 검증) | DB 적재: SAM 파일을 적재하는 과정에서 발생할 수 있는 오류나 데이터 누락 여부 등 확인(로그 검증) | DB 적재 후: 적재 완료 후 정합성 확인(기본 항목 검증) | 전환 완료 후: 추가 검증을 통해 데이터 전환의 정합성 검증(응용 프로그램 검증, 응용 데이터 검증) | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/04/02/theory32.html",
            "relUrl": "/theory/2021/04/02/theory32.html",
            "date": " • Apr 2, 2021"
        }
        
    
  
    
        ,"post187": {
            "title": "데이터 전환",
            "content": "1. 데이터 전환 . 운영 중인 기존 정보 시스템에 축적되어 있는 데이터를 추출하여 새로 개발할 정보 시스템에서 운영할 수 있도록 변환한 후 적재하는 일련의 과정 . | ETL(Extraction, Transformation, Load) 과정이라고 함 | 데이터 이행 또는 데이터 이관이라고도 함 | . 2. 데이터 전환 계획서 . 데이터 전환이 필요한 대상을 분석하여 데이터 전환 작업에 필요한 모든 계획을 기록하는 문서 . | 항목 . 데이터 전환 개요 | 데이터 전환 대상 및 범위 | 데이터 전환 환경 구성 | 데이터 전환 조직 및 역할 | 데이터 전환 일정 | 데이터 전환 방안 | 데이터 정비 방안 | 비상 계획 | 데이터 복구 대책 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/03/31/theory31.html",
            "relUrl": "/theory/2021/03/31/theory31.html",
            "date": " • Mar 31, 2021"
        }
        
    
  
    
        ,"post188": {
            "title": "소프트웨어 개발 프레임워크",
            "content": "1. 소프트웨어 개발 프레임워크 . 소프트웨어 개발에 공통적으로 사용되는 구성 요소와 아키텍처를 일반화하여 손쉽게 구현할 수 있도록 여러 가지 기능들을 제공하는 반제품 형태의 소프트웨어 시스템 | 선행 사업자의 기술에 의존하지 않는 표준화된 개발 기반으로 인해 사업자 종속성이 해소됨 | 주요 기능 예외 처리 | 트랜잭션 처리 | 메모리 공유 | 데이터 소스 관리 | 서비스 관리 | 쿼리 서비스 | 로깅 서비스 | 사용자 인증 서비스 | . | 종류 스프링 프레임워크 | 전자정부 프레임워크 | 닷넷 프레임워크 | . | . 2. 스프링 프레임워크 . 자바 플랫폼을 위한 오픈 소스 경량형 애플리케이션 프레임워크 | 동적인 웹 사이트의 개발을 위해 다양한 서비스 제공 | 전자정부 표준 프레임워크의 기반 기술로 사용 | . 3. 전자정부 프레임워크 . 대한민국의 공공부문 정보화 사업 시 효율적인 정보 시스템의 구축을 지원하기 위해 필요한 기능 및 아키텍처를 제공하는 프레임워크 | 개발 프레임워크의 표준 정립으로 응용 소프트웨어의 표준화, 품질 및 재사용성 향상이 목적 | 오픈 소스 기반의 범용화 이룰 수 있음 | 공개된 기술을 활용해 특정 업체의 종속성을 배제하고 사업별 공통 컴포넌트의 중복 개발 방지 | . 4. 닷넷 프레임워크(.NET Framework) . Windows 프로그램의 개발 및 실행 환경을 제공하는 프레임워크 | 통합 인터넷 전략을 위해 Microsoft 사에서 개발 | 코드 실행을 관리하는 CLR(Common Language Runtime) 이라는 이름의 가상머신 상에서 작동 | . 5. 소프트웨어 개발 프레임워크의 특성 . 모듈화(Modularity) . 캡슐화를 통해 모듈화를 강화하고 설계 및 구현의 변경에 따른 영향 최소화하여 소프트웨어 품질 향상 | 개발 표준에 의한 모듈화로 인해 유지 보수 용이 | . | 재사용성(Reusability) . 재사용 가능한 모듈을 제공하여 예산 절감, 생산성 향상, 품질 보증이 가능 | . | 확장성(Extensibility) . 다형성을 통한 인터페이스 확장이 가능하여 다양한 형태와 기능을 가진 애플리케이션 개발 가능 | . | 제어의 역흐름(Inversion of Control) . 개발자가 관리하고 통제해야 하는 객체들의 제어를 프레임워크에 넘김으로써 생산성 향상 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/03/30/theory30.html",
            "relUrl": "/theory/2021/03/30/theory30.html",
            "date": " • Mar 30, 2021"
        }
        
    
  
    
        ,"post189": {
            "title": "소프트웨어 개발 방법론 테일러링",
            "content": "1. 소프트웨어 개발 방법론 테일러링 . 프로젝트 상황 및 특성에 맞도록 정의된 소프트웨어 개발 방법론의 절차, 사용 기법 등을 수정 및 보완하는 작업 | . 프로젝트 특징 정의 -&gt; 표준 프로세스 선정 및 검증 -&gt; 상위 수준의 커스터마이징 -&gt; 세부 커스터마이징 -&gt; 테일러링 문서화 . 2. 소프트웨어 개발 방법론 테일러링 고려사항 . 내부적 기준 . 목표 환경: 시스템의 개발 환경과 유형이 서로 다른 경우 | 요구사항: 우선적으로 고려할 요구사항이 서로 다른 경우 | 프로젝트 규모: 비용, 인력, 기간 등 프로젝트 규모가 서로 다른 경우 | 보유 기술: 프로세스, 개발 방법론, 산출물, 구성원의 능력 등이 서로 다른 경우 | . | 외부적 기준 . 법적 제약사항: 프로젝트별로 적용될 IT Compliance(기업 운영 시 IT 분야에서 반드시 지켜야 하는 법적 규제 사항)가 서로 다른 경우 . | 표준 품질 기준: 금융, 제도 등 분야별 표준 품질 기준이 서로 다른 경우 . | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/03/29/theory29.html",
            "relUrl": "/theory/2021/03/29/theory29.html",
            "date": " • Mar 29, 2021"
        }
        
    
  
    
        ,"post190": {
            "title": "소프트웨어 개발 표준",
            "content": "1. 소프트웨어 개발 표준 . 소프트웨어 개발 단계에서 수행하는 품질 관리에 사용되는 국제 표준을 의미 . | 주요 소프트웨어 개발 표준 . ISO/IEC 12207 . CMMI(능력 성숙도 통합 모델) . SPICE(소프트웨어 처리 개선 및 능력 평가 기준) . | . 2. ISO/IEC 12207 . ISO(국제표준화기구)에서 만든 표준 소프트웨어 생명 주기 프로세스임 | 소프트웨어의 개발, 운영, 유지보수 등을 체계적으로 관리하기 위한 소프트웨어 생명 주기 표준 제공 | 구분(기본, 지원, 조직) 기본 생명 주기 프로세스: 획득, 공급, 개발, 운영, 유지보수 프로세스 | 지원 생명 주기 프로세스: 품질 보증, 검증, 확인, 활동 검토, 감사, 문서화, 형상 관리, 문제 해결 프로세스 | 조직 생명 주기 프로세스: 관리, 기반 구조, 훈련, 개선 프로세스 | . | . 3. CMMI(Capability Maturity Model Integration) . 소프트웨어 개발 조직의 업무 능력 및 조직의 성숙도를 평가하는 모델 | 성숙도 단계: 초기, 관리, 정의, 정량적 관리, 최적화 초기: 정의된 프로세스 없음, 작업자 능력에 따라 성공 여부 결정 | 관리: 규칙화된 프로세스, 특정한 프로젝트 내의 프로세스 정의 및 수행 | 정의: 표준화된 프로세스, 조직의 표준 프로세스 활용하여 업무 수행 | 정량적 관리: 예측 가능한 프로세스, 프로젝트를 정량적으로 관리 및 통제 | 최적화: 지속적 개선 프로세스, 프로세스 역량 향상을 위해 지속적인 프로세스 개선 | . | . 4. SPICE(Software Process Improvement and Capability dEtermination) . 소프트웨어의 품질 및 생산성 향상을 위해 소프트웨어 프로세스를 평가 및 개선하는 국제 표준 | 공식 명칭: ISO/IEC 15504 | . 5. SPICE의 구성 . 고객-공급자 프로세스 소프트웨어를 개발하여 고객에게 전달하는 것을 지원 | SW의 정확한 운용 및 사용을 위한 프로세스로 구성 | 구성 요소: 인수, 공급, 요구 도출, 운영 | 프로세스 수: 10개 | . | 공학 프로세스 시스템과 소프트웨어 제품의 명세화, 구현, 유지보수를 하는데 사용되는 프로세스로 구성 | 구성 요소: 개발, 소프트웨어 유지보수 | 프로세스 수: 9개 | . | 지원 프로세스 다른 프로세스에 의해 이용되는 프로세스로 구성 | 구성 요소: 문서화, 형상, 품질 보증, 검증, 확인, 리뷰, 감사, 품질 문제 해결 | 프로세스 수: 8개 | . | 관리 프로세스 프로젝트 관리자에 의해 사용되는 프로세스로 구성 | 구성 요소: 관리, 프로젝트 관리, 품질 및 위험 관리 | 프로세스 수: 4개 | . | 조직 프로세스 조직의 업무 목적 수립과 조직의 업무 목표 달성을 위한 프로세스로 구성 | 구성 요소: 조직 배치, 개선 활동 프로세스, 인력 관리, 기반 관리, 측정 도구, 재사용 | 프로세스 수: 9개 | . | . 6. SPICE의 프로세스 수행 능력 단계 . 불완전-수행-관리-확립-예측-최적화 . 불완전: 프로세스가 구현되지 않았거나 목적을 달성하지 못한 단계 | 수행: 프로세스가 수행되고 목적이 달성된 단계 | 관리: 정의된 자원의 한도 내에서 그 프로세스가 작업 산출물을 인도하는 단계 | 확립: 소프트웨어 공학 원칙에 기반하여 정의된 프로세스가 수행되는 단계 | 예측: 프로세스가 목적 달성을 위해 통제되고, 양적인 측정을 통해서 일관되게 수행되는 단계 | 최적화: 프로세스 수행을 최적화하고, 지속적인 개선을 통해 업무 목적을 만족시키는 단계 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/03/28/theory28.html",
            "relUrl": "/theory/2021/03/28/theory28.html",
            "date": " • Mar 28, 2021"
        }
        
    
  
    
        ,"post191": {
            "title": "소프트웨어 개발 방법론 결정",
            "content": "1. 소프트웨어 개발 방법론 결정 . 프로젝트 관리와 재사용 현황을 소프트웨어 개발 방법론에 반영하고, 확정된 소프트웨어 생명 주기와 개발 방법론에 맞춰 소프트웨어 개발 단계, 활동, 작업, 절차 등을 정의하는 것임 | . 프로젝트 관리와 재사용 현황을 소프트웨어 개발 방법론에 반영 | 개발 단계별 작업 및 절차를 소프트웨어 생명 주기에 맞춰 수립 | 결정된 sw 개발 방법론의 개발 단계별 활동 목적, 작업 내용, 산출물에 대한 메뉴얼을 작성 | 2. 프로젝트 관리(Project Management) . 주어진 기간 내에 최소의 비용으로 사용자를 만족시키는 시스템을 개발하기 위한 전반적인 활동 . 일정 관리: 작업 순서, 작업 기간 산정, 일정 개발, 일정 통제 | 비용 관리: 비용 산정, 비용 예산 편성, 비용 통제 | 인력 관리: 프로젝트 팀 편성, 자원 산정, 프로젝트 조직 정의, 프로젝트 팀 개발, 자원 통제, 프로젝트 팀 관리 | 위험 관리: 위험 식별, 위험 평가, 위험 대처, 위험 통제 | 품질 관리: 품질 계획, 품질 보증 수행, 품질 통제 수행 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/03/27/theory27.html",
            "relUrl": "/theory/2021/03/27/theory27.html",
            "date": " • Mar 27, 2021"
        }
        
    
  
    
        ,"post192": {
            "title": "프로젝트 일정 계획",
            "content": "1. 프로젝트 일정 계획 . 프로젝트의 프로세스를 이루는 소작업을 파악하고 예측된 노력을 각 소작업에 분배하여 소작업의 순서와 일정을 정하는 것 | 사용되는 기능: WBS, PERT/CPM, 간트 차트 | . 2. PERT(Program Evaluation and Review Technique, 프로그램 평가 및 검토 기술) . 프로젝트에 필요한 전체 작업의 상호 관계를 표시하는 네트워크 | 각 작업별로 다음과 같이 단계를 나누어 종료 결정 낙관적인 경우 | 가능성이 있는 경우 | 비관적인 경우 | . | 개발 경험이 없어 소요 기간 예측이 어려운 프로젝트 일정 계획에 사용 | 노드와 간선으로 구성되며 원 노드에는 작업을, 간선에는 낙관치, 기대치, 비관치 표시 | 결정 경로, 작업에 대한 경계 시간, 작업 간의 상호 관련성 등을 알 수 있음 | . 작업 예측치 = (비관치+ 4*기대치 + 낙관치) / 6 . 평방 편차 = [(비관치-낙관치) / 6]^2 . 3. CPM(Critical Path Method, 임계 경로 기법) . 프로젝트 완성에 필요한 작업을 나열하고 작업에 필요한 소요 기간을 예측하는데 사용하는 기법 | 노드와 간선으로 구성된 네트워크로 노드는 작업, 간선은 작업 사이의 전후 의존 관계 나타냄 | 원형 노드는 각각의 작업을 의미하며, 작업 이름과 소요 기간 표시 | 박스 노드는 이정표를 의미하며, 이정표 이름과 예상 완료 시간 표시 | 간선을 나타내는 화살표의 흐름에 따라 각 작업 진행. 전 작업이 완료되어야 다음 작업 진행 가능 | 임계 경로: 제시된 그림에서 굵은 선(최장 경로) | . 4. 간트 차트 . 프로젝트의 각 작업들이 언제 시작하고 언제 종료되는지에 대한 작업 일정을 막대 도표를 이용하여 표시하는 프로젝트 일정표 | 시간선 차트라고도 함 | 중간 목표 미달성 시 그 이유와 기간을 예측할 수 있게 함 | 사용자와의 문제점이나 예산의 초과 지출 등도 관리 | 자원 배치와 인원 게획에 유용하게 사용됨 | 이정표, 작업 일정, 작업 기간, 산출물로 구성 | 수평 막대의 길이는 각 작업의 기간 | . -낙관치: 모든 상황이 좋아 최대로 빨리 진행될 때 걸리는 시간 . -기대치: 모든 상황이 정상적으로 진행될 때 걸리는 시간 . -비관치: 모든 상황에 장애가 생겨 가장 늦게 진행될 때 걸리는 시간 .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/03/26/theory26.html",
            "relUrl": "/theory/2021/03/26/theory26.html",
            "date": " • Mar 26, 2021"
        }
        
    
  
    
        ,"post193": {
            "title": "수학적 산정 기법",
            "content": "1. 수학적 산정 기법 . 상향식 비용 산정 기법으로, 경험적 추정 모형, 실험적 추정 모형이라고도 함 . | 개발 비용 산정의 자동화를 목표로 함 . | 사용되는 공식은 과거의 유사한 프로젝트를 기반으로 유도된 것 . COCOMO(COnstructive COst MOdel) 모형 . Putnam 모형 . 기능 점수(FP) 모형 . | . 2. COCOMO 모형 . 원시 프로그램의 규모인 LOC(원시 코드 라인 수)에 의한 비용 산정 기법 | 개발할 소프트웨어의 규모를 예측한 후 이를 소프트웨어 종류에 따라 다르게 책정되는 비용 산정 방정식에 대입하여 비용을 산정함 | 비용 산정 결과는 프로젝트를 완성하는 데 필요한 노력(Man-Month)로 나타남 | 보헴(Bohem)이 제안 | . 3. COCOMO의 소프트웨어 개발 유형 . 조직형(Organic Mode) 기관 내부에서 개발된 중.소규모의 소프트웨어 | 일괄 자료 처리나 과학기술 계산용, 비즈니스 자료 처리용 등의 ` 5만 라인 이하`의 SW 개발 | 사무 처리용, 업무용, 과학용 응용 소프트웨어 개발에 적합 | . | 반분리형(Semi-Detached Mode) 조직형과 내장형의 중간형 | 트랜잭션 처리 시스템이나 운영체제, 데이터베이스 관리 시스템 등의 30만 라인 이하의 SW 개발 | 컴파일러, 인터프리터와 같은 유틸리티 개발에 적합 | . | 내장형(Embedded Mode) 초대형 규모 | 트랜잭션 처리 시스템이나 운영체제 등의 30만 라인 이상의 SW 개발 | 신호기 제어 시스템, 미사일 유도 시스템, 실시간 처리 시스템 등의 시스템 프로그램 개발에 적합 | . | . 4. COCOMO 모형의 종류 . 기본형(Basic) COCOMO . SW의 크기와 개발 유형만을 이용하여 비용 산정 | . | 중간형(Intermediate) COCOMO . 기본형 COCOMO 공식을 토대로 사용하나 아래 4가지 특성에 의해 비용 산정 . 제품의 특성 . 컴퓨터의 특성 . 개발 요원의 특성 . 프로젝트 특성 . | . | 발전형(Detailed) COCOMO . 중간형 COCOMO를 보완하여 만들어진 모형 | 개발 공정별로 보다 자세하고 정확하게 노력 산출하여 비용 산정 | 소프트웨어 환경과 구성 요소가 사전에 정의되어 있어야 하며 개발 과정의 후반부에 주로 적용 | . | . 5. Putnam 모형 . 소프트웨어 생명 주기의 전 과정 동안에 사용될 노력의 분포를 예상하는 모형 | 푸트남이 제안한 것으로, 생명 주기 예측 모형이라고도 함 | 시간에 따른 함수로 표현되는 Rayleigh-Norden 곡선의 노력 분포도를 기초로 함 | 대형 프로젝트의 노력 분포 산정에 이용 | 개발 기간이 늘어날수록 프로젝트 적용 인원의 노력 감소 | . 6. 기능 점수(FP, Function Point) 모형 . 소프트웨어의 기능을 증대시키는 요인별로 가중치를 부여하고 가중치를 합산하여 총 기능 점수 산출하며, 총 기능 점수와 영향도를 이용하여 기능 점수(FP)를 구한 후 이를 이용해 비용 산정하는 기법 | 알브레히트가 제안 | 소프트웨어 기능 증대 요인 자료 입력(입력 양식) | 정보 출력(출력 보고서) | 명령어(사용자 질의수) | 데이터 파일 | 필요한 외부 루틴과의 인터페이스 | . | . 7. 비용 산정 자동화 추정 도구 . SLIM Rayleigh-Norden 곡선과 Putnam 예측 모델을 기초로 하여 개발된 자동화 추정 도구 | . | ESTIMACS 다양한 프로젝트와 개인별 요소를 수용하도록 FP 모형을 기초로 하여 개발된 자동화 추정 도구 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/03/25/theory25.html",
            "relUrl": "/theory/2021/03/25/theory25.html",
            "date": " • Mar 25, 2021"
        }
        
    
  
    
        ,"post194": {
            "title": "상향식 비용 산정 기법",
            "content": "1. 상향식 비용 산정 기법 . 프로젝트의 세부적인 작업 단위별로 비용을 산정한 후 집계하여 전체 비용을 산정하는 방법 | . LOC(원시 코드 라인 수, source Line Of Code) 기법 . 개발 단계별 인월수(Effort per Task) 기법 . 수학적 산정 기법 . 2. LOC 기법 . 소프트웨어 각 기능의 원시 코드 라인 수의 비관치, 낙관치, 기대치를 측정하여 예측치를 구하고 이를 이용하여 비용을 산정하는 기법 | 측정 용이, 이해하기 쉬워 가장 많이 사용 | 예측치를 이용하여 생산성, 노력, 개발 기간 등의 비용 산정 | . 예측치 = (a+4m+b)/6 *a=낙관치, b=비관치, m=기대치(중간치) . 산정 공식 노력(인월) = 개발 기간 * 투입 인원 = LOC / 1인당 월평균 생산 코드 라인 수 | 개발 비용 = 노력(인월) * 단위 비용(1인당 월평균 인건비) | 개발 기간 = 노력(인월) /투입 인원 | 생산성 = LOC / 노력(인월) | . | ex. LOC 기법에 의하여 예측된 총 라인 수가 30000라인, 개발에 참여할 프로그래머가 5명, 프로그래머들의 평균 생산성이 월간 300라인일 때 개발에 소요되는 기간은? 노력(인월) = LOC/1인당 월평균 생산 코드 라인 수 = 30000/300=100명 | 개발 기간 = 노력(인월)/투입 인원 = 100/5 = 20개월 | . | . 3. 개발 단계별 인원수 기법 . LOC 기법을 보완하기 위한 기법으로, 각 기능을 구현시키는 데 필요한 노력을 생명 주기의 각 단계별로 산정함 | LOC 기법보다 더 정확함 | . 비관치, 낙관치, 기대치 . 비관치: 가장 많이 측정된 코드 라인 수 | 낙관치: 가장 적게 측정된 코드 라인 수 | 기대치: 측정된 모든 코드 라인 수의 평균 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/03/24/theory24.html",
            "relUrl": "/theory/2021/03/24/theory24.html",
            "date": " • Mar 24, 2021"
        }
        
    
  
    
        ,"post195": {
            "title": "하향식 비용 산정 기법",
            "content": "1. 하향식 비용 산정 기법 . 과거의 유사한 경험을 바탕으로 전문 지식이 많은 개발자들이 참여한 회의를 통해 비용을 산정하는 비과학적인 방법 | 전체 비용을 선정한 후 각 작업별 비용 세분화 | . 전문가 감정 기법 . 델파이 기법 . 2. 전문가 감정 기법 . 조직 내에 있는 경험 많은 두 명 이상의 전문가에게 비용 산정을 의뢰하는 기법 | 가장 편리하고 신속하게 비용 산정 | 의뢰자로부터 믿음을 얻을 수 있음 | 개인적이고 주관적 | . 3. 델파이 기법 . 전문가 감정 기법의 주관적인 편견을 보완하기 위해 많은 전문가의 의견을 종합하여 산정하는 기법 | 편견, 분위기에 지배되지 않도록 한 명의 조정자와 여러 전문가로 구성 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/03/23/theory23.html",
            "relUrl": "/theory/2021/03/23/theory23.html",
            "date": " • Mar 23, 2021"
        }
        
    
  
    
        ,"post196": {
            "title": "비용 산정 기법",
            "content": "1. 소프트웨어 비용 산정 . 개발에 소요되는 인원, 자원, 기간 등으로 소프트웨어의 규모를 확인하여 개발 계획 수립에 필요한 비용을 산정하는 것 | 비용 너무 높게 산정할 경우 예산 낭비와 일의 효율성 저하 초래 | 비용 너무 낮게 산정할 경우 개발자의 부담이 가중되고 품질 문제 발생 | 하향식 비용 산정 기법, 상향식 비용 산정 기법 | . 2. 소프트웨어 비용 결정 요소 . 프로젝트 요소 제품 복잡도: 소프트웨어 종류에 따라 발생할 수 있는 문제점 난이도 | 시스템 크기: 소프트웨어의 규모에 따라 개발해야 할 시스템의 크기 | 요구되는 신뢰도: 일정 기간 내 주어진 조건 하에서 프로그램이 필요한 기능을 수행하는 정도 | . | 자원 요소 인적 자원: 소프트웨어 개발 관련자들이 갖춘 능력 혹은 자질 | 하드웨어 자원: 개발 시 필요한 장비와 워드프로세서, 프린터 등의 보조 장비 | 소프트웨어 자원: 필요한 언어 분석기, 문서화 도구 등의 개발 지원 도구 | . | 생산성 요소 개발자 능력: 개발자들이 갖춘 전문지식, 경험, 이해도, 책임감, 창의력 등 | 개발 기간: 소프트웨어 개발 기간 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/03/22/theory22.html",
            "relUrl": "/theory/2021/03/22/theory22.html",
            "date": " • Mar 22, 2021"
        }
        
    
  
    
        ,"post197": {
            "title": "S/W 공학의 발전적 추세",
            "content": "1. 소프트웨어 재사용(Software Reuse) . 이미 개발되어 인정받은 소프트웨어를 다른 소프트웨어 개발이나 유지에 사용하는 것 | 소프트웨어 개발의 품질과 생산성을 높이기 위한 방법 | 기존에 개발된 소프트웨어와 경험, 지식 등을 새로운 소프트웨어에 적용함 | 합성 중심(Composition-Based) : 전자 칩과 같은 소프트웨어 부품, 즉 블록을 만들어서 끼워 맞춰 소프트웨어를 완성시키는 방법. 블록 구성 방법이라고도 함 | 생성 중심(Generation-Based) : 추상화 형태로 써진 명세를 구체화하여 프로그램을 만드는 방법. 패턴 구성 방법이라고도 함 | . 2. 소프트웨어 재공학 . 새로운 요구에 맞도록 기존 시스템을 이용하여 보다 나은 시스템을 구축하고, 새로운 기능을 추가하여 소프트웨어 성능을 향상시키는 것 | 유지보수 비용이 소프트웨어 개발 비용의 대부분을 차지하기 때문에 유지보수의 생산성 향상을 통해 소프트웨어 위기를 해결하는 방법 | 기존 소프트웨어의 데이터와 기능들의 개조 및 개선을 통해 유지보수성과 품질을 향상 | 소프트웨어 재공학의 이점 품질 향상 | 생산성 증가 | 수명 연장 | 오류 감소 | . | . 3. CASE(Computer Aided Software Engineering) . 소프트웨어 개발 과정에서 사용되는 요구 분석, 설계, 구현, 검사 및 디버깅 과정 전체 또는 일부를 컴퓨터와 전용 소프트웨어 도구를 사용하여 자동화하는 것 | 객체지향 시스템, 구조적 시스템 등 다양한 시스템에서 활용되는 자동화 도구 | 소프트웨어 생명 주기의 전체 단계를 연결하고 자동화하는 통합된 도구 제공 | 소프트웨어 개발 도구와 방법론이 결합. 정형화된 구조 및 방법을 소프트웨어 개발에 적용하여 생산성 향상을 구현 | CASE의 주요 기능 소프트웨어 생명 주기 전 단계의 연결 | 다양한 소프트웨어 개발 모형 지원 | 그래픽 지원 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/03/20/theory21.html",
            "relUrl": "/theory/2021/03/20/theory21.html",
            "date": " • Mar 20, 2021"
        }
        
    
  
    
        ,"post198": {
            "title": "소프트웨어 개발 방법론",
            "content": "1. 소프트웨어 개발 방법론 . 소프트웨어 개발, 유지보수 등에 필요한 여러 가지 일들의 수행 방법과 이러한 일들을 효율적으로 수행하려는 과정에서 필요한 각종 기법 및 도구를 체계적으로 정리하여 표준화한 것 . | 목적: 소프트웨어의 생산성과 품질 향상 | 주요 소프트웨어 개발 방법론 구조적 방법론 | 정보공학 방법론 | 객체지향 방법론 | 컴포넌트 기반(CBD) 방법론 | 제품 계열 방법론 | 애자일 방법론 | . | . 2. 구조적 방법론 . 정형화된 분석 절차에 따라 사용자 요구사항을 파악하여 문서화하는 처리 중심의 방법론 | 1960년대까지 가장 많이 적용 | 쉬운 이해 및 검증이 가능한 프로그램 코드를 생성하는 것이 목적 | 복잡한 문제를 다루기 위해 분할과 정복 원리 적용 | . 타당성 검토-&gt;계획-&gt;요구사항-&gt;설계-&gt;구현-&gt;시험-&gt;운용/유지보수 . 3. 정보공학 방법론 . 정보 시스템의 개발을 위해 계획, 분석, 설계, 구축에 정형화된 기법들을 통합 및 적용하는 자료 중심의 방법론 | 정보 시스템 개발 주기를 이용해 대규모 정보 시스템을 구축하는데 적합함 | . 정보 전략 계획 수립-&gt;업무 영역 분석-&gt;업무 시스템 설계-&gt;업무 시스템 구축 . 4. 객체지향 방법론 . 현실 세계의 개체(Entity)를 기계의 부품처럼 하나의 객체(Object)로 만들어 기계의 부품을 조립하듯이 객체들을 조립해서 필요한 소프트웨어를 구현하는 방법론 | 구조적 기법의 문제점으로 인한 소프트웨어 위기의 해결책으로 채택 | 구성 요소: 객체, 클래스, 메세지 | 기본 원칙: 캡슐화, 정보 은닉, 추상화, 상속성, 다형성 | . 요구 분석-&gt;설계-&gt;구현-&gt;테스트 및 검증-&gt;인도 . 5. 컴포넌트 기반(CBD: Component Based Design) 방법론 . 기존 시스템이나 소프트웨어를 구성하는 컴포넌트들을 조합하여 하나의 새로운 애플리케이션을 만드는 방법론 | 컴포넌트의 재사용이 가능-&gt;시간, 노력 절감 | 새로운 기능 간단하게 추가 가능 -&gt; 확장성 보장 | 유지 보수 비용 최소화, 생산성 및 품질 향상 | . 개발 준비-&gt;분석-&gt;설계-&gt;구현-&gt;테스트-&gt;전개-&gt;인도 . 6. 제품 계열 방법론 . 특정 제품에 적용하고 싶은 공통된 기능을 정의하여 개발하는 방법론 | 임베디드 소프트웨어를 만드는데 적합함 영역 공학: 영역 분석, 영역 설계, 핵심 자산을 구현 | 응용 공학: 제품 요구 분석, 제품 설계, 제품을 구현 | . | 영역 공학과 응용 공학의 연계를 위해 제품의 요구사항, 아키텍처, 조립 생산이 필요 | . 객체, 클래스, 메시지 . 객체: 데이터와 데이터를 처리하는 함수를 묶어 놓은 하나의 sw 모듈 | 클래스: 공통된 속성과 연산을 갖는 객체의 집합으로 객체의 일반적 타입 | 메시지: 객체들 간에 상호작용을 하는 데 사용되는 명령 또는 요구 사항 | . 캡슐화, 정보은닉, 추상화, 상속성, 다형성 . 캡슐화: 데이터와 데이터를 처리하는 함수를 하나로 묶는 것 | 정보 은닉: 다른 객체에게 자신의 정보를 숨기고 자신의 연산만을 통해 접근을 허용하는 것 | 추상화: 불필요한 부분을 생략하고 객체의 속성 중 가장 중요한 것에 중점을 두어 개략화하는 것 | 상속성: 이미 정의된 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것 | 다형성: 메시지에 의해 객체가 연산을 수행하게 될 때 하나의 메시지에 대해 각 객체가 가지고 있는 고유한 방법으로 응답할 수 있는 능력 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/03/20/theory20.html",
            "relUrl": "/theory/2021/03/20/theory20.html",
            "date": " • Mar 20, 2021"
        }
        
    
  
    
        ,"post199": {
            "title": "패키지 다이어그램",
            "content": "1. 패키지 다이어그램 . 유스케이스나 클래스 등의 요소들을 그룹화한 패키지 간의 의존 관계를 표현한 것임 | 패키지는 또 다른 패키지의 요소가 될 수 있음 | 대규모 시스템에서 주요 요소 간의 종속성을 파악하는 데 사용함 | . 2. 패키지 다이어그램의 구성 요소 . 다음은 회원이 상품 주문 시 패키지들 간의 의존 관계를 표현한 패키지 다이어그램임 | . . 패키지 구성 설명 , , , 패키지가 존재함 | 패키지는 과 패키지를 포함하고 있음 | 패키지는 &#39;결제 인증&#39;과 &#39;환불&#39; 객체를 포함하고 있음 | . | 의존 관계 설명 과 패키지 간의 의존 관계 패키지는 주문자를 확인하기 위해 패키지를 이용함 | «import» 관계이므로 패키지에 포함된 객체들을 직접 가져와서 이용할 수 있는 관계임 | . | 패키지와 패키지의 &#39;결제 인증&#39; 객체와 의존 관계 패키지는 주문된 상품의 결제를 위해 패키지의 &#39;결제 인증&#39; 객체를 이용함 | «access» 관계이므로 인터페이스를 통해 접근하여 이용할 수 있는 관계임 | . | . | . 구성 요소 표현 방법 의미 . 패키지 | | - 객체들을 그룹화한 것- 단순 표기법: 패키지 안에 패키지 이름만 표현- 확장 표기법: 패키지 안에 요소까지 표현 | . 객체 | | 유스케이스, 클래스, 인터페이스, 테이블 등 패키지에 포함될 수 있는 다양한 요소들 | . 의존 관계 | | - 패키지와 패키지, 패키지와 객체 간을 점선 화살표로 연결하여 표현함- 스테레오타입을 이용해 의존 관계를 구체적으로 표현할 수 있음- 의존 관계의 표현 형태는 사용자가 임의로 작성할 수 있으며, 대표적으로 import와 access가 사용됨- «import»: 패키지에 포함된 객체들을 직접 가져와서 이용하는 관계- «access»: 인터페이스를 통해 패키지 내의 객체에 접근하여 이용하는 관계 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/03/19/theory19.html",
            "relUrl": "/theory/2021/03/19/theory19.html",
            "date": " • Mar 19, 2021"
        }
        
    
  
    
        ,"post200": {
            "title": "상태 다이어그램",
            "content": "1. 상태 다이어그램 . 객체들 사이에 발생하는 이벤트에 의한 객체들의 상태 변화를 그림으로 표현한 것 | 객체의 상태란 객체가 갖는 속성 값의 변화를 의미함 | 특정 객체가 어떤 이벤트에 의해 상태 변환 과정이 진행되는지 확인하는 데 사용됨 | 시스템에서 상태 변환 이벤트를 확인할 필요가 있는 객체만을 대상으로 그림 | . 2. 상태 다이어그램의 구성 요소 . 다음은 상품결제 객체의 상태 변화를 표현한 상태 다이어그램임 | . . 상태의 상태 변화 결제 과정이 시작되면 객체는 상태로 전환됨 | ‘결제정보 입력’ 이벤트에 의해 상태로 전환됨 | . | 상태의 상태 변화 ‘결제정보 입력’ 이벤트에 의해 상태로 전환됨 | ‘결제정보 일치’ 이벤트에 의해 상태로 전환됨 | ‘결제정보 불일치’ 이벤트에 의해 상태로 전환됨 | . | 상태의 상태 변화 ‘결제정보 불일치’ 이벤트에 의해 상태로 전환됨 | ‘결제 재시도’ 이벤트에 의해 상태로 전환됨 | . | 상태의 상태 변화 ‘결제정보 일치’ 이벤트에 의해 상태로 전환됨 | . | . 구성 요소 표현 방법 의미 . 상태 | | 객체의 상태를 표현한 것 | . 시작 상태 | | 상태의 시작을 표현한 것 | . 종료 상태 | | 상태의 종료를 표현한 것 | . 상태 전환 | | 상태 사이의 흐름, 변화를 화살표로 표현한 것 | . 이벤트 | | - 상태에 변화를 주는 현상- 이벤트에는 조건, 외부 신호, 시간의 흐름 등이 있음 | . 프레임 | | 상태 다이어그램의 범위를 표현한 것 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/03/18/theory18.html",
            "relUrl": "/theory/2021/03/18/theory18.html",
            "date": " • Mar 18, 2021"
        }
        
    
  
    
        ,"post201": {
            "title": "커뮤니케이션 다이어그램",
            "content": "1. 커뮤니케이션 다이어그램 . 시스템이나 객체들이 메시지를 주고받으며 상호작용하는 과정과 객체들 간의 연관을 그림으로 표현한 것임 | 동작에 참여하는 객체들 사이의 관계를 파악하는 데 사용됨 | 클래스 다이어그램에서 관계가 제대로 표현됐는지 점검하는 용도로도 사용됨 | 초기에는 협업 다이어그램이라고도 불렸음 | . 2. 커뮤니케이션 다이어그램의 구성 요소 . 다음은 회원의 상품 주문 과정을 표현한 커뮤니케이션 다이어그램임 | . . 상품 주문 과정에서 상호 작용하는 객체들 간의 관계 | 액터는 , , &lt;신발 : 신규주문&gt;, &lt;카드 : 결제화면&gt; 객체와 관계되어 있음 | 객체는 객체와 관계되어 있음 | 객체는 &lt;신발 : 신규주문&gt; 객체와 관계되어 있음 | &lt;신발 : 신규주문&gt; 객체는 시스템과 관계되어 있음 | &lt;카드 : 결제화면&gt; 객체는 시스템과 관계되어 있음 | . 구성 요소 표현 방법 의미 . 액터 | | 시스템으로부터 서비스를 요청하는 외부 요소로, 사람이나 외부 시스템을 의미함 | . 객체 | | 메시지를 주고받는 주체 | . 링크 | | - 객체들 간의 관계를 표현한 것- 액터와 객체, 객체와 객체 간에 실선을 그어 표현함 | . 메시지 | | - 객체가 상호 작용을 위해 주고받는 내용- 화살표의 방향은 메시지를 받는 쪽으로 향하게 표현함- 일정한 순서에 의해 처리되는 메시지의 경우 숫자로 순서를 표시함 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/03/16/theory17.html",
            "relUrl": "/theory/2021/03/16/theory17.html",
            "date": " • Mar 16, 2021"
        }
        
    
  
    
        ,"post202": {
            "title": "시퀀스 다이어그램",
            "content": "1. 동적 모델링 . 시스템의 내부 구성 요소들의 상태 변화 과정과 과정에서 발생하는 상호 작용을 표현한 것임 | 시스템 내부 구성 요소들 간에 이루어지는 동작이라는 관점에서 표현함 | 시스템이 실행될 때 구성 요소들 간의 메시지 호출, 즉 오퍼레이션을 통한 상호 작용에 초점을 둠 | 동적 모델링의 종류 시퀀스 다이어그램 | 커뮤니케이션 다이어그램 | 상태 다이어그램 | . | . 2. 시퀀스 다이어그램 . 시스템이나 객체들이 메시지를 주고받으며 상호 작용하는 과정을 그림으로 표현한 것 | 시스템이나 객체들의 상호 작용 과정에서 주고받는 메시지를 표현함 | 각 동작에 참여하는 시스템이나 객체들의 수행 기간을 확인할 수 있음 | 클래스 내부에 있는 객체들을 기본 단위로 하여 그들의 상호 작용을 표현함 | . 3. 시퀀스 다이어그램의 구성 요소 . 다음은 회원의 상품 주문 과정에 재고 시스템과 결제 시스템이 관계되어 상호 작용하는 과정을 표현한 시퀀스 다이어그램임 . . | 액터 로그인 버튼을 클릭한다 | ID와 비밀번호를 입력한다 | 로그인이 완료되면 상품 선택 화면에서 주문할 상품을 선택한다 | 주문할 상품에 대한 재고 확인이 완료되면 결제 화면에서 결제 정보를 입력한다 | 결제가 완료되어 “결제 및 주문 완료” 메시지를 확인한 후 소멸됨 | . | 객체 으로부터 입력받은 ID와 비밀번호가 올바른지 객체에게 확인을 요청함 | “로그인 완료” 메시지를 받으면 에게 상품 선택 화면을 출력한 후 소멸됨 | . | 객체 입력받은 ID와 비밀번호를 확인함 | “로그인 완료” 메시지를 전송한 후 소멸됨 | . | 객체 이 주문할 상품을 선택하면 선택된 상품에 대한 &lt;신발 : 신규주문&gt; 객체를 생성한 후 소멸됨 | . | &lt;신발 : 신규주문&gt; 객체 “주문생성” 메시지를 받으면 새로운 객체로 생성됨 | 에게 주문한 상품에 대한 재고 확인을 요청함 | “재고 있음” 메시지를 받으면 에게 결제 화면을 출력한 후 소멸됨 | . | &lt;카드 : 결제화면&gt; 객체 이 결제 정보를 입력하면 에게 결제 정보 확인을 요청함 | “결제 승인” 메시지를 받으면 에게 &quot;결제 및 주문 완료&quot; 메시지를 전송한 후 소멸됨 | . | 액터 이 주문한 상품에 대한 재고를 확인함 | &lt;신발 : 신규주문&gt; 객체에게 “재고 있음” 메시지를 전송한 후 소멸됨 | . | 액터 이 입력한 결제 정보를 확인함 | &lt;카드 : 결제화면&gt;에게 “결제 승인” 메시지를 전송한 후 소멸됨 | . | . 구성 요소 표현 방법 의미 . 액터 | | 시스템으로부터 서비스를 요청하는 외부 요소로, 사람이나 외부 시스템을 의미함 | . 객체 | | 메시지를 주고받는 주체 | . 생명선 | | - 객체가 메모리에 존재하는 기간으로, 객체 아래쪽에 점선을 그어 표현함- 객체 소멸(X)이 표시된 기간까지 존재함 | . 실행 상자(활성 상자) | | 객체가 메시지를 주고받으며 구동되고 있음을 표현함 | . 메시지 | | 객체가 상호 작용을 위해 주고받는 메시지 | . 객체 소멸 | | 해당 객체가 더 이상 메모리에 존재하지 않음을 표현한 것 | . 프레임 | | 다이어그램의 전체 또는 일부를 묶어 표현한 것 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/03/16/theory16.html",
            "relUrl": "/theory/2021/03/16/theory16.html",
            "date": " • Mar 16, 2021"
        }
        
    
  
    
        ,"post203": {
            "title": "클래스 다이어그램",
            "content": "1. 정적 모델링 . 사용자가 요구한 기능을 구현하는데 필요한 자료들의 논리적인 구조를 표현한 것 | 시스템에 의해 처리되거나 생성될 객체들 사이에 어떤 관련이 있는지를 구조적인 관점에서 표현함 | 정적 모델링은 객체들을 클래스로 추상화하여 표현함 | UML을 이용한 정적 모델링의 대표적인 것이 클래스 다이어그램임 | . 2. 클래스 다이어그램 . 클래스와 클래스가 가지는 속성, 클래스 사이의 관계를 표현한 것 | 시스템을 구성하는 요소에 대해 이해할 수 있는 구조적 다이어그램임 | 시스템 구성 요소를 문서화하는 데 사용됨 | . 3. 클래스 다이어그램의 구성 요소 . 다음은 프로야구 리그에 필요한 정보의 일부를 표현한 클래스 다이어그램임 | . . 리그에는 10개의 팀이 참가한다 . . | 리그는 한 개 이상의 경기장에서 경기가 진행된다 . . | 매 경기는 두 팀이 진행하며, 두 팀은 한 번 이상의 경기를 진행한다 . . | 한 팀에는 한 명 이상의 선수가 있다 . . | 한 경기장에서는 한 경기 이상이 진행되며, 경기는 여러 경기장에서 진행된다 . . | 한 팀에서 최소 9명 이상의 선수가 한 경기에 출전하며, 경기에 출전하지 못하는 선수도 있고 여러 경기에 출전하는 선수도 있다 . . | 선수는 주전선수와 후보선수가 있다 . | 선수의 경력은 0보다 큰 값이 입력되어야 한다 . | 승점이 5 이상인 선수들은 연봉을 조정할 수 있으며, 연봉은 승점만큼 증가한다 . | . 구성 요소 표현 방법 내용 . 클래스 | | - 각가의 객체들이 갖는 속성과 오퍼레이션(동작)을 표현한 것- 일반적으로 3개의 구획으로 나눠 클래스의 이름, 속성, 오퍼레이션을 표기함- 속성(Attribute): 클래스의 상태나 정보를 표현함- 오퍼레이션(Operation): 클래스가 수행할 수 있는 동작으로, 함수라고도 함 | . 제약조건 | | - 속성에 입력될 값에 대한 제약조건이나 오퍼레이션 수행 전후에 지정해야 할 조건이 있다면 이를 적음- 클래스 안에 제약조건을 기술할 때는 중괄호 { } 를 이용함 | . 관계(Relationships) |   | - 관계는 클래스와 클래스 사이의 연관성을 표현함- 클래스 다이어그램에 표현하는 관계에는 연관 관계, 집합 관계, 포함 관계, 일반화 관계, 의존 관계가 있음 | . 4. 연관 클래스 . 연관 관계에 있는 두 클래스에 추가적으로 표현해야 할 속성이나 오퍼레이션이 있는 경우 생성하는 클래스임 | 두 클래스의 연관 관계를 나타내는 선의 가운데로부터 점선을 연관 클래스로 이어 표시함 | 연관 클래스의 이름은 연관 관계의 이름을 이용해 지정함 | . 팀이 경기에 참여하는 상황에서 참여횟수에 참여결과 속성을 어디에 두어야 할지를 생각해 보자. 먼저 ‘팀’ 클래스에 참여횟수와 참여결과 속성을 둔다면 팀이 어느 경기에 참여한 것인지 모호해짐. 또한 ‘경기’ 클래스에 참여횟수와 참여결과 속성을 둔다면 어느 팀이 참여한 것인지 모호해짐. 이런 경우 ‘팀’이나 ‘경기’ 클래스의 속성이 아닌 ‘참여하다’라는 연관 관계에 대한 연관 클래스를 만들어 ‘참여횟수’와 ‘참여결과’ 속성을 연관 클래스의 속성으로 다루면 됨 . ​ .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/03/14/theory15.html",
            "relUrl": "/theory/2021/03/14/theory15.html",
            "date": " • Mar 14, 2021"
        }
        
    
  
    
        ,"post204": {
            "title": "활동 다이어그램",
            "content": "1. 활동 다이어그램 . 사용자의 관점에서 시스템이 수행하는 기능을 처리 흐름에 따라 순서대로 표현한 것 | 하나의 유스케이스/유스케이스 사이에 발생하는 복잡한 처리의 흐름 명확하게 표현 | 자료 흐름도와 유사 | . 2. 활동 다이어그램의 구성 요소 . 다음은 회원의 상품 주문 과정에 결제 시스템과 재고 시스템이 관계되어 발생하는 처리의 흐름을 표현한 활동 다이어그램임 | . . 액터 회원이 상품을 주문하기 위해 로그인 단추를 클릭한 후 회원 정보를 입력함 | 입력된 정보가 잘못됐으면 회원 정보를 다시 입력받고, 그렇지 않으면 주문 상품 선택으로 이동함 | 회원이 주문할 상품을 선택하면 흐름이 ‘결제 인증’과 ‘상품 재고 확인’으로 분할되어 진행됨 | 상품 주문을 완료하고 액티비티를 종료함 | . | 시스템 주문한 상품에 대한 결제 인증을 진행함 | 인증에 성공하면 ‘주문 완료’로 이동하고, 인증에 실패하면 ‘인증 재시도’로 이동함 | 다시 진행한 결제 인증이 성공하면 ‘주문 완료’로 이동하고, 이번에도 인증이 실패하면 결제 인증에 대한 처리 흐름을 종료함 | . | 시스템 주문한 상품에 대한 재고를 확인함 | 재고가 있으면 액티비티의 흐름을 ‘주문 완료’로 이동하고, 재고가 없으면 회원이 다른 상품을 선택할 수 있도록 ‘주문 상품 선택’으로 이동함 | . | . 구성 요소 표현 방법 내용 . 액션/액티비티 | -액션 -액티비티 | - 액션: 더 이상 분해할 수 없는 단일 작업- 액티비티: 몇 개의 액션으로 분리될 수 있는 작업 | . 시작 노드 | | 액션이나 액티비가 시작됨을 표현한 것 | . 종료 노드 | | 액티비티 안의 모든 흐름이 종료됨을 표현한 것 | . 조건(판단) 노드 | | - 조건에 따라 제어의 흐름이 분리됨을 표현한 것- 들어오는 제어 흐름은 한 개이고 나가는 제어 흐름은 여러 개임 | . 병합 노드 | | - 여러 경로의 흐름이 하나로 합쳐짐을 표현한 것- 들어오는 제어 흐름은 여러 개이고 나가는 제어 흐름은 한 개임 | . 포크 노드 | | - 액티비티의 흐름이 분리되어 수행됨을 표현한 것- 들어오는 액티비티 흐름은 한 개이고 나가는 액티비티 흐름은 여러 개임 | . 조인 노드 | | - 분리되어 수행되던 액티비티의 흐름이 다시 합쳐짐을 표현한 것- 들어오는 액티비티 흐름은 여러 개이고 나가는 액티비티 흐름은 한 개임 | . 스윔레인 | | - 액티비티 수행을 담당하는 주체를 구분하는 선- 가로 또는 세로 실선을 그어 구분함 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/03/14/theory14.html",
            "relUrl": "/theory/2021/03/14/theory14.html",
            "date": " • Mar 14, 2021"
        }
        
    
  
    
        ,"post205": {
            "title": "유스케이스 다이어그램",
            "content": "1. 기능 모델링 . 사용자의 요구사항을 분석하여 개발될 시스템이 갖춰야 할 기능을 정리한 후 사용자와 공유하기 위해 그림으로 표현하는 것 | 개발될 시스템의 전반적인 형태를 기능에 초점을 맞춰 표현 | 기능 모델링의 종류 유스 케이스 다이어그램 | 액티비티 다이어그램 | . | . 2. 유스케이스 다이어그램 . 개발될 시스템을 이용해 수행할 수 있는 기능을 사용자의 관점에서 표현한 것 | 외부 요소와 시스템 간의 상호 작용 확인 가능 | 사용자의 요구사항을 분석하기 위한 도구로 사용됨 | 시스템의 범위 파악 가능 | . 3. 유스케이스 다이어그램의 구성 요소 . . 고객은 회원과 비회원으로 구분된다 | 회원은 상품조회, 상품주문, 배송조회, 리뷰작성 기능을 사용할 수 있다. | 비회원은 상품조회 기능만 사용할 수 있다. | 고객은 이름이나 브랜드로 상품을 조회할 수 있다. | 회원이 상품주문, 배송조회, 리뷰작성 기능을 사용하려면 반드시 로그인을 수행해야 한다. | 회원이 리뷰작성을 할 때 필요한 경우 사진 업로드 기능을 사용할 수 있다. | 회원이 상품주문을 완료하려면 재고 시스템을 통해 재고 여부를 확인해야 한다. | 회원이 상품주문을 완료하려면 결제 시스템을 통해 승인을 얻어야 한다. | 회원은 배송업체를 통해 배송조회를 할 수 있다. | . 구성 요소 표현 방법 내용 . 시스템/시스템 범위 | 사각형 | 시스템 내부의 유스케이스들을 사각형으로 묶어 시스템의 범위를 표현 | . 액터 | -주액터 -부액터 | -시스템과 상호 작용하는 모든 외부 요소-주로 사람이나 외부 시스템을 의미-주액터: 시스템을 사용함으로써 이득을 얻는 대상(주로 사람)-부액터: 주액터의 목적 달성을 위해 시스템에 서비스를 제공하는 외부 시스템(조직, 기관) | . 유스케이스 | 타원 | 사용자가 보는 관점에서 시스템이 액터에게 제공하는 서비스나 기능을 표현한 것 | . 관계 | -포함-확장-일반화 | -액터와 유스케이스, 유스케이스와 유스케이스 사이에서 나타날 수 있음-포함(Include) 관계, 확장(Extends) 관계, 일반화(Generalization) 관계 | . 포함관계 . 두 개 이상의 유스케이스에 공통적으로 적용되는 기능을 별도로 분리하여 새로운 유스케이스로 만든 경우 | 새롭게 만든 포함되는 유스케이스 쪽으로 점선 화살표를 연결한 후 화살표 위에 «include»라고 표기 | . 확장관계 . 유스케이스가 특정 조건에 부합되어 기능이 확장될 때 | 확장될 유스케이스에서 원래의 유스케이스 쪽으로 점선 화살표를 연결한 후 화살표 위에 «extends»라고 표기 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/03/13/theory13.html",
            "relUrl": "/theory/2021/03/13/theory13.html",
            "date": " • Mar 13, 2021"
        }
        
    
  
    
        ,"post206": {
            "title": "UML-다이어그램",
            "content": "1. 다이어그램(Diagram) . 사물과 관계를 도형으로 표현한 것 | 여러 관점에서 시스템을 가시화한 뷰 제공 -&gt; 의사소통에 도움 | 정적 모델링 - 구조적 다이어그램 | 동적 모델링 - 행위 다이어그램 | . 2. 구조적(Structural) 다이어그램(클객컴배복패) . 종류 내용 . 클래스 다이어그램(Class Diagram) | 클래스와 클래스가 가지는 속성, 클래스 사이의 관계 표현 | . 객체 다이어그램(Object Diagram) | -클래스에 속한 사물(객체)들, 즉 인스턴스를 특정 시점의 객체와 객체 사이 관계로 표현-럼바우(Rumbaugh) 객체지향 분석 기법에서 객체 모델링에 활용됨 | . 컴포넌트 다이어그램(Component Diagram) | -실제 구현 모듈인 컴포넌트 간의 관계나 컴포넌트 간의 인터페이스 표현-구현 단계에서 사용 | . 배치 다이어그램(Deployment Diagram) | -결과물, 프로세스, 컴포넌트 등 물리적 요소들의 위치를 표현-구현 단계에서 사용 | . 복합체 구조 다이어그램(Composite Structure Diagram) | 클래스나 컴포넌트가 복합 구조를 갖는 경우 그 내부 구조를 표현 | . 패키지 다이어그램(Package Diagram) | 유스케이스나 클래스 등의 모델 요소들을 그룹화한 패키지들의 관계 표현 | . 3. 행위(Behavioral) 다이어그램의 종류 -동적(유시커상활상타) . 종류 내용 . 유스케이스 다이어그램(Use Case Diagram) | -사용자의 요구를 분석하는 것으로, 기능 모델링 작업에 사용-사용자(Actor)와 사용 사례(Use Case)로 구성 | . 시퀀스 다이어그램(Sequence Diagram) | 상호 작용하는 시스템이나 객체들이 주고받는 메시지를 표현 | . 커뮤니케이션 다이어그램(Communication Diagram) | 동작에 참여하는 객체들이 주고받는 메시지와 객체들 간의 연관 관계를 표현 | . 상태 다이어그램(State Diagram) | -하나의 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호 작용에 따라 상태가 어떻게 변화하는지 표현-럼바우 객체지향 분석 기법에서 동적 모델링에 활용됨 | . 활동 다이어그램(Activity Diagram) | 시스템이 어떤 기능을 수행하는지 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서에 따라 표현 | . 상호작용 개요 다이어그램(Interaction Overview Diagram) | 상호작용 다이어그램 간의 제어 흐름을 표현 | . 타이밍 다이어그램(Timing Diagram) | 객체 상태 변화와 시간 제약을 명시적으로 표현 | . 4. 스테레오 타입(Stereotype) . UML에서 표현하는 기본 기능 외에 추가적인 기능을 표현하는 것 . | 길러멧이라고 부르는 겹화살표(&lt;&lt;&gt;&gt;) 사이에 표현할 형태 기술 . | 표현 형태 의미 . «include» | 연결된 다른 UML 요소에 대해 포함 관계에 있는 경우 | . «extend» | 연결된 다른 UML 요소에 대해 확장 관계에 있는 경우 | . «interface» | 인터페이스를 정의하는 경우 | . «exception» | 예외를 정의하는 경우 | . «constructor» | 생성자 역할을 수행하는 경우 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/03/12/theory12.html",
            "relUrl": "/theory/2021/03/12/theory12.html",
            "date": " • Mar 12, 2021"
        }
        
    
  
    
        ,"post207": {
            "title": "UML-관계(Relationship)",
            "content": "1. 관계(Relationship) . 사물과 사물 사이의 연관성을 표현하는 것 | 관계의 종류 연관 관계 | 집합 관계 | 포함 관계 | 일반화 관계 | 의존 관계 | 실체화 관계 | . | . 2. 연관(Association) 관계 . 2개 이상의 사물이 서로 관련되어 있는 관계 | 실선으로 연결하여 표현 | 화살표로 방향성 표현 | 양방향 관계의 경우 화살표 생략하고 실선으로만 연결 | 다중도를 선 위에 표기 | . 다중도 의미 . 1 | 1개의 객체가 연관되어 있음 | . n | n개의 객체가 연관되어 있음 | . 0..1 | 연관된 객체가 없거나 1개만 존재함 | . 0..* 또는 * | 연관된 객체가 없거나 다수일 수 있음 | . 1..* | 연관된 객체가 적어도 1개 이상 | . n..* | 연관된 객체가 적어도 n개 이상 | . n..m | 연관된 객체가 최소 n개에서 최대 m개임 | . 예제 1) 사람이 집을 소유하는 관계이다. 사람은 자기가 소유하고 있는 집에 대해 알고 있지만 집은 누구에 의해 자신이 소유되고 있는지 모른다는 의미 . 사람1———-&gt;1집 | ‘사람’ 쪽 다중도가 1이므로 집은 한 사람에 의해서만 소유될 수 있음 | ‘집’ 쪽 다중도가 1이므로 사람은 집을 하나만 소유할 수 있음 | . 예제 2) 선생님은 학생을 가르치고 학생은 선생님으로부터 가르침을 받는 것과 같이 선생님과 학생은 서로 관계가 있다. . 선생님1..———1.. 학생 | 선생님 쪽 다중도가 1..*이므로 학생은 한 명 이상의 선생님으로부터 가르침을 받는다. | 학생 쪽 다중도가 1..*이므로 선생님은 한 명 이상의 학생을 가르친다. | . 3. 집합(Aggregation) 관계 . 하나의 사물이 다른 사물에 포함 되어 있는 단계 . | 포함하는 쪽(전체, whole)과 포함되는 쪽(부분, part)이 서로 독립적임 . | 포함되는 쪽(부분)에서 포함하는 쪽(전체)로 속이 빈 마름모를 연결하여 표현 . . | . 4. 포함(Composition) 관계 . 집합 관계의 특수 형태로, 포함하는 사물의 변화가 포함되는 사물에게 영향을 미치는 관계 . | 포함하는 쪽과 포함되는 쪽은 서로 독립될 수 없고 생명주기 함께함 . | 포함되는 쪽(부분)에서 포함하는 쪽(전체)로 속이 채워진 마름모를 연결하여 표현 . ex. 문◆——-키 : 문을 열 수 있는 키는 하나이며, 해당 키로 다른 문은 열 수 없고 문이 없어지면 키도 필요 없다. . | . 5. 일반화(Generalization) 관계 . 하나의 사물이 다른 사물에 비해 더 일반적이거나 구체적인 관계 . | 일반적인 개념을 상위(부모), 구체적인 개념을 하위(자식)라고 부름 . | 구체적(하위)인 사물에서 일반적(상위)인 사물 쪽으로 속이 빈 화살표를 연결하여 표현 . ex. 아메리카노와 에스프레소는 커피이다. . | . 6. 의존(Dependency) 관계 . 연관 관계와 같이 사물 사이에 서로 연관은 있으나 필요에 의해 서로에게 영향을 주는 짧은 시간 동안만 연관을 유지하는 관계 . | 소유 관계는 아니지만 사물의 변화가 다른 사물에도 영향을 미치는 관계 . | 영향을 주는 사물(이용자)이 영향을 받는 사물(제공자) 쪽으로 점선 화살표를 연결하여 표현 . ex. 등급——&gt;할인율 : 등급이 높으면 할인율을 적용하고, 등급이 낮으면 할인율을 적용하지 않는다. . | . 7. 실체화(Realization) 관계 . 실체화 관계는 사물이 할 수 있거나 해야 하는 기능으로, 서로를 그룹화할 수 있는 관계 . | 사물에서 기능 쪽으로 속이 빈 점선 화살표를 연결하여 표현 . ex. 날 수 있다 ◀️—-비행기 : 비행기는 날 수 있고 새도 날 수 있으므로 날 수 있다는 행위로 그룹화 가능 . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/03/11/theory11.html",
            "relUrl": "/theory/2021/03/11/theory11.html",
            "date": " • Mar 11, 2021"
        }
        
    
  
    
        ,"post208": {
            "title": "UML(Unified Modeling Language)의 개요",
            "content": "1. UML(Unified Modeling Language) : 공통된 표현법 . 시스템 분석, 설계, 구현 등 시스템 개발 과정에서 시스템 개발자와 고객 또는 개발자 상호 간의 의사소통이 원활하게 이루어지도록 표준화한 대표적인 객체지향 모델링 언어 | Rumbaugh(OMT), Booch, Jacobason 등의 객체지향 방법론의 장점 통합 | OMG(Object Management Group)에서 표준으로 지정하였음 | UML의 구성 요소 사관다 사물(Things) | 관계(Relationships) | 다이어그램(Diagram) | . | . 2. 사물(객체) . 다이어그램 안에서 관계가 형성될 수 있는 대상 | 모델을 구성하는 가장 중요한 기본 요소 | 사물의 종류 구조 사물(Structural Things) 시스템의 개념적, 물리적 요소 표현 | 클래스, 유스케이스, 컴포넌트, 노드 등 | . | 행동 사물(Behavioral Things) 시간과 공간에 따른 요소들의 행위를 표현 | 상호작용, 상태 머신 등 | . | 그룹 사물(Grouping Things) 요소들을 그룹으로 묶어서 표현 | 패키지 | . | 주해 사물(Annotation Things) 부가적인 `설명이나 제약조건 등을 표현 | 노트 | . | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/03/10/theory10.html",
            "relUrl": "/theory/2021/03/10/theory10.html",
            "date": " • Mar 10, 2021"
        }
        
    
  
    
        ,"post209": {
            "title": "요구사항 분석 CASE와 HIPO",
            "content": "1. 요구사항 분석용 CASE(자동화 도구) . 요구사항을 자동으로 분석하고, 요구사항 분석 명세서 기술하도록 개발된 도구 . sadt -시스템 정의, 요구사항 분석, 시스템/소프트웨어 설계를 위한 도구-SoftTecth 사에서 개발-구조적 요구 분석을 하기 위해 블록 다이어그램을 채택한 자동화 도구 . SREM =RSL/REVS | -TRW 사가 실시간 처리 소프트웨어 시스템에서 요구사항을 명확히 기술하도록 할 목적으로 개발한 도구-RSL과 REVS를 사용하는 자동화 도구 | . PSL/PSA | -PSL과 PSA를 사용하는 자동화 도구-미시간 대학에서 개발 | . TAGS | -시스템 공학 방법 응용에 대한 자동 접근 방법-개발 주기의 전 과정에 이용할 수 있는 통합 자동화 도구 | . | . 2. HIPO(Hierarchy Input Process Output) . 시스템의 분석 및 설계 또는 문서화에 사용되는 기법으로, 시스템 실행 과정인 입력.처리.출력의 기능을 표현한 것 . | 하향식 소프트웨어 개발을 위한 문서화 도구 . | 기능과 자료의 의존 관계 동시에 표현 가능 . | 기호, 도표를 이용하여 보기 쉽고 이해하기 쉬움 . | HIPO Chart: 시스템의 기능을 여러 개의 고유 모듈로 분할하여 이들 간의 인터페이스를 계층 구조로 표현한 것 . 가시적 도표(Visual Table of Contents, 도식 목차) | 총체적 도표(Overview Diagram, 총괄 도표, 개요 도표) | 세부적 도표(Detail Diagram, 상세 도표) | . ​ . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/03/09/theory9.html",
            "relUrl": "/theory/2021/03/09/theory9.html",
            "date": " • Mar 9, 2021"
        }
        
    
  
    
        ,"post210": {
            "title": "요구사항 분석",
            "content": "1. 요구사항 분석 . 소프트웨어 개발의 실제적인 첫 단계 | 개발 대상에 대한 사용자의 요구사항을 이해하고 문서화하는 활동 | 사용자 요구의 타당성을 조사, 비용.일정에 대한 제약 설정 | 사용자 요구를 정확하게 추출하여 목표 정함 | . 2. 구조적 분석 기법 . 자료의 흐름과 처리를 중심으로 하는 요구사항 분석 방법 | 도형 중심의 분석용 도구와 분석 절차를 이용하여 사용자의 요구사항 파악, 문서화 | 하향식 방법(전체-&gt;상세)을 사용하여 시스템을 세분화 | 분석의 중복 배제 | 주요 구조적 분석 기법 도구 자료 흐름도(DFD) | 자료 사전(DD) | 소단위 명세서(Mini-Spec.) | 개체 관계도(ERD) | 상태 전이도(STD) | 제어 명세서 | . | . 3. 자료 흐름도(DFD) . 자료의 흐름 및 변환 과정과 기능을 도형 중심으로 기술 | 자료 흐름 그래프, 버블 차트라고도 함 | 자료 흐름과 처리를 중심으로 하는 구조적 분석 기법에 이용됨 | . 4. 자료 흐름도 기본 기호 . 기호 의미 . 프로세스(Process) | 자료를 변환시키는 시스템의 한 부분(처리 과정)을 나타내며 처리, 기능, 변환, 버블이라고도 함 | . 자료 흐름(Data Flow) | 자료의 이동(흐름)이나 연관관계를 나타냄 | . 자료 저장소(Data Store) | 시스템에서의 자료 저장소(파일, 데이터베이스)를 나타냄 | . 단말(Terminator) | 시스템과 교신하는 외부 개체로, 입력 데이터가 만들어지고 출력 데이터를 받음 | . . 5. 자료 사전(DD) . 자료 흐름도에 있는 자료를 더 자세히 정의하고 기록한 것 . | 메타데이터: 데이터를 설명하는 데이터. 데이터의 데이터 . | 기호 의미 . = | 정의: ~로 구성되어 있다 | . + | 연결: 그리고 | . () | 생략: 생략 가능한 자료 | . [] | 선택: 또는 | . {} | 반복: 아래에 최소, 위에 최대 횟수 표시 | . * * | 설명: 주석 | .   |   | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/03/08/theory8.html",
            "relUrl": "/theory/2021/03/08/theory8.html",
            "date": " • Mar 8, 2021"
        }
        
    
  
    
        ,"post211": {
            "title": "요구사항 개발 프로세스",
            "content": "1. 요구사항 개발 프로세스 . 개발 대상에 대한 요구사항을 체계적으로 도출.분석한 후 명세서에 정리한 다음 확인 및 검증 하는 일련의 구조화된 활동 | 타당성 조사(Feasibility Study)가 선행되어야 함 | 요구사항 개발은 요구공학의 한 요소 | . 도출(Elicitation) -&gt; 분석(Analysis) -&gt; 명세(Specification) -&gt; 확인(Validation) . 2. 요구사항 도출(수집) . 시스템 개발에 관련된 사람들이 서로 의견을 교환하여 요구사항을 어떻게 수집할 것인지를 식별하고 이해하는 과정 | 개발자와 고객 사이의 관계가 만들어지고 이해관계자가 식별됨 | 소프트웨어 개발 생명 주기(SDLC) 동안 지속적으로 반복됨 | 주요 도출 기법 청취와 인터뷰 | 설문 | 브레인스토밍 | 워크샵 | 프로토타이핑 | 유스케이스 | . | . 3. 요구사항 분석 . 사용자의 요구사항 중 명확하지 않거나 모호하여 이해되지 않는 부분을 발견하고 이를 걸러내기 위한 과정 | 타당성을 조사하고 비용과 일정에 대한 제약 설정 | 상충되는 요구사항 중재 | 사용되는 도구 자료 흐름도(DFD) | 자료 사전(DD) | . | . 4. 요구사항 명세 . 분석된 요구사항을 바탕으로 모델을 작성하고 문서화하는 것 | 기능 요구사항 빠짐없이 기술 | 비기능 요구사항 필요한 것만 기술 | 소단위 명세가 사용될 수 있음 | . 5. 요구사항 확인(검증) . 개발 자원을 요구사항에 할당하기 전에 요구사항 명세서가 정확하고 완전하게 작성되었는지 검토하는 활동 | 이해관계자들이 검토해야 함 | 요구사항 관리 도구를 이용하여 요구사항 정의 문서들에 대해 형상 관리(SCM) 수행 | . 6. 요구공학 . 무엇을 개발해야 하는지 요구사항을 정의하고, 분석 및 관리하는 프로세스를 연구하는 학문 | 요구사항 변경의 원인과 처리 방법을 이해, 품질 개선하여 프로젝트 실패 최소화 | . 7. 요구사항 명세 기법 . 구분 정형 명세 기법 비정형 명세 기법 . 기법 | 수학적 원리, 모델 기반 | 상태/기능/객체 중심 | . 작성 방법 | 수학적 기호, 정형화된 표기법 | 일반 명사, 동사 등의 자연어 기반 서술/다이어그램 | . 특징 | -요구사항을 정확하고 간결하게 표현 가능-요구사항에 대한 결과 일관적이므로 완전성 검증 가능-표기법이 어려워 사용자가 이해하기 어려움 | -자연어의 사용으로 인해 일관성 떨어지고 해석 달라질 수 있음-내용의 이해가 쉬워 의사소통 용이 | . 종류 | VDM, Z, Petri-net, CSP | FSM, Decision Table, ER모델링, State Chart(SADT) | . 타당성 조사 . 개발 프로세스가 비즈니스 목적에 부합되는지, 예산은 적정한지 등에 대한 정보를 수집, 평가한 보고서를 토대로 수행 . 형상 관리(SCM) . 소프트웨어 개발 단계의 각 과정에서 만들어지는 프로그램, 설명 문서, 데이터 등을 통칭하여 형상이라고 함 . 형상 관리: 형상들의 변경 사항을 관리하는 일련의 활동 .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/03/07/theory7.html",
            "relUrl": "/theory/2021/03/07/theory7.html",
            "date": " • Mar 7, 2021"
        }
        
    
  
    
        ,"post212": {
            "title": "요구사항 정의",
            "content": "1. 요구사항 . 요구사항은 소프트웨어가 어떤 문제를 해결하기 위해 제공하는 서비스에 대한 설명 과 정상적으로 운영되는데 필요한 제약조건 | 소프트웨어 개발이나 유지 보수 과정에서 필요한 기준과 근거를 제공 | 개발에 참여하는 이해관계자들 간의 의사소통을 원활하게 하는 데 도움 | 유형 기능 요구사항(Functional requirements) | 비기능 요구사항(Non-functional requirements) | 사용자 요구사항(User requirements) | 시스템 요구사항(System requirements) | . | . 2. 기능 요구사항 . 시스템이 무엇을 하는지, 어떤 기능을 하는지 등의 기능이나 수행과 관련된 요구사항 | 시스템의 입력이나 출력으로 무엇이 포함되어야 하는지에 대한 사항 | 시스템이 어떤 데이터를 저장하거나 연산을 수행해야 하는지에 대한 사항 | 시스템이 반드시 수행해야 하는 기능 | 사용자가 시스템을 통해 제공받기 원하는 기능 | . 3. 비기능 요구사항 . 품질이나 제약사항과 관련된 요구사항 | 시스템 장비 구성 요구사항 | 성능 요구사항 | 인터페이스 요구사항 | 데이터 구축에 필요한 요구사항 | 테스트 요구사항 | 보안 요구사항 | 품질 요구사항: 가용성, 정합성, 상호 호환성, 대응성, 이식성, 확장성, 보안성 등 | 제약사항 | 프로젝트 관리 요구사항 | 프로젝트 자원 요구사항 | . 4. 사용자 요구사항 . 사용자 관점에서 본 시스템이 제공해야 할 요구사항 | 사용자를 위한 것으로, 친숙한 표현으로 이해하기 쉽게 작성 | . 5. 시스템 요구사항 . 개발자 관점에서 본 시스템 전체가 사용자와 다른 시스템에 제공해야 할 요구사항 | 전문적이고 기술적인 용어로 표현 | 소프트웨어 요구사항이라고도 함 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/03/06/theory6.html",
            "relUrl": "/theory/2021/03/06/theory6.html",
            "date": " • Mar 6, 2021"
        }
        
    
  
    
        ,"post213": {
            "title": "개발 기술 환경 파악의 개요",
            "content": "1. 개발 기술 환경 파악의 개요 . 개발하고자 하는 소프트웨어와 관련된 운영체제(OS), 데이터베이스 관리 시스템(DBMS), 미들웨어 등을 선정할 때 고려해야 할 사항을 기술하고 오픈소스를 사용할 때 주의해야 할 내용 제시 . 2. 운영체제(OS) . 운영체제는 컴퓨터 시스템의 자원을 효율적으로 관리하며 사용자가 컴퓨터를 편리하고 효율적으로 사용할 수 있도록 환경을 제공하는 소프트웨어 | 컴퓨터 사용자와 컴퓨터 하드웨어 간의 인터페이스로서 동작하는 시스템 소프트웨어의 일종 | 다른 응용 프로그램이 유용한 작업을 할 수 있도록 환경 제공 | 운영체제 관련 요구사항 식별 시 고려사항 가용성 | 성능 | 기술 지원 | 구축 비용 | 주변 기기 | . | . 3. 데이터베이스 관리 시스템(DBMS) . 데이터베이스 관리 시스템은 사용자와 데이터베이스 사이에서 사용자의 요구에 따라 정보를 생성하고 데이터베이스를 관리해주는 소프트웨어 | 기존의 파일 시스템이 갖는 데이터의 종속성과 중복성의 문제를 해결하기 위해 제안된 시스템 | 모든 응용 프로그램들이 데이터베이스를 공용할 수 있도록 관리 | DBMS 관련 요구사항 식별 시 고려사항 가용성 | 성능 | 기술 지원 | 구축 비용 | 상호 호환성 | . | . 4. 웹 애플리케이션 서버(WAS) . 사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어 | 데이터 접근, 세션 관리, 트랜잭션 관리 등을 위한 라이브러리 제공 | 주로 데이터베이스 서버와 연동해서 사용 | WAS 관련 요구사항 식별 시 고려사항 가용성 | 성능 | 기술 지원 | 구축 비용 | . | . 5. 오픈 소스(Open Source) . 오픈 소스는 누구나 별다른 제한 없이 사용할 수 있도록 소스 코드를 공개한 소프트웨어 | 오픈 소스 라이선스 만족 | 오픈 소스 관련 요구사항 식별 시 고려사항 라이선스의 종류 | 사용자 수 | 기술의 지속 가능성 | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/03/05/theory5.html",
            "relUrl": "/theory/2021/03/05/theory5.html",
            "date": " • Mar 5, 2021"
        }
        
    
  
    
        ,"post214": {
            "title": "현행 시스템 파악",
            "content": "1. 현행 시스템 파악 절차 . 프로세스 현행 시스템 내용 . 1단계 | 시스템 구성 파악 | 조직의 주요 업무를 담당하는 기간 업무와 이를 지원하는 지원 업무로 구분하여 기술 | .   | 시스템 기능 파악 | 현재 제공하는 기능들을 주요 기능과 하부 기능, 세부 기능으로 구분하여 계층형으로 표시 | .   | 시스템 인터페이스 파악 | 단위 업무 시스템 간에 주고받는 데이터의 종류, 형식, 프로토콜, 연계 유형, 주기 등을 명시 | . 2단계 | 아키텍처 구성 파악 | 최상위 수준에서 계층별로 표현한 아키텍처 구성도 작성 | .   | 소프트웨어 구성 파악 | 소프트웨어들의 제품명, 용도, 라이선스 적용 방식, 라이선스 수 등을 명시 | . 3단계 | 하드웨어 구성 파악 | 단위 업무 시스템들이 운용되는 서버의 주요 사양과 수량, 서버의 이중화 적용 여부 명시 | .   | 네트워크 구성 파악 | 서버의 위치, 서버 간의 네트워크 연결 방식을 네트워크 구성도로 작성 | . *서버의 주요 사양 . 서버의 CPU 처리 속도, 메모리 크기, 하드디스크의 용량 등을 파악해서 명시 . *서버의 이중화 . 운용 서버에 장애가 발생했을 때 대기 서버에서 서비스를 계속 유지할 수 있도록 대기 서버에도 동일하게 복제되도록 관리하는 것 .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/03/04/theory4.html",
            "relUrl": "/theory/2021/03/04/theory4.html",
            "date": " • Mar 4, 2021"
        }
        
    
  
    
        ,"post215": {
            "title": "XP 기법",
            "content": "1. XP(eXtreme Programming) . 수시로 발생하는 고객의 요구사항에 유연하게 대응하기 위해 고객의 참여와 개발 과정의 반복을 극대화하여 개발 생산성 향상 | 짧고 반복적 개발 주기, 단순한 설계, 고객의 적극적 참여를 통해 소프트웨어 빠르게 개발하는 것 목표 | 릴리즈 기간 짧게 반복 -&gt; 고객의 요구사항 반영에 대한 가시성 높임 | XP의 5가지 핵심 가치(용단의 피존) 용기 | 단순성 | 의사소통 | 피드백 | 존중 | . | . 2. XP 개발 프로세스 . 프로세스 내용 . 릴리즈 계획 수립 | -부분/전체 개발 완료 시점에 대한 일정 수립-부분적으로 기능이 완료된 제품 제공하는 것: 릴리즈 | . 이터레이션(주기) | 개발 작업 진행 과정 (1~3주) | . 승인 검사(인수 테스트) | 한 이터레이션 내 부분 완료 제품 구현되면 수행하는 테스트 | . 소규모 릴리즈 | 릴리즈의 규모를 축소한 것(요구사항에 유연하게 대응) | . 3. XP의 주요 실천 방법 . 실천 방법 내용 . 짝 프로그래밍(Pair Programming) | 다른 사람과 함께 프로그래밍 수행하여 개발 책임 나눠 갖는 환경 조성 | . 공동 코드 소유(Collective Ownership) | 개발 코드에 대한 권한과 책임 공동 소유 | . 테스트 주도 개발(Test-Driven Development) | -실제 코드 작성 전 테스트케이스 먼저 작성하여 무엇을 해야할지 정확히 파악-테스트가 지속적으로 진행될 수 있도록 자동화된 테스팅 도구(구조, 프레임워크) 사용 | . 전체 팀(Whole Team) | 개발에 참여하는 모든 구성원(고객 포함)들은 각자 자신의 역할이 있고 책임 가져야 함 | . 계속적인 통합(Continuous Integration) | 모듈 단위로 나눠서 개발된 코드들은 하나의 작업이 마무리될 때마다 지속적으로 통합됨 | . **리팩토링(Refactoring)** | -프로그램 기능의 변경 없이 시스템을 재구성-목적: 프로그램을 쉽게 이해하고 수정하여 빠르게 개발 | . 소규모 릴리즈(Small Release) | 릴리즈 기간을 짧게 반복하여 요구 변화에 신속히 대응 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/03/03/theory3.html",
            "relUrl": "/theory/2021/03/03/theory3.html",
            "date": " • Mar 3, 2021"
        }
        
    
  
    
        ,"post216": {
            "title": "스크럼 기법",
            "content": "1. 스크럼(Scrum) . 팀이 중심이 되어 개발의 효율성을 높이는 기법 | 팀원 스스로가 스크럼 팀을 구성하고 개발 작업 스스로 해결 | . 2. 스크럼 팀 . 구성원 역할 . 제품 책임자(PO) | -요구사항이 담긴 백로그를 작성하는 주체-이해관계자들 중 개발될 제품에 대한 이해도가 높고 요구사항을 책임지고 이해를 결정할 사람 | . 스크럼 마스터(SM) | 스크럼 팀의 가이드 역할 | . 개발팀(DT) | 위 구성원 제외 모든 팀원. 개발 수행 | . 백로그: 제품 개발에 필요한 모든 요구사항의 우선순위를 부여한 목록 . 3. 스크럼 개발 프로세스 . Product Backlog -&gt; Sprint Backlog(스프린트 계획 회의) -&gt; 스프린트 수행(매일 일일 스크럼 회의) -&gt; 스프린트 검토 회의, 스프린트 회고 . 프로세스 내용 . 스프린트 계획 회의 | 제품 백로그 중 이번 스프린트에서 수행할 작업 대상으로 단기 일정 수립 | . 스프린트 | 개발 작업 진행. 2~4주 기간 | . 일일 스크럼 회의 | - 모든 팀원이 매일 약 15분 동안 진행 상황 점검- 남은 작업 시간 소멸 차트에 표시 | . 스프린트 검토 회의 | 부분/전체 완성 제품이 요구사항에 잘 부합하는지 테스팅 | . 스프린트 회고 | 정해놓은 규칙 준수 여부 및 개선 사항 확인, 기록 | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/03/02/theory2.html",
            "relUrl": "/theory/2021/03/02/theory2.html",
            "date": " • Mar 2, 2021"
        }
        
    
  
    
        ,"post217": {
            "title": "소프트웨어 생명 주기",
            "content": "1. 소프트웨어 생명 주기 . 소프트웨어를 개발하기 위한 설계, 운용, 유지보수 등의 과정을 각 단계별로 나눈 것 | sw 개발 단계 + 각 단계별 주요 활동 + 활동 결과 산출물 폭포수 모형 | 프로토타입 모형 | 나선형 모형 | 애자일 모형 | . | . 2. 폭포수 모형 . 각 단계를 확실히 매듭짓고 철저하게 검토 후 다음 단계로 진행 | 이전 단계로 돌아갈 수 없음 | 가장 오래되고 폭넓게 사용된 전통적인 모형 | 적용한 경험과 성공 사례 많음 | 각 단계 종료 시 명확한 결과물 산출 필요 | . 3. 프로토타입 모형 . 실제 개발될 소프트웨어에 대한 견본품(프로토타입)을 만들어 최종 결과물 예측하는 모형 | 사용자와 시스템 사이의 인터페이스에 중점을 두어 개발 | . 4. 나선형 모형 . 여러 번의 소프트웨어 개발 과정 반복하여 점진적으로 최종 완성하는 모형 | 보헴(Bohem)이 제안 | 폭포수, 프로토타입의 장점 + 위험 분석 기능 추가 | 누락되거나 추가된 요구사항 추가 가능 | 유지보수 과정 불필요 | . 계획 수립 -&gt; 위험 분석 -&gt; 개발 및 검증 -&gt; 고객 평가 -&gt; 계획 수립 .. . 5. 애자일 모형 . 고객의 요구사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하며 개발하는 모형 | 고객과의 소통에 초점을 맞춘 방법론 통칭 | 폭포수 모형과 대조적 | 대표적 개발 모형 스크럼(Scrum) | XP(eXtreme Programming) | 칸반(Kanban) | Lean | 기능 중심 개발(FDD: Feature Driven Development) | . | 4가지 핵심 가치 개인과 상호작용 &gt; 프로세스, 도구 | 실행되는 SW &gt; 방대한 문서 | 고객과 협업 &gt; 계약 협상 | 변화에 반응 &gt; 계획 | . | . 6. 소프트웨어 공학 . 소프트웨어 위기를 극복하기 위한 방안으로 연구된 학문 . 여러 방법론과 도구, 관리 기법을 통한 SW의 품질과 생산성 향상 목적 | 기본 원칙 현대적인 프로그래밍 기술을 계속적으로 적용해야 한다. | 개발된 sw의 품질이 유지되도록 지속적으로 검증해야 한다. | sw 개발 관련 사항 및 결과에 대한 명확한 기록을 유지해야 한다. | . | .",
            "url": "https://eunkyung99.github.io/gang/theory/2021/03/01/theory1.html",
            "relUrl": "/theory/2021/03/01/theory1.html",
            "date": " • Mar 1, 2021"
        }
        
    
  
    
        ,"post218": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://eunkyung99.github.io/gang/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "김은경 . 한국외국어대학교 컴퓨터.전자시스템공학부 18학번 데이터와 웹 개발, 교육에 관심이 많은 개발자입니다. . 📧 kek9520@naver.com . 🔗 깃허브 페이지 . ✍🏻 블로그 페이지 . . 🔎한 눈에 보기 . *자세히 보기: 원본 페이지 . *하이퍼링크 항목을 클릭하면 상세 설명 페이지로 이동합니다. . . 👩🏻‍🎓 현재 . 한국외국어대학교 글로벌캠퍼스 컴퓨터.전자시스템공학부 4학년 | 데이터, 웹 개발에 관심이 많은 개발자 | 전공심화+스페인어통.번역학과 부전공 | 총 학점: 4.2 / 4.5 (130학점 이수) | 전공 학점: 4.25 / 4.5 (74학점 이수) | . 👩🏻‍💼 프로젝트 . 2020.07-2020.08 제이엠스마트 현장 실습(2개월) | 웹 개발 업무 수행 php, HTML, javascript 사용 | . | 2020.11~2021.08 학부연구생 연구 진행(10개월) . 압축 적용 Erasure coding 성능 실험 . | RISC-V VP 기반 CNN 딥러닝 가속기 시스템에서 Object Detection 일부 구현 . | . | 2021.01-2021.02 SJSU SVSTIP 해외교육 카페 추천 앱 개발 프로젝트 | 무료 호스팅 사이트 서버 구축 및 DB 관리 | Java 기반 안드로이드 앱 개발 | 팀 2등 상, 개인 우수상(3명 중 1명) 수상 | . | 2021.03-2021.05 캡스톤 프로젝트 키오스크 대치 앱 시스템 개발 | AWS 서버, 데이터베이스 구축 및 관리 | kotlin 기반 안드로이드 앱 개발 | . | 2021.09- 메디칼스탠다드 인턴(4개월) 웹 개발 업무 수행 - 하이퍼링크 수정 | node.js 사용 | . | . 🌟 외부 활동 . 2018.11 교내 이공계 학술제 참가 | 교내 빅데이터 학회 소속 - 데이터 분석 공부 dacon 대회 공부 | . | 2021.07 삼성 SDS 알고리즘 교육 수료 | 2021.08 교내 알고리즘 특강 교육 수료 | . 🎖️ 자격증 . 토익 895 / 990 2021.04 취득 | 오픽 IH 2021.08 취득 | ADsP(데이터 분석 준전문가) 2021.03 취득 | SQLD(SQL 개발자) 2021.03 취득 | 정보처리기사 2021.08 취득 | . 👩🏻‍🏫 교육 활동 . 2019.03-2019.06 교내 튜터링 프로그램 참가 과 후배들에게 C 언어 튜터링 진행 | . | 2019.07-2019.08 월드프렌즈 봉사활동 코스타리카🇨🇷에서 IT 교육 진행 | . | 2021.07~ 한국외대 SW 봉사단 초등학생 대상 sw 관련 수업 보조 sw와 3D 입체 교육 수업 | sw와 환경 융합 교육 수업 | . | . | . 🏆 수상 내역 . 교내 TOPCIT 성적 우수상(2021.05 응시) | . 👩🏻‍🎨 성격 . 부족한 점 → 배우려는 자세 | 정리, 발표하는 습관 → 원활한 소통 | 다양한 분야에 관심이 많음 | 응용하는 것을 좋아함 | . . Web Programming . AI &amp; Data Study . Application . Education . 전공이수학점 내역 .",
          "url": "https://eunkyung99.github.io/gang/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  

  
  

  

  
  

  

  
  

  
  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  
  

  
      ,"page25": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://eunkyung99.github.io/gang/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}