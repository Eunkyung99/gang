---
layout: post
categories: [theory]
comments: true
title: "디자인 패턴"
date: 2021-05-19 17:31:23
typora-copy-images-to: upload
---

#### 1. 디자인 패턴

- 모듈 간의 관계 및 인터페이스를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제
- `문제 및 배경, 실제 적용된 사례, 재사용이 가능한 샘플 코드` 등으로 구성
- '바퀴를 다시 발명하지 마라'라는 말과 같이 개발 과정 중에 문제가 발생하면 새로 해결책을 구상하는 것보다 문제에 해당하는 디자인 패턴을 참고하여 적용하는 것이 더 효율적임
- GOF의 디자인 패턴은 생성 패턴, 구조 패턴, 행위 패턴으로 구분됨

#### 2. 생성 패턴

- **클래스나 객체의 생성과 참조 과정을 정의**하는 패턴
- `추상 팩토리`
  - 구체적인 클래스에 의존하지 않고, `인터페이스를 통해 서로 연관.의존하는 객체들의 그룹으로 생성하여 추상적으로 표현`
  - 연관된 서브 클래스를 묶어 한 번에 교체하는 것이 가능함 
- `빌더`
  - `작게 분리된 인스턴스를 건축하듯이 조합`하여 객체를 생성
  - 객체의 생성 과정과 표현 방법을 분리하고 있어, 동일한 객체 생성에서도 서로 다른 결과를 만들어 낼 수 있음 
- `팩토리 메소드`
  - `객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴`
  - 상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당함
  - 가상 생성자 패턴이라고도 함 
- `프로토타입`
  - `원본 객체를 복제`하는 방법으로 객체를 생성하는 패턴
  - 일반적인 방법으로 객체를 생성하며, 비용이 큰 경우 주로 이용함 
- `싱글톤 `
  - 하나의 객체를 생성하면 `생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수는 없음`
  - 클래스 내에서 인스턴스가 하나뿐임을 보장하며, 불필요한 메모리 낭비를 최소화할 수 있음

* `추상 팩토리`는 서로 `다른 부품을 조립만 하는 조립 공장`, `빌더`는 `건축가각 블록을 조립`하는 모습, `팩토리 메소드`는 `부품부터 완성까지 통째로 찍어내는 공장`, `프로토타입`은 `원형을 두고 복제품을 만드는 것`, `싱글톤`은 식당에서 `누구나 사용할 수 있지만 하나뿐인 정수기`이다.

#### 3. 구조 패턴

- 구조가 복잡한 시스템을 개발하기 쉽도록 **클래스나 객체들을 조합하여 더 큰 구조로 만드는 패턴**
- `어댑터`
  - `호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환`해주는 패턴
  - 기존의 클래스를 이용하고 싶지만 인터페이스가 일치하지 않을 때 이용함 
- `브리지`
  - 구현부에서 추상층을 분리하여 `서로가 독립적으로 확장할 수 있도록 구성`한 패턴
  - 기능과 구현을 `두 개의 별도 클래스로 구현` 
- `컴포지트`
  - 여러 객체를 가진 `복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용하는 패턴`
  - 객체들을 트리 구조로 구성하여 디렉터리 안에 디렉터리가 있듯이 `복합 객체 안에 복합 객체가 포함되는 구조 구현 가능`
- `데코레이터`
  - 객체 간의 결합을 통해 `능동적으로 기능들을 확장할 수 있는 패턴`
  - 임의의 객체에 부가적인 기능을 추가하기 위해 `다른 객체들을 덧붙이는 방식`으로 구현
- `퍼싸드`
  - 복잡한 서브 클래스들을 피해 더 `상위에 인터페이스를 구성`함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴
  - 서브 클래스들 사이의 통합 인터페이스를 제공하는 Wrapper 객체가 필요 
- `플라이웨이트`
  - 인스턴스가 필요할 때마다 매번 생성하는 것이 아니고 `가능한 한 공유해서 사용함으로써 메모리를 절약`하는 패턴
  - 다수의 유사 객체를 생성하거나 조작할 때 유용하게 사용할 수 있음
- `프록시`
  - `접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴`
  - 네트워크 연결, 메모리의 대용량 객체로의 접근 등에 주로 이용
- `어댑터`는 전압을 맞춰주는 `변압기`, `브리지`는 두 섬을 연결하는 `다리`, `컴포지트`는 `폴더와 파일을 합성`한 것, `데코레이터`는 온갖 것으로 `장식된 눈사람`, `퍼싸드`는 `외부의 리모컨 버튼`만으로 복잡한 명령들을 간편하게 수행하는 것, `플라이웨이트`는 `부담을 가볍게 하기 위해 물품을 공유`하는 것, `프록시`는 내가 하기 어려운 법률업무를 대리해서 처리해주는 `변호사`이다.

#### 4. 행위 패턴

- 클래스나 객체들이 **서로 상호작용하는 방법이나 책임 분배 방법을 정의**하는 패턴
- `책임 연쇄`
  - 요청을 처리할 수 있는 `객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태`의 패턴
  - 요청을 처리할 수 있는 각 객체들이 고리로 묶여 있어 `요청이 해결될 때까지 고리를 따라 책임이 넘어감 `
- `커맨드`
  - `요청을 객체의 형태로 캡슐화`하여 `재이용하거나 취소`할 수 있도록 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴
  - 요청에 사용되는 각종 명령어들을 추상 클래스와 구체 클래스로 분리하여 단순화함
- `인터프리터`
  - 언어에 `문법 표현을 정의`하는 패턴
  - SQL이나 통신 프로토콜과 같은 것을 개발할 때 사용
- `반복자`
  - 자료 구조와 같이 `접근이 잦은 객체에 대해 동일한 인터페이스를 사용`하도록 하는 패턴
  - 내부 표현 방법의 노출 없이 순차적인 접근이 가능 
- `중재자`
  - `수많은 객체들 간의 복잡한 상호작용을 캡슐화`하여 객체로 정의하는 패턴
  - 객체 사이의 `의존성을 줄여 결합도를 감소`시킬 수 있음 
- `메멘토`
  - 특정 시점에서의 객체 내부 상태를 객체화함으로써 이후 요청에 따라 객체를 `해당 시점의 상태로 돌릴 수 있는 기능을 제공`하는 패턴
  - Ctrl+Z와 같은 되돌리기 기능을 개발할 때 주로 이용
- `옵서버`
  - 한 객체의 `상태가 변화하면` 객체에 `상속되어 있는 다른 객체들에게 변화된 상태를 전달`하는 패턴
  - 일대다의 의존성을 정의함
  - 주로 `분산된 시스템 간에 이벤트를 생성.발행`하고, 이를 수신해야 할 때 이용
- `상태`
  - `객체의 상태에 따라 동일한 동작을 다르게 처리`해야 할 때 사용하는 패턴
  - 객체 상태를 캡슐화하고 이를 참조하는 방식으로 처리
- `전략`
  - `동일한 계열의 알고리즘들을 개별적으로 캡슐화`하여 `상호 교환`할 수 있게 정의하는 패턴
  - 클라이언트는 독립적으로 원하는 알고리즘을 선택하여 사용할 수 있으며, 클라이언트에 영향 없이 알고리즘의 변경이 가능함
- `템플릿 메소드`
  - `상위 클래스에서 골격을 정의`하고, `하위 클래스에서 세부 처리를 구체화`하는 구조의 패턴
  - 유사한 서브 클래스를 묶어 공통된 내용을 상위 클래스에서 정의함으로써 코드의 양을 줄이고 유지보수를 용이하게 해줌 
- `방문자`
  - `각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성`하는 패턴
  - `분리된 처리 기능은 각 클래스를 방문하여 수행함 `
- `책임 연쇄`는 위에서 쏟아지는 물을 여러 물받이가 연속해서 나눠 받는 `물레방아`, `커맨드`는 각종 `명령어를 하나로 합쳐둔 것`, `인터프리터`는 `언어 번역기`, `반복자`는 음악 파일의 다음 곡 재생처럼 같은 `명령어 반복`, `중재자`는 물품 예매를 `중개`해주는 인터넷 사이트, `메멘토`는 `기억 속의 그 때로 돌아가는 것`, `옵서버`는 `변화를 지켜보고 알려주는 것`, `상태`는 환자의 `상태에 따라 치료방법이 다른 것`, `전략`은 여러 전략들을 정하고 `필요할 때 원하는 전략을 선택`하여 쓰는 것, `템플릿 메소드`는 세모, 네모, 동그라미를 그리는 방법들을 도형이라는 `하나의 큰 틀로 묶는 것`, `방문자`는 책을 만들기 위해 저자, 편집자, 홍보팀을 `번갈아가며 방문`하는 것이다.